
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Diversity
 * 
 */
export type Diversity = $Result.DefaultSelection<Prisma.$DiversityPayload>
/**
 * Model AdditionalDetail
 * 
 */
export type AdditionalDetail = $Result.DefaultSelection<Prisma.$AdditionalDetailPayload>
/**
 * Model Preference
 * 
 */
export type Preference = $Result.DefaultSelection<Prisma.$PreferencePayload>
/**
 * Model MaritalStatus
 * 
 */
export type MaritalStatus = $Result.DefaultSelection<Prisma.$MaritalStatusPayload>
/**
 * Model Religion
 * 
 */
export type Religion = $Result.DefaultSelection<Prisma.$ReligionPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model MotherTongue
 * 
 */
export type MotherTongue = $Result.DefaultSelection<Prisma.$MotherTonguePayload>
/**
 * Model Astrology
 * 
 */
export type Astrology = $Result.DefaultSelection<Prisma.$AstrologyPayload>
/**
 * Model Connection
 * 
 */
export type Connection = $Result.DefaultSelection<Prisma.$ConnectionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.diversity`: Exposes CRUD operations for the **Diversity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diversities
    * const diversities = await prisma.diversity.findMany()
    * ```
    */
  get diversity(): Prisma.DiversityDelegate<ExtArgs>;

  /**
   * `prisma.additionalDetail`: Exposes CRUD operations for the **AdditionalDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdditionalDetails
    * const additionalDetails = await prisma.additionalDetail.findMany()
    * ```
    */
  get additionalDetail(): Prisma.AdditionalDetailDelegate<ExtArgs>;

  /**
   * `prisma.preference`: Exposes CRUD operations for the **Preference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preferences
    * const preferences = await prisma.preference.findMany()
    * ```
    */
  get preference(): Prisma.PreferenceDelegate<ExtArgs>;

  /**
   * `prisma.maritalStatus`: Exposes CRUD operations for the **MaritalStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaritalStatuses
    * const maritalStatuses = await prisma.maritalStatus.findMany()
    * ```
    */
  get maritalStatus(): Prisma.MaritalStatusDelegate<ExtArgs>;

  /**
   * `prisma.religion`: Exposes CRUD operations for the **Religion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Religions
    * const religions = await prisma.religion.findMany()
    * ```
    */
  get religion(): Prisma.ReligionDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs>;

  /**
   * `prisma.motherTongue`: Exposes CRUD operations for the **MotherTongue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MotherTongues
    * const motherTongues = await prisma.motherTongue.findMany()
    * ```
    */
  get motherTongue(): Prisma.MotherTongueDelegate<ExtArgs>;

  /**
   * `prisma.astrology`: Exposes CRUD operations for the **Astrology** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Astrologies
    * const astrologies = await prisma.astrology.findMany()
    * ```
    */
  get astrology(): Prisma.AstrologyDelegate<ExtArgs>;

  /**
   * `prisma.connection`: Exposes CRUD operations for the **Connection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Connections
    * const connections = await prisma.connection.findMany()
    * ```
    */
  get connection(): Prisma.ConnectionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.13.0
   * Query Engine version: b9a39a7ee606c28e3455d0fd60e78c3ba82b1a2b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Diversity: 'Diversity',
    AdditionalDetail: 'AdditionalDetail',
    Preference: 'Preference',
    MaritalStatus: 'MaritalStatus',
    Religion: 'Religion',
    Country: 'Country',
    City: 'City',
    Community: 'Community',
    MotherTongue: 'MotherTongue',
    Astrology: 'Astrology',
    Connection: 'Connection'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'diversity' | 'additionalDetail' | 'preference' | 'maritalStatus' | 'religion' | 'country' | 'city' | 'community' | 'motherTongue' | 'astrology' | 'connection'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Diversity: {
        payload: Prisma.$DiversityPayload<ExtArgs>
        fields: Prisma.DiversityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiversityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiversityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          findFirst: {
            args: Prisma.DiversityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiversityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          findMany: {
            args: Prisma.DiversityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>[]
          }
          create: {
            args: Prisma.DiversityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          createMany: {
            args: Prisma.DiversityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DiversityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          update: {
            args: Prisma.DiversityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          deleteMany: {
            args: Prisma.DiversityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DiversityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DiversityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          aggregate: {
            args: Prisma.DiversityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiversity>
          }
          groupBy: {
            args: Prisma.DiversityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiversityGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiversityCountArgs<ExtArgs>,
            result: $Utils.Optional<DiversityCountAggregateOutputType> | number
          }
        }
      }
      AdditionalDetail: {
        payload: Prisma.$AdditionalDetailPayload<ExtArgs>
        fields: Prisma.AdditionalDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdditionalDetailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdditionalDetailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          findFirst: {
            args: Prisma.AdditionalDetailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdditionalDetailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          findMany: {
            args: Prisma.AdditionalDetailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>[]
          }
          create: {
            args: Prisma.AdditionalDetailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          createMany: {
            args: Prisma.AdditionalDetailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdditionalDetailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          update: {
            args: Prisma.AdditionalDetailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          deleteMany: {
            args: Prisma.AdditionalDetailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdditionalDetailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdditionalDetailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          aggregate: {
            args: Prisma.AdditionalDetailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdditionalDetail>
          }
          groupBy: {
            args: Prisma.AdditionalDetailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdditionalDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdditionalDetailCountArgs<ExtArgs>,
            result: $Utils.Optional<AdditionalDetailCountAggregateOutputType> | number
          }
        }
      }
      Preference: {
        payload: Prisma.$PreferencePayload<ExtArgs>
        fields: Prisma.PreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload>
          }
          findFirst: {
            args: Prisma.PreferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload>
          }
          findMany: {
            args: Prisma.PreferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload>[]
          }
          create: {
            args: Prisma.PreferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload>
          }
          createMany: {
            args: Prisma.PreferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PreferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload>
          }
          update: {
            args: Prisma.PreferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload>
          }
          deleteMany: {
            args: Prisma.PreferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PreferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PreferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferencePayload>
          }
          aggregate: {
            args: Prisma.PreferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePreference>
          }
          groupBy: {
            args: Prisma.PreferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<PreferenceCountAggregateOutputType> | number
          }
        }
      }
      MaritalStatus: {
        payload: Prisma.$MaritalStatusPayload<ExtArgs>
        fields: Prisma.MaritalStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaritalStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaritalStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          findFirst: {
            args: Prisma.MaritalStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaritalStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          findMany: {
            args: Prisma.MaritalStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>[]
          }
          create: {
            args: Prisma.MaritalStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          createMany: {
            args: Prisma.MaritalStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MaritalStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          update: {
            args: Prisma.MaritalStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          deleteMany: {
            args: Prisma.MaritalStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MaritalStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MaritalStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          aggregate: {
            args: Prisma.MaritalStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMaritalStatus>
          }
          groupBy: {
            args: Prisma.MaritalStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MaritalStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaritalStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<MaritalStatusCountAggregateOutputType> | number
          }
        }
      }
      Religion: {
        payload: Prisma.$ReligionPayload<ExtArgs>
        fields: Prisma.ReligionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReligionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReligionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          findFirst: {
            args: Prisma.ReligionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReligionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          findMany: {
            args: Prisma.ReligionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>[]
          }
          create: {
            args: Prisma.ReligionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          createMany: {
            args: Prisma.ReligionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReligionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          update: {
            args: Prisma.ReligionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          deleteMany: {
            args: Prisma.ReligionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReligionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReligionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          aggregate: {
            args: Prisma.ReligionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReligion>
          }
          groupBy: {
            args: Prisma.ReligionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReligionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReligionCountArgs<ExtArgs>,
            result: $Utils.Optional<ReligionCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>,
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>,
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      MotherTongue: {
        payload: Prisma.$MotherTonguePayload<ExtArgs>
        fields: Prisma.MotherTongueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MotherTongueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MotherTongueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          findFirst: {
            args: Prisma.MotherTongueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MotherTongueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          findMany: {
            args: Prisma.MotherTongueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>[]
          }
          create: {
            args: Prisma.MotherTongueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          createMany: {
            args: Prisma.MotherTongueCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MotherTongueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          update: {
            args: Prisma.MotherTongueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          deleteMany: {
            args: Prisma.MotherTongueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MotherTongueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MotherTongueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          aggregate: {
            args: Prisma.MotherTongueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMotherTongue>
          }
          groupBy: {
            args: Prisma.MotherTongueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MotherTongueGroupByOutputType>[]
          }
          count: {
            args: Prisma.MotherTongueCountArgs<ExtArgs>,
            result: $Utils.Optional<MotherTongueCountAggregateOutputType> | number
          }
        }
      }
      Astrology: {
        payload: Prisma.$AstrologyPayload<ExtArgs>
        fields: Prisma.AstrologyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AstrologyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AstrologyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          findFirst: {
            args: Prisma.AstrologyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AstrologyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          findMany: {
            args: Prisma.AstrologyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>[]
          }
          create: {
            args: Prisma.AstrologyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          createMany: {
            args: Prisma.AstrologyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AstrologyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          update: {
            args: Prisma.AstrologyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          deleteMany: {
            args: Prisma.AstrologyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AstrologyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AstrologyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          aggregate: {
            args: Prisma.AstrologyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAstrology>
          }
          groupBy: {
            args: Prisma.AstrologyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AstrologyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AstrologyCountArgs<ExtArgs>,
            result: $Utils.Optional<AstrologyCountAggregateOutputType> | number
          }
        }
      }
      Connection: {
        payload: Prisma.$ConnectionPayload<ExtArgs>
        fields: Prisma.ConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findFirst: {
            args: Prisma.ConnectionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findMany: {
            args: Prisma.ConnectionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          create: {
            args: Prisma.ConnectionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          createMany: {
            args: Prisma.ConnectionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConnectionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          update: {
            args: Prisma.ConnectionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          deleteMany: {
            args: Prisma.ConnectionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConnectionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          aggregate: {
            args: Prisma.ConnectionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConnection>
          }
          groupBy: {
            args: Prisma.ConnectionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionCountArgs<ExtArgs>,
            result: $Utils.Optional<ConnectionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sentConnections: number
    receivedConnections: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentConnections?: boolean | UserCountOutputTypeCountSentConnectionsArgs
    receivedConnections?: boolean | UserCountOutputTypeCountReceivedConnectionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }


  /**
   * Count Type MaritalStatusCountOutputType
   */

  export type MaritalStatusCountOutputType = {
    users: number
    Preference: number
  }

  export type MaritalStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MaritalStatusCountOutputTypeCountUsersArgs
    Preference?: boolean | MaritalStatusCountOutputTypeCountPreferenceArgs
  }

  // Custom InputTypes
  /**
   * MaritalStatusCountOutputType without action
   */
  export type MaritalStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatusCountOutputType
     */
    select?: MaritalStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaritalStatusCountOutputType without action
   */
  export type MaritalStatusCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * MaritalStatusCountOutputType without action
   */
  export type MaritalStatusCountOutputTypeCountPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenceWhereInput
  }


  /**
   * Count Type ReligionCountOutputType
   */

  export type ReligionCountOutputType = {
    Diversity: number
    Preference: number
  }

  export type ReligionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | ReligionCountOutputTypeCountDiversityArgs
    Preference?: boolean | ReligionCountOutputTypeCountPreferenceArgs
  }

  // Custom InputTypes
  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionCountOutputType
     */
    select?: ReligionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeCountPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenceWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    cities: number
    Diversity: number
    Preference: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | CountryCountOutputTypeCountCitiesArgs
    Diversity?: boolean | CountryCountOutputTypeCountDiversityArgs
    Preference?: boolean | CountryCountOutputTypeCountPreferenceArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenceWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    Diversity: number
    Preference: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | CityCountOutputTypeCountDiversityArgs
    Preference?: boolean | CityCountOutputTypeCountPreferenceArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenceWhereInput
  }


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    Diversity: number
    Preference: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | CommunityCountOutputTypeCountDiversityArgs
    Preference?: boolean | CommunityCountOutputTypeCountPreferenceArgs
  }

  // Custom InputTypes
  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenceWhereInput
  }


  /**
   * Count Type MotherTongueCountOutputType
   */

  export type MotherTongueCountOutputType = {
    Diversity: number
    Preference: number
  }

  export type MotherTongueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | MotherTongueCountOutputTypeCountDiversityArgs
    Preference?: boolean | MotherTongueCountOutputTypeCountPreferenceArgs
  }

  // Custom InputTypes
  /**
   * MotherTongueCountOutputType without action
   */
  export type MotherTongueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongueCountOutputType
     */
    select?: MotherTongueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MotherTongueCountOutputType without action
   */
  export type MotherTongueCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * MotherTongueCountOutputType without action
   */
  export type MotherTongueCountOutputTypeCountPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenceWhereInput
  }


  /**
   * Count Type AstrologyCountOutputType
   */

  export type AstrologyCountOutputType = {
    AdditionalDetail: number
  }

  export type AstrologyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdditionalDetail?: boolean | AstrologyCountOutputTypeCountAdditionalDetailArgs
  }

  // Custom InputTypes
  /**
   * AstrologyCountOutputType without action
   */
  export type AstrologyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AstrologyCountOutputType
     */
    select?: AstrologyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AstrologyCountOutputType without action
   */
  export type AstrologyCountOutputTypeCountAdditionalDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalDetailWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    maritalStatusId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    maritalStatusId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: string | null
    bio: string | null
    image: string | null
    maritalStatusId: number | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: string | null
    bio: string | null
    image: string | null
    maritalStatusId: number | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    firstName: number
    lastName: number
    dateOfBirth: number
    gender: number
    bio: number
    image: number
    maritalStatusId: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    maritalStatusId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    maritalStatusId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bio?: true
    image?: true
    maritalStatusId?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bio?: true
    image?: true
    maritalStatusId?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bio?: true
    image?: true
    maritalStatusId?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bio?: boolean
    image?: boolean
    maritalStatusId?: boolean
    password?: boolean
    maritalStatus?: boolean | MaritalStatusDefaultArgs<ExtArgs>
    diversity?: boolean | User$diversityArgs<ExtArgs>
    additionalDetail?: boolean | User$additionalDetailArgs<ExtArgs>
    Preference?: boolean | User$PreferenceArgs<ExtArgs>
    sentConnections?: boolean | User$sentConnectionsArgs<ExtArgs>
    receivedConnections?: boolean | User$receivedConnectionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bio?: boolean
    image?: boolean
    maritalStatusId?: boolean
    password?: boolean
  }


  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maritalStatus?: boolean | MaritalStatusDefaultArgs<ExtArgs>
    diversity?: boolean | User$diversityArgs<ExtArgs>
    additionalDetail?: boolean | User$additionalDetailArgs<ExtArgs>
    Preference?: boolean | User$PreferenceArgs<ExtArgs>
    sentConnections?: boolean | User$sentConnectionsArgs<ExtArgs>
    receivedConnections?: boolean | User$receivedConnectionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      maritalStatus: Prisma.$MaritalStatusPayload<ExtArgs>
      diversity: Prisma.$DiversityPayload<ExtArgs> | null
      additionalDetail: Prisma.$AdditionalDetailPayload<ExtArgs> | null
      Preference: Prisma.$PreferencePayload<ExtArgs> | null
      sentConnections: Prisma.$ConnectionPayload<ExtArgs>[]
      receivedConnections: Prisma.$ConnectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      email: string
      firstName: string
      lastName: string
      dateOfBirth: Date
      gender: string
      bio: string
      image: string
      maritalStatusId: number
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    maritalStatus<T extends MaritalStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatusDefaultArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    diversity<T extends User$diversityArgs<ExtArgs> = {}>(args?: Subset<T, User$diversityArgs<ExtArgs>>): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    additionalDetail<T extends User$additionalDetailArgs<ExtArgs> = {}>(args?: Subset<T, User$additionalDetailArgs<ExtArgs>>): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Preference<T extends User$PreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$PreferenceArgs<ExtArgs>>): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    sentConnections<T extends User$sentConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findMany'> | Null>;

    receivedConnections<T extends User$receivedConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly maritalStatusId: FieldRef<"User", 'Int'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.diversity
   */
  export type User$diversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
  }

  /**
   * User.additionalDetail
   */
  export type User$additionalDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    where?: AdditionalDetailWhereInput
  }

  /**
   * User.Preference
   */
  export type User$PreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    where?: PreferenceWhereInput
  }

  /**
   * User.sentConnections
   */
  export type User$sentConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * User.receivedConnections
   */
  export type User$receivedConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Diversity
   */

  export type AggregateDiversity = {
    _count: DiversityCountAggregateOutputType | null
    _avg: DiversityAvgAggregateOutputType | null
    _sum: DiversitySumAggregateOutputType | null
    _min: DiversityMinAggregateOutputType | null
    _max: DiversityMaxAggregateOutputType | null
  }

  export type DiversityAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    religionId: number | null
    countryId: number | null
    cityId: number | null
    communityId: number | null
    motherTongueId: number | null
  }

  export type DiversitySumAggregateOutputType = {
    id: number | null
    userId: number | null
    religionId: number | null
    countryId: number | null
    cityId: number | null
    communityId: number | null
    motherTongueId: number | null
  }

  export type DiversityMinAggregateOutputType = {
    id: number | null
    userId: number | null
    religionId: number | null
    countryId: number | null
    cityId: number | null
    communityId: number | null
    motherTongueId: number | null
  }

  export type DiversityMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    religionId: number | null
    countryId: number | null
    cityId: number | null
    communityId: number | null
    motherTongueId: number | null
  }

  export type DiversityCountAggregateOutputType = {
    id: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
    _all: number
  }


  export type DiversityAvgAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
  }

  export type DiversitySumAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
  }

  export type DiversityMinAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
  }

  export type DiversityMaxAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
  }

  export type DiversityCountAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
    _all?: true
  }

  export type DiversityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diversity to aggregate.
     */
    where?: DiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversities to fetch.
     */
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diversities
    **/
    _count?: true | DiversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiversityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiversitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiversityMaxAggregateInputType
  }

  export type GetDiversityAggregateType<T extends DiversityAggregateArgs> = {
        [P in keyof T & keyof AggregateDiversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiversity[P]>
      : GetScalarType<T[P], AggregateDiversity[P]>
  }




  export type DiversityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithAggregationInput | DiversityOrderByWithAggregationInput[]
    by: DiversityScalarFieldEnum[] | DiversityScalarFieldEnum
    having?: DiversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiversityCountAggregateInputType | true
    _avg?: DiversityAvgAggregateInputType
    _sum?: DiversitySumAggregateInputType
    _min?: DiversityMinAggregateInputType
    _max?: DiversityMaxAggregateInputType
  }

  export type DiversityGroupByOutputType = {
    id: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
    _count: DiversityCountAggregateOutputType | null
    _avg: DiversityAvgAggregateOutputType | null
    _sum: DiversitySumAggregateOutputType | null
    _min: DiversityMinAggregateOutputType | null
    _max: DiversityMaxAggregateOutputType | null
  }

  type GetDiversityGroupByPayload<T extends DiversityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiversityGroupByOutputType[P]>
            : GetScalarType<T[P], DiversityGroupByOutputType[P]>
        }
      >
    >


  export type DiversitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    religionId?: boolean
    countryId?: boolean
    cityId?: boolean
    communityId?: boolean
    motherTongueId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    motherTongue?: boolean | MotherTongueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diversity"]>

  export type DiversitySelectScalar = {
    id?: boolean
    userId?: boolean
    religionId?: boolean
    countryId?: boolean
    cityId?: boolean
    communityId?: boolean
    motherTongueId?: boolean
  }


  export type DiversityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    motherTongue?: boolean | MotherTongueDefaultArgs<ExtArgs>
  }


  export type $DiversityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diversity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      religion: Prisma.$ReligionPayload<ExtArgs>
      country: Prisma.$CountryPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      community: Prisma.$CommunityPayload<ExtArgs>
      motherTongue: Prisma.$MotherTonguePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      religionId: number
      countryId: number
      cityId: number
      communityId: number
      motherTongueId: number
    }, ExtArgs["result"]["diversity"]>
    composites: {}
  }


  type DiversityGetPayload<S extends boolean | null | undefined | DiversityDefaultArgs> = $Result.GetResult<Prisma.$DiversityPayload, S>

  type DiversityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiversityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiversityCountAggregateInputType | true
    }

  export interface DiversityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diversity'], meta: { name: 'Diversity' } }
    /**
     * Find zero or one Diversity that matches the filter.
     * @param {DiversityFindUniqueArgs} args - Arguments to find a Diversity
     * @example
     * // Get one Diversity
     * const diversity = await prisma.diversity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiversityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityFindUniqueArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Diversity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DiversityFindUniqueOrThrowArgs} args - Arguments to find a Diversity
     * @example
     * // Get one Diversity
     * const diversity = await prisma.diversity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiversityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Diversity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityFindFirstArgs} args - Arguments to find a Diversity
     * @example
     * // Get one Diversity
     * const diversity = await prisma.diversity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiversityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityFindFirstArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Diversity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityFindFirstOrThrowArgs} args - Arguments to find a Diversity
     * @example
     * // Get one Diversity
     * const diversity = await prisma.diversity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiversityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Diversities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diversities
     * const diversities = await prisma.diversity.findMany()
     * 
     * // Get first 10 Diversities
     * const diversities = await prisma.diversity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diversityWithIdOnly = await prisma.diversity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiversityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Diversity.
     * @param {DiversityCreateArgs} args - Arguments to create a Diversity.
     * @example
     * // Create one Diversity
     * const Diversity = await prisma.diversity.create({
     *   data: {
     *     // ... data to create a Diversity
     *   }
     * })
     * 
    **/
    create<T extends DiversityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityCreateArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Diversities.
     *     @param {DiversityCreateManyArgs} args - Arguments to create many Diversities.
     *     @example
     *     // Create many Diversities
     *     const diversity = await prisma.diversity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiversityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diversity.
     * @param {DiversityDeleteArgs} args - Arguments to delete one Diversity.
     * @example
     * // Delete one Diversity
     * const Diversity = await prisma.diversity.delete({
     *   where: {
     *     // ... filter to delete one Diversity
     *   }
     * })
     * 
    **/
    delete<T extends DiversityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityDeleteArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Diversity.
     * @param {DiversityUpdateArgs} args - Arguments to update one Diversity.
     * @example
     * // Update one Diversity
     * const diversity = await prisma.diversity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiversityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityUpdateArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Diversities.
     * @param {DiversityDeleteManyArgs} args - Arguments to filter Diversities to delete.
     * @example
     * // Delete a few Diversities
     * const { count } = await prisma.diversity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiversityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diversities
     * const diversity = await prisma.diversity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiversityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diversity.
     * @param {DiversityUpsertArgs} args - Arguments to update or create a Diversity.
     * @example
     * // Update or create a Diversity
     * const diversity = await prisma.diversity.upsert({
     *   create: {
     *     // ... data to create a Diversity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diversity we want to update
     *   }
     * })
    **/
    upsert<T extends DiversityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityUpsertArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Diversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityCountArgs} args - Arguments to filter Diversities to count.
     * @example
     * // Count the number of Diversities
     * const count = await prisma.diversity.count({
     *   where: {
     *     // ... the filter for the Diversities we want to count
     *   }
     * })
    **/
    count<T extends DiversityCountArgs>(
      args?: Subset<T, DiversityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiversityAggregateArgs>(args: Subset<T, DiversityAggregateArgs>): Prisma.PrismaPromise<GetDiversityAggregateType<T>>

    /**
     * Group by Diversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiversityGroupByArgs['orderBy'] }
        : { orderBy?: DiversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diversity model
   */
  readonly fields: DiversityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diversity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiversityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    religion<T extends ReligionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReligionDefaultArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    motherTongue<T extends MotherTongueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MotherTongueDefaultArgs<ExtArgs>>): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Diversity model
   */ 
  interface DiversityFieldRefs {
    readonly id: FieldRef<"Diversity", 'Int'>
    readonly userId: FieldRef<"Diversity", 'Int'>
    readonly religionId: FieldRef<"Diversity", 'Int'>
    readonly countryId: FieldRef<"Diversity", 'Int'>
    readonly cityId: FieldRef<"Diversity", 'Int'>
    readonly communityId: FieldRef<"Diversity", 'Int'>
    readonly motherTongueId: FieldRef<"Diversity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Diversity findUnique
   */
  export type DiversityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversity to fetch.
     */
    where: DiversityWhereUniqueInput
  }

  /**
   * Diversity findUniqueOrThrow
   */
  export type DiversityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversity to fetch.
     */
    where: DiversityWhereUniqueInput
  }

  /**
   * Diversity findFirst
   */
  export type DiversityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversity to fetch.
     */
    where?: DiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversities to fetch.
     */
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diversities.
     */
    cursor?: DiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diversities.
     */
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Diversity findFirstOrThrow
   */
  export type DiversityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversity to fetch.
     */
    where?: DiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversities to fetch.
     */
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diversities.
     */
    cursor?: DiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diversities.
     */
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Diversity findMany
   */
  export type DiversityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversities to fetch.
     */
    where?: DiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversities to fetch.
     */
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diversities.
     */
    cursor?: DiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversities.
     */
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Diversity create
   */
  export type DiversityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * The data needed to create a Diversity.
     */
    data: XOR<DiversityCreateInput, DiversityUncheckedCreateInput>
  }

  /**
   * Diversity createMany
   */
  export type DiversityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diversities.
     */
    data: DiversityCreateManyInput | DiversityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diversity update
   */
  export type DiversityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * The data needed to update a Diversity.
     */
    data: XOR<DiversityUpdateInput, DiversityUncheckedUpdateInput>
    /**
     * Choose, which Diversity to update.
     */
    where: DiversityWhereUniqueInput
  }

  /**
   * Diversity updateMany
   */
  export type DiversityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diversities.
     */
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyInput>
    /**
     * Filter which Diversities to update
     */
    where?: DiversityWhereInput
  }

  /**
   * Diversity upsert
   */
  export type DiversityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * The filter to search for the Diversity to update in case it exists.
     */
    where: DiversityWhereUniqueInput
    /**
     * In case the Diversity found by the `where` argument doesn't exist, create a new Diversity with this data.
     */
    create: XOR<DiversityCreateInput, DiversityUncheckedCreateInput>
    /**
     * In case the Diversity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiversityUpdateInput, DiversityUncheckedUpdateInput>
  }

  /**
   * Diversity delete
   */
  export type DiversityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter which Diversity to delete.
     */
    where: DiversityWhereUniqueInput
  }

  /**
   * Diversity deleteMany
   */
  export type DiversityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diversities to delete
     */
    where?: DiversityWhereInput
  }

  /**
   * Diversity without action
   */
  export type DiversityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
  }


  /**
   * Model AdditionalDetail
   */

  export type AggregateAdditionalDetail = {
    _count: AdditionalDetailCountAggregateOutputType | null
    _avg: AdditionalDetailAvgAggregateOutputType | null
    _sum: AdditionalDetailSumAggregateOutputType | null
    _min: AdditionalDetailMinAggregateOutputType | null
    _max: AdditionalDetailMaxAggregateOutputType | null
  }

  export type AdditionalDetailAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    astrologicalId: number | null
  }

  export type AdditionalDetailSumAggregateOutputType = {
    id: number | null
    userId: number | null
    astrologicalId: number | null
  }

  export type AdditionalDetailMinAggregateOutputType = {
    id: number | null
    userId: number | null
    astrologicalId: number | null
    facebookProfileLink: string | null
    contactNumber: string | null
  }

  export type AdditionalDetailMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    astrologicalId: number | null
    facebookProfileLink: string | null
    contactNumber: string | null
  }

  export type AdditionalDetailCountAggregateOutputType = {
    id: number
    userId: number
    astrologicalId: number
    facebookProfileLink: number
    contactNumber: number
    _all: number
  }


  export type AdditionalDetailAvgAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
  }

  export type AdditionalDetailSumAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
  }

  export type AdditionalDetailMinAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
    facebookProfileLink?: true
    contactNumber?: true
  }

  export type AdditionalDetailMaxAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
    facebookProfileLink?: true
    contactNumber?: true
  }

  export type AdditionalDetailCountAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
    facebookProfileLink?: true
    contactNumber?: true
    _all?: true
  }

  export type AdditionalDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalDetail to aggregate.
     */
    where?: AdditionalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDetails to fetch.
     */
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdditionalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdditionalDetails
    **/
    _count?: true | AdditionalDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdditionalDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdditionalDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdditionalDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdditionalDetailMaxAggregateInputType
  }

  export type GetAdditionalDetailAggregateType<T extends AdditionalDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateAdditionalDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdditionalDetail[P]>
      : GetScalarType<T[P], AggregateAdditionalDetail[P]>
  }




  export type AdditionalDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalDetailWhereInput
    orderBy?: AdditionalDetailOrderByWithAggregationInput | AdditionalDetailOrderByWithAggregationInput[]
    by: AdditionalDetailScalarFieldEnum[] | AdditionalDetailScalarFieldEnum
    having?: AdditionalDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdditionalDetailCountAggregateInputType | true
    _avg?: AdditionalDetailAvgAggregateInputType
    _sum?: AdditionalDetailSumAggregateInputType
    _min?: AdditionalDetailMinAggregateInputType
    _max?: AdditionalDetailMaxAggregateInputType
  }

  export type AdditionalDetailGroupByOutputType = {
    id: number
    userId: number
    astrologicalId: number
    facebookProfileLink: string
    contactNumber: string
    _count: AdditionalDetailCountAggregateOutputType | null
    _avg: AdditionalDetailAvgAggregateOutputType | null
    _sum: AdditionalDetailSumAggregateOutputType | null
    _min: AdditionalDetailMinAggregateOutputType | null
    _max: AdditionalDetailMaxAggregateOutputType | null
  }

  type GetAdditionalDetailGroupByPayload<T extends AdditionalDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdditionalDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdditionalDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdditionalDetailGroupByOutputType[P]>
            : GetScalarType<T[P], AdditionalDetailGroupByOutputType[P]>
        }
      >
    >


  export type AdditionalDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    astrologicalId?: boolean
    facebookProfileLink?: boolean
    contactNumber?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    astrology?: boolean | AstrologyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["additionalDetail"]>

  export type AdditionalDetailSelectScalar = {
    id?: boolean
    userId?: boolean
    astrologicalId?: boolean
    facebookProfileLink?: boolean
    contactNumber?: boolean
  }


  export type AdditionalDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    astrology?: boolean | AstrologyDefaultArgs<ExtArgs>
  }


  export type $AdditionalDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdditionalDetail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      astrology: Prisma.$AstrologyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      astrologicalId: number
      facebookProfileLink: string
      contactNumber: string
    }, ExtArgs["result"]["additionalDetail"]>
    composites: {}
  }


  type AdditionalDetailGetPayload<S extends boolean | null | undefined | AdditionalDetailDefaultArgs> = $Result.GetResult<Prisma.$AdditionalDetailPayload, S>

  type AdditionalDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdditionalDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdditionalDetailCountAggregateInputType | true
    }

  export interface AdditionalDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdditionalDetail'], meta: { name: 'AdditionalDetail' } }
    /**
     * Find zero or one AdditionalDetail that matches the filter.
     * @param {AdditionalDetailFindUniqueArgs} args - Arguments to find a AdditionalDetail
     * @example
     * // Get one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdditionalDetailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailFindUniqueArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdditionalDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdditionalDetailFindUniqueOrThrowArgs} args - Arguments to find a AdditionalDetail
     * @example
     * // Get one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdditionalDetailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdditionalDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailFindFirstArgs} args - Arguments to find a AdditionalDetail
     * @example
     * // Get one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdditionalDetailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailFindFirstArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdditionalDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailFindFirstOrThrowArgs} args - Arguments to find a AdditionalDetail
     * @example
     * // Get one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdditionalDetailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdditionalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdditionalDetails
     * const additionalDetails = await prisma.additionalDetail.findMany()
     * 
     * // Get first 10 AdditionalDetails
     * const additionalDetails = await prisma.additionalDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const additionalDetailWithIdOnly = await prisma.additionalDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdditionalDetailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdditionalDetail.
     * @param {AdditionalDetailCreateArgs} args - Arguments to create a AdditionalDetail.
     * @example
     * // Create one AdditionalDetail
     * const AdditionalDetail = await prisma.additionalDetail.create({
     *   data: {
     *     // ... data to create a AdditionalDetail
     *   }
     * })
     * 
    **/
    create<T extends AdditionalDetailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailCreateArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdditionalDetails.
     *     @param {AdditionalDetailCreateManyArgs} args - Arguments to create many AdditionalDetails.
     *     @example
     *     // Create many AdditionalDetails
     *     const additionalDetail = await prisma.additionalDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdditionalDetailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdditionalDetail.
     * @param {AdditionalDetailDeleteArgs} args - Arguments to delete one AdditionalDetail.
     * @example
     * // Delete one AdditionalDetail
     * const AdditionalDetail = await prisma.additionalDetail.delete({
     *   where: {
     *     // ... filter to delete one AdditionalDetail
     *   }
     * })
     * 
    **/
    delete<T extends AdditionalDetailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailDeleteArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdditionalDetail.
     * @param {AdditionalDetailUpdateArgs} args - Arguments to update one AdditionalDetail.
     * @example
     * // Update one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdditionalDetailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailUpdateArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdditionalDetails.
     * @param {AdditionalDetailDeleteManyArgs} args - Arguments to filter AdditionalDetails to delete.
     * @example
     * // Delete a few AdditionalDetails
     * const { count } = await prisma.additionalDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdditionalDetailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdditionalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdditionalDetails
     * const additionalDetail = await prisma.additionalDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdditionalDetailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdditionalDetail.
     * @param {AdditionalDetailUpsertArgs} args - Arguments to update or create a AdditionalDetail.
     * @example
     * // Update or create a AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.upsert({
     *   create: {
     *     // ... data to create a AdditionalDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdditionalDetail we want to update
     *   }
     * })
    **/
    upsert<T extends AdditionalDetailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailUpsertArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdditionalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailCountArgs} args - Arguments to filter AdditionalDetails to count.
     * @example
     * // Count the number of AdditionalDetails
     * const count = await prisma.additionalDetail.count({
     *   where: {
     *     // ... the filter for the AdditionalDetails we want to count
     *   }
     * })
    **/
    count<T extends AdditionalDetailCountArgs>(
      args?: Subset<T, AdditionalDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdditionalDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdditionalDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdditionalDetailAggregateArgs>(args: Subset<T, AdditionalDetailAggregateArgs>): Prisma.PrismaPromise<GetAdditionalDetailAggregateType<T>>

    /**
     * Group by AdditionalDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdditionalDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdditionalDetailGroupByArgs['orderBy'] }
        : { orderBy?: AdditionalDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdditionalDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdditionalDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdditionalDetail model
   */
  readonly fields: AdditionalDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdditionalDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdditionalDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    astrology<T extends AstrologyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AstrologyDefaultArgs<ExtArgs>>): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdditionalDetail model
   */ 
  interface AdditionalDetailFieldRefs {
    readonly id: FieldRef<"AdditionalDetail", 'Int'>
    readonly userId: FieldRef<"AdditionalDetail", 'Int'>
    readonly astrologicalId: FieldRef<"AdditionalDetail", 'Int'>
    readonly facebookProfileLink: FieldRef<"AdditionalDetail", 'String'>
    readonly contactNumber: FieldRef<"AdditionalDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdditionalDetail findUnique
   */
  export type AdditionalDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetail to fetch.
     */
    where: AdditionalDetailWhereUniqueInput
  }

  /**
   * AdditionalDetail findUniqueOrThrow
   */
  export type AdditionalDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetail to fetch.
     */
    where: AdditionalDetailWhereUniqueInput
  }

  /**
   * AdditionalDetail findFirst
   */
  export type AdditionalDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetail to fetch.
     */
    where?: AdditionalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDetails to fetch.
     */
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalDetails.
     */
    cursor?: AdditionalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalDetails.
     */
    distinct?: AdditionalDetailScalarFieldEnum | AdditionalDetailScalarFieldEnum[]
  }

  /**
   * AdditionalDetail findFirstOrThrow
   */
  export type AdditionalDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetail to fetch.
     */
    where?: AdditionalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDetails to fetch.
     */
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalDetails.
     */
    cursor?: AdditionalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalDetails.
     */
    distinct?: AdditionalDetailScalarFieldEnum | AdditionalDetailScalarFieldEnum[]
  }

  /**
   * AdditionalDetail findMany
   */
  export type AdditionalDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetails to fetch.
     */
    where?: AdditionalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDetails to fetch.
     */
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdditionalDetails.
     */
    cursor?: AdditionalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDetails.
     */
    skip?: number
    distinct?: AdditionalDetailScalarFieldEnum | AdditionalDetailScalarFieldEnum[]
  }

  /**
   * AdditionalDetail create
   */
  export type AdditionalDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a AdditionalDetail.
     */
    data: XOR<AdditionalDetailCreateInput, AdditionalDetailUncheckedCreateInput>
  }

  /**
   * AdditionalDetail createMany
   */
  export type AdditionalDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdditionalDetails.
     */
    data: AdditionalDetailCreateManyInput | AdditionalDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdditionalDetail update
   */
  export type AdditionalDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a AdditionalDetail.
     */
    data: XOR<AdditionalDetailUpdateInput, AdditionalDetailUncheckedUpdateInput>
    /**
     * Choose, which AdditionalDetail to update.
     */
    where: AdditionalDetailWhereUniqueInput
  }

  /**
   * AdditionalDetail updateMany
   */
  export type AdditionalDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdditionalDetails.
     */
    data: XOR<AdditionalDetailUpdateManyMutationInput, AdditionalDetailUncheckedUpdateManyInput>
    /**
     * Filter which AdditionalDetails to update
     */
    where?: AdditionalDetailWhereInput
  }

  /**
   * AdditionalDetail upsert
   */
  export type AdditionalDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the AdditionalDetail to update in case it exists.
     */
    where: AdditionalDetailWhereUniqueInput
    /**
     * In case the AdditionalDetail found by the `where` argument doesn't exist, create a new AdditionalDetail with this data.
     */
    create: XOR<AdditionalDetailCreateInput, AdditionalDetailUncheckedCreateInput>
    /**
     * In case the AdditionalDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdditionalDetailUpdateInput, AdditionalDetailUncheckedUpdateInput>
  }

  /**
   * AdditionalDetail delete
   */
  export type AdditionalDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter which AdditionalDetail to delete.
     */
    where: AdditionalDetailWhereUniqueInput
  }

  /**
   * AdditionalDetail deleteMany
   */
  export type AdditionalDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalDetails to delete
     */
    where?: AdditionalDetailWhereInput
  }

  /**
   * AdditionalDetail without action
   */
  export type AdditionalDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
  }


  /**
   * Model Preference
   */

  export type AggregatePreference = {
    _count: PreferenceCountAggregateOutputType | null
    _avg: PreferenceAvgAggregateOutputType | null
    _sum: PreferenceSumAggregateOutputType | null
    _min: PreferenceMinAggregateOutputType | null
    _max: PreferenceMaxAggregateOutputType | null
  }

  export type PreferenceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    countryId: number | null
    cityId: number | null
    motherTongueId: number | null
    communityId: number | null
    religionId: number | null
    maritalStatusId: number | null
  }

  export type PreferenceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    countryId: number | null
    cityId: number | null
    motherTongueId: number | null
    communityId: number | null
    religionId: number | null
    maritalStatusId: number | null
  }

  export type PreferenceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    countryId: number | null
    cityId: number | null
    motherTongueId: number | null
    communityId: number | null
    religionId: number | null
    maritalStatusId: number | null
  }

  export type PreferenceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    countryId: number | null
    cityId: number | null
    motherTongueId: number | null
    communityId: number | null
    religionId: number | null
    maritalStatusId: number | null
  }

  export type PreferenceCountAggregateOutputType = {
    id: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
    _all: number
  }


  export type PreferenceAvgAggregateInputType = {
    id?: true
    userId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
    maritalStatusId?: true
  }

  export type PreferenceSumAggregateInputType = {
    id?: true
    userId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
    maritalStatusId?: true
  }

  export type PreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
    maritalStatusId?: true
  }

  export type PreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
    maritalStatusId?: true
  }

  export type PreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
    maritalStatusId?: true
    _all?: true
  }

  export type PreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preference to aggregate.
     */
    where?: PreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Preferences
    **/
    _count?: true | PreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferenceMaxAggregateInputType
  }

  export type GetPreferenceAggregateType<T extends PreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregatePreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreference[P]>
      : GetScalarType<T[P], AggregatePreference[P]>
  }




  export type PreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenceWhereInput
    orderBy?: PreferenceOrderByWithAggregationInput | PreferenceOrderByWithAggregationInput[]
    by: PreferenceScalarFieldEnum[] | PreferenceScalarFieldEnum
    having?: PreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferenceCountAggregateInputType | true
    _avg?: PreferenceAvgAggregateInputType
    _sum?: PreferenceSumAggregateInputType
    _min?: PreferenceMinAggregateInputType
    _max?: PreferenceMaxAggregateInputType
  }

  export type PreferenceGroupByOutputType = {
    id: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
    _count: PreferenceCountAggregateOutputType | null
    _avg: PreferenceAvgAggregateOutputType | null
    _sum: PreferenceSumAggregateOutputType | null
    _min: PreferenceMinAggregateOutputType | null
    _max: PreferenceMaxAggregateOutputType | null
  }

  type GetPreferenceGroupByPayload<T extends PreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], PreferenceGroupByOutputType[P]>
        }
      >
    >


  export type PreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    countryId?: boolean
    cityId?: boolean
    motherTongueId?: boolean
    communityId?: boolean
    religionId?: boolean
    maritalStatusId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    motherTongue?: boolean | MotherTongueDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
    maritalStatus?: boolean | MaritalStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preference"]>

  export type PreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    countryId?: boolean
    cityId?: boolean
    motherTongueId?: boolean
    communityId?: boolean
    religionId?: boolean
    maritalStatusId?: boolean
  }


  export type PreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    motherTongue?: boolean | MotherTongueDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
    maritalStatus?: boolean | MaritalStatusDefaultArgs<ExtArgs>
  }


  export type $PreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Preference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      country: Prisma.$CountryPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      motherTongue: Prisma.$MotherTonguePayload<ExtArgs>
      community: Prisma.$CommunityPayload<ExtArgs>
      religion: Prisma.$ReligionPayload<ExtArgs>
      maritalStatus: Prisma.$MaritalStatusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      countryId: number
      cityId: number
      motherTongueId: number
      communityId: number
      religionId: number
      maritalStatusId: number
    }, ExtArgs["result"]["preference"]>
    composites: {}
  }


  type PreferenceGetPayload<S extends boolean | null | undefined | PreferenceDefaultArgs> = $Result.GetResult<Prisma.$PreferencePayload, S>

  type PreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PreferenceCountAggregateInputType | true
    }

  export interface PreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Preference'], meta: { name: 'Preference' } }
    /**
     * Find zero or one Preference that matches the filter.
     * @param {PreferenceFindUniqueArgs} args - Arguments to find a Preference
     * @example
     * // Get one Preference
     * const preference = await prisma.preference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PreferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PreferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Preference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PreferenceFindUniqueOrThrowArgs} args - Arguments to find a Preference
     * @example
     * // Get one Preference
     * const preference = await prisma.preference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PreferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Preference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceFindFirstArgs} args - Arguments to find a Preference
     * @example
     * // Get one Preference
     * const preference = await prisma.preference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PreferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferenceFindFirstArgs<ExtArgs>>
    ): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Preference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceFindFirstOrThrowArgs} args - Arguments to find a Preference
     * @example
     * // Get one Preference
     * const preference = await prisma.preference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PreferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preferences
     * const preferences = await prisma.preference.findMany()
     * 
     * // Get first 10 Preferences
     * const preferences = await prisma.preference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preferenceWithIdOnly = await prisma.preference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PreferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Preference.
     * @param {PreferenceCreateArgs} args - Arguments to create a Preference.
     * @example
     * // Create one Preference
     * const Preference = await prisma.preference.create({
     *   data: {
     *     // ... data to create a Preference
     *   }
     * })
     * 
    **/
    create<T extends PreferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PreferenceCreateArgs<ExtArgs>>
    ): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Preferences.
     *     @param {PreferenceCreateManyArgs} args - Arguments to create many Preferences.
     *     @example
     *     // Create many Preferences
     *     const preference = await prisma.preference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PreferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Preference.
     * @param {PreferenceDeleteArgs} args - Arguments to delete one Preference.
     * @example
     * // Delete one Preference
     * const Preference = await prisma.preference.delete({
     *   where: {
     *     // ... filter to delete one Preference
     *   }
     * })
     * 
    **/
    delete<T extends PreferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PreferenceDeleteArgs<ExtArgs>>
    ): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Preference.
     * @param {PreferenceUpdateArgs} args - Arguments to update one Preference.
     * @example
     * // Update one Preference
     * const preference = await prisma.preference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PreferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PreferenceUpdateArgs<ExtArgs>>
    ): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Preferences.
     * @param {PreferenceDeleteManyArgs} args - Arguments to filter Preferences to delete.
     * @example
     * // Delete a few Preferences
     * const { count } = await prisma.preference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PreferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preferences
     * const preference = await prisma.preference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PreferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PreferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Preference.
     * @param {PreferenceUpsertArgs} args - Arguments to update or create a Preference.
     * @example
     * // Update or create a Preference
     * const preference = await prisma.preference.upsert({
     *   create: {
     *     // ... data to create a Preference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preference we want to update
     *   }
     * })
    **/
    upsert<T extends PreferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PreferenceUpsertArgs<ExtArgs>>
    ): Prisma__PreferenceClient<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceCountArgs} args - Arguments to filter Preferences to count.
     * @example
     * // Count the number of Preferences
     * const count = await prisma.preference.count({
     *   where: {
     *     // ... the filter for the Preferences we want to count
     *   }
     * })
    **/
    count<T extends PreferenceCountArgs>(
      args?: Subset<T, PreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferenceAggregateArgs>(args: Subset<T, PreferenceAggregateArgs>): Prisma.PrismaPromise<GetPreferenceAggregateType<T>>

    /**
     * Group by Preference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferenceGroupByArgs['orderBy'] }
        : { orderBy?: PreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Preference model
   */
  readonly fields: PreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Preference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    motherTongue<T extends MotherTongueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MotherTongueDefaultArgs<ExtArgs>>): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    religion<T extends ReligionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReligionDefaultArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    maritalStatus<T extends MaritalStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatusDefaultArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Preference model
   */ 
  interface PreferenceFieldRefs {
    readonly id: FieldRef<"Preference", 'Int'>
    readonly userId: FieldRef<"Preference", 'Int'>
    readonly countryId: FieldRef<"Preference", 'Int'>
    readonly cityId: FieldRef<"Preference", 'Int'>
    readonly motherTongueId: FieldRef<"Preference", 'Int'>
    readonly communityId: FieldRef<"Preference", 'Int'>
    readonly religionId: FieldRef<"Preference", 'Int'>
    readonly maritalStatusId: FieldRef<"Preference", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Preference findUnique
   */
  export type PreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * Filter, which Preference to fetch.
     */
    where: PreferenceWhereUniqueInput
  }

  /**
   * Preference findUniqueOrThrow
   */
  export type PreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * Filter, which Preference to fetch.
     */
    where: PreferenceWhereUniqueInput
  }

  /**
   * Preference findFirst
   */
  export type PreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * Filter, which Preference to fetch.
     */
    where?: PreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preferences.
     */
    cursor?: PreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preferences.
     */
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * Preference findFirstOrThrow
   */
  export type PreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * Filter, which Preference to fetch.
     */
    where?: PreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preferences.
     */
    cursor?: PreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preferences.
     */
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * Preference findMany
   */
  export type PreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     */
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Preferences.
     */
    cursor?: PreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     */
    skip?: number
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * Preference create
   */
  export type PreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Preference.
     */
    data: XOR<PreferenceCreateInput, PreferenceUncheckedCreateInput>
  }

  /**
   * Preference createMany
   */
  export type PreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Preferences.
     */
    data: PreferenceCreateManyInput | PreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Preference update
   */
  export type PreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Preference.
     */
    data: XOR<PreferenceUpdateInput, PreferenceUncheckedUpdateInput>
    /**
     * Choose, which Preference to update.
     */
    where: PreferenceWhereUniqueInput
  }

  /**
   * Preference updateMany
   */
  export type PreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Preferences.
     */
    data: XOR<PreferenceUpdateManyMutationInput, PreferenceUncheckedUpdateManyInput>
    /**
     * Filter which Preferences to update
     */
    where?: PreferenceWhereInput
  }

  /**
   * Preference upsert
   */
  export type PreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Preference to update in case it exists.
     */
    where: PreferenceWhereUniqueInput
    /**
     * In case the Preference found by the `where` argument doesn't exist, create a new Preference with this data.
     */
    create: XOR<PreferenceCreateInput, PreferenceUncheckedCreateInput>
    /**
     * In case the Preference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreferenceUpdateInput, PreferenceUncheckedUpdateInput>
  }

  /**
   * Preference delete
   */
  export type PreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    /**
     * Filter which Preference to delete.
     */
    where: PreferenceWhereUniqueInput
  }

  /**
   * Preference deleteMany
   */
  export type PreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preferences to delete
     */
    where?: PreferenceWhereInput
  }

  /**
   * Preference without action
   */
  export type PreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
  }


  /**
   * Model MaritalStatus
   */

  export type AggregateMaritalStatus = {
    _count: MaritalStatusCountAggregateOutputType | null
    _avg: MaritalStatusAvgAggregateOutputType | null
    _sum: MaritalStatusSumAggregateOutputType | null
    _min: MaritalStatusMinAggregateOutputType | null
    _max: MaritalStatusMaxAggregateOutputType | null
  }

  export type MaritalStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type MaritalStatusSumAggregateOutputType = {
    id: number | null
  }

  export type MaritalStatusMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type MaritalStatusMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type MaritalStatusCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type MaritalStatusAvgAggregateInputType = {
    id?: true
  }

  export type MaritalStatusSumAggregateInputType = {
    id?: true
  }

  export type MaritalStatusMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type MaritalStatusMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type MaritalStatusCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type MaritalStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaritalStatus to aggregate.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaritalStatuses
    **/
    _count?: true | MaritalStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaritalStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaritalStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaritalStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaritalStatusMaxAggregateInputType
  }

  export type GetMaritalStatusAggregateType<T extends MaritalStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMaritalStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaritalStatus[P]>
      : GetScalarType<T[P], AggregateMaritalStatus[P]>
  }




  export type MaritalStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaritalStatusWhereInput
    orderBy?: MaritalStatusOrderByWithAggregationInput | MaritalStatusOrderByWithAggregationInput[]
    by: MaritalStatusScalarFieldEnum[] | MaritalStatusScalarFieldEnum
    having?: MaritalStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaritalStatusCountAggregateInputType | true
    _avg?: MaritalStatusAvgAggregateInputType
    _sum?: MaritalStatusSumAggregateInputType
    _min?: MaritalStatusMinAggregateInputType
    _max?: MaritalStatusMaxAggregateInputType
  }

  export type MaritalStatusGroupByOutputType = {
    id: number
    title: string
    _count: MaritalStatusCountAggregateOutputType | null
    _avg: MaritalStatusAvgAggregateOutputType | null
    _sum: MaritalStatusSumAggregateOutputType | null
    _min: MaritalStatusMinAggregateOutputType | null
    _max: MaritalStatusMaxAggregateOutputType | null
  }

  type GetMaritalStatusGroupByPayload<T extends MaritalStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaritalStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaritalStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaritalStatusGroupByOutputType[P]>
            : GetScalarType<T[P], MaritalStatusGroupByOutputType[P]>
        }
      >
    >


  export type MaritalStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    users?: boolean | MaritalStatus$usersArgs<ExtArgs>
    Preference?: boolean | MaritalStatus$PreferenceArgs<ExtArgs>
    _count?: boolean | MaritalStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maritalStatus"]>

  export type MaritalStatusSelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type MaritalStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MaritalStatus$usersArgs<ExtArgs>
    Preference?: boolean | MaritalStatus$PreferenceArgs<ExtArgs>
    _count?: boolean | MaritalStatusCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MaritalStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaritalStatus"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      Preference: Prisma.$PreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["maritalStatus"]>
    composites: {}
  }


  type MaritalStatusGetPayload<S extends boolean | null | undefined | MaritalStatusDefaultArgs> = $Result.GetResult<Prisma.$MaritalStatusPayload, S>

  type MaritalStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaritalStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaritalStatusCountAggregateInputType | true
    }

  export interface MaritalStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaritalStatus'], meta: { name: 'MaritalStatus' } }
    /**
     * Find zero or one MaritalStatus that matches the filter.
     * @param {MaritalStatusFindUniqueArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaritalStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MaritalStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MaritalStatusFindUniqueOrThrowArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MaritalStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MaritalStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindFirstArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaritalStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusFindFirstArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MaritalStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindFirstOrThrowArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MaritalStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MaritalStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaritalStatuses
     * const maritalStatuses = await prisma.maritalStatus.findMany()
     * 
     * // Get first 10 MaritalStatuses
     * const maritalStatuses = await prisma.maritalStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maritalStatusWithIdOnly = await prisma.maritalStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MaritalStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MaritalStatus.
     * @param {MaritalStatusCreateArgs} args - Arguments to create a MaritalStatus.
     * @example
     * // Create one MaritalStatus
     * const MaritalStatus = await prisma.maritalStatus.create({
     *   data: {
     *     // ... data to create a MaritalStatus
     *   }
     * })
     * 
    **/
    create<T extends MaritalStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusCreateArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MaritalStatuses.
     *     @param {MaritalStatusCreateManyArgs} args - Arguments to create many MaritalStatuses.
     *     @example
     *     // Create many MaritalStatuses
     *     const maritalStatus = await prisma.maritalStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaritalStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaritalStatus.
     * @param {MaritalStatusDeleteArgs} args - Arguments to delete one MaritalStatus.
     * @example
     * // Delete one MaritalStatus
     * const MaritalStatus = await prisma.maritalStatus.delete({
     *   where: {
     *     // ... filter to delete one MaritalStatus
     *   }
     * })
     * 
    **/
    delete<T extends MaritalStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusDeleteArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MaritalStatus.
     * @param {MaritalStatusUpdateArgs} args - Arguments to update one MaritalStatus.
     * @example
     * // Update one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaritalStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusUpdateArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MaritalStatuses.
     * @param {MaritalStatusDeleteManyArgs} args - Arguments to filter MaritalStatuses to delete.
     * @example
     * // Delete a few MaritalStatuses
     * const { count } = await prisma.maritalStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaritalStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaritalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaritalStatuses
     * const maritalStatus = await prisma.maritalStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaritalStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaritalStatus.
     * @param {MaritalStatusUpsertArgs} args - Arguments to update or create a MaritalStatus.
     * @example
     * // Update or create a MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.upsert({
     *   create: {
     *     // ... data to create a MaritalStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaritalStatus we want to update
     *   }
     * })
    **/
    upsert<T extends MaritalStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusUpsertArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MaritalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusCountArgs} args - Arguments to filter MaritalStatuses to count.
     * @example
     * // Count the number of MaritalStatuses
     * const count = await prisma.maritalStatus.count({
     *   where: {
     *     // ... the filter for the MaritalStatuses we want to count
     *   }
     * })
    **/
    count<T extends MaritalStatusCountArgs>(
      args?: Subset<T, MaritalStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaritalStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaritalStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaritalStatusAggregateArgs>(args: Subset<T, MaritalStatusAggregateArgs>): Prisma.PrismaPromise<GetMaritalStatusAggregateType<T>>

    /**
     * Group by MaritalStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaritalStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaritalStatusGroupByArgs['orderBy'] }
        : { orderBy?: MaritalStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaritalStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaritalStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaritalStatus model
   */
  readonly fields: MaritalStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaritalStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaritalStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends MaritalStatus$usersArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatus$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    Preference<T extends MaritalStatus$PreferenceArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatus$PreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MaritalStatus model
   */ 
  interface MaritalStatusFieldRefs {
    readonly id: FieldRef<"MaritalStatus", 'Int'>
    readonly title: FieldRef<"MaritalStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaritalStatus findUnique
   */
  export type MaritalStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus findUniqueOrThrow
   */
  export type MaritalStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus findFirst
   */
  export type MaritalStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaritalStatuses.
     */
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus findFirstOrThrow
   */
  export type MaritalStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaritalStatuses.
     */
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus findMany
   */
  export type MaritalStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatuses to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus create
   */
  export type MaritalStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a MaritalStatus.
     */
    data: XOR<MaritalStatusCreateInput, MaritalStatusUncheckedCreateInput>
  }

  /**
   * MaritalStatus createMany
   */
  export type MaritalStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaritalStatuses.
     */
    data: MaritalStatusCreateManyInput | MaritalStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaritalStatus update
   */
  export type MaritalStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a MaritalStatus.
     */
    data: XOR<MaritalStatusUpdateInput, MaritalStatusUncheckedUpdateInput>
    /**
     * Choose, which MaritalStatus to update.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus updateMany
   */
  export type MaritalStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaritalStatuses.
     */
    data: XOR<MaritalStatusUpdateManyMutationInput, MaritalStatusUncheckedUpdateManyInput>
    /**
     * Filter which MaritalStatuses to update
     */
    where?: MaritalStatusWhereInput
  }

  /**
   * MaritalStatus upsert
   */
  export type MaritalStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the MaritalStatus to update in case it exists.
     */
    where: MaritalStatusWhereUniqueInput
    /**
     * In case the MaritalStatus found by the `where` argument doesn't exist, create a new MaritalStatus with this data.
     */
    create: XOR<MaritalStatusCreateInput, MaritalStatusUncheckedCreateInput>
    /**
     * In case the MaritalStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaritalStatusUpdateInput, MaritalStatusUncheckedUpdateInput>
  }

  /**
   * MaritalStatus delete
   */
  export type MaritalStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter which MaritalStatus to delete.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus deleteMany
   */
  export type MaritalStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaritalStatuses to delete
     */
    where?: MaritalStatusWhereInput
  }

  /**
   * MaritalStatus.users
   */
  export type MaritalStatus$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * MaritalStatus.Preference
   */
  export type MaritalStatus$PreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    where?: PreferenceWhereInput
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    cursor?: PreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * MaritalStatus without action
   */
  export type MaritalStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
  }


  /**
   * Model Religion
   */

  export type AggregateReligion = {
    _count: ReligionCountAggregateOutputType | null
    _avg: ReligionAvgAggregateOutputType | null
    _sum: ReligionSumAggregateOutputType | null
    _min: ReligionMinAggregateOutputType | null
    _max: ReligionMaxAggregateOutputType | null
  }

  export type ReligionAvgAggregateOutputType = {
    id: number | null
  }

  export type ReligionSumAggregateOutputType = {
    id: number | null
  }

  export type ReligionMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type ReligionMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type ReligionCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type ReligionAvgAggregateInputType = {
    id?: true
  }

  export type ReligionSumAggregateInputType = {
    id?: true
  }

  export type ReligionMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type ReligionMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type ReligionCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type ReligionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Religion to aggregate.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Religions
    **/
    _count?: true | ReligionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReligionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReligionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReligionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReligionMaxAggregateInputType
  }

  export type GetReligionAggregateType<T extends ReligionAggregateArgs> = {
        [P in keyof T & keyof AggregateReligion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReligion[P]>
      : GetScalarType<T[P], AggregateReligion[P]>
  }




  export type ReligionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReligionWhereInput
    orderBy?: ReligionOrderByWithAggregationInput | ReligionOrderByWithAggregationInput[]
    by: ReligionScalarFieldEnum[] | ReligionScalarFieldEnum
    having?: ReligionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReligionCountAggregateInputType | true
    _avg?: ReligionAvgAggregateInputType
    _sum?: ReligionSumAggregateInputType
    _min?: ReligionMinAggregateInputType
    _max?: ReligionMaxAggregateInputType
  }

  export type ReligionGroupByOutputType = {
    id: number
    title: string
    _count: ReligionCountAggregateOutputType | null
    _avg: ReligionAvgAggregateOutputType | null
    _sum: ReligionSumAggregateOutputType | null
    _min: ReligionMinAggregateOutputType | null
    _max: ReligionMaxAggregateOutputType | null
  }

  type GetReligionGroupByPayload<T extends ReligionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReligionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReligionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReligionGroupByOutputType[P]>
            : GetScalarType<T[P], ReligionGroupByOutputType[P]>
        }
      >
    >


  export type ReligionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    Diversity?: boolean | Religion$DiversityArgs<ExtArgs>
    Preference?: boolean | Religion$PreferenceArgs<ExtArgs>
    _count?: boolean | ReligionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["religion"]>

  export type ReligionSelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type ReligionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | Religion$DiversityArgs<ExtArgs>
    Preference?: boolean | Religion$PreferenceArgs<ExtArgs>
    _count?: boolean | ReligionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ReligionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Religion"
    objects: {
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      Preference: Prisma.$PreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["religion"]>
    composites: {}
  }


  type ReligionGetPayload<S extends boolean | null | undefined | ReligionDefaultArgs> = $Result.GetResult<Prisma.$ReligionPayload, S>

  type ReligionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReligionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReligionCountAggregateInputType | true
    }

  export interface ReligionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Religion'], meta: { name: 'Religion' } }
    /**
     * Find zero or one Religion that matches the filter.
     * @param {ReligionFindUniqueArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReligionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionFindUniqueArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Religion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReligionFindUniqueOrThrowArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReligionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Religion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindFirstArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReligionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionFindFirstArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Religion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindFirstOrThrowArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReligionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Religions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Religions
     * const religions = await prisma.religion.findMany()
     * 
     * // Get first 10 Religions
     * const religions = await prisma.religion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const religionWithIdOnly = await prisma.religion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReligionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Religion.
     * @param {ReligionCreateArgs} args - Arguments to create a Religion.
     * @example
     * // Create one Religion
     * const Religion = await prisma.religion.create({
     *   data: {
     *     // ... data to create a Religion
     *   }
     * })
     * 
    **/
    create<T extends ReligionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionCreateArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Religions.
     *     @param {ReligionCreateManyArgs} args - Arguments to create many Religions.
     *     @example
     *     // Create many Religions
     *     const religion = await prisma.religion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReligionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Religion.
     * @param {ReligionDeleteArgs} args - Arguments to delete one Religion.
     * @example
     * // Delete one Religion
     * const Religion = await prisma.religion.delete({
     *   where: {
     *     // ... filter to delete one Religion
     *   }
     * })
     * 
    **/
    delete<T extends ReligionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionDeleteArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Religion.
     * @param {ReligionUpdateArgs} args - Arguments to update one Religion.
     * @example
     * // Update one Religion
     * const religion = await prisma.religion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReligionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionUpdateArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Religions.
     * @param {ReligionDeleteManyArgs} args - Arguments to filter Religions to delete.
     * @example
     * // Delete a few Religions
     * const { count } = await prisma.religion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReligionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Religions
     * const religion = await prisma.religion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReligionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Religion.
     * @param {ReligionUpsertArgs} args - Arguments to update or create a Religion.
     * @example
     * // Update or create a Religion
     * const religion = await prisma.religion.upsert({
     *   create: {
     *     // ... data to create a Religion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Religion we want to update
     *   }
     * })
    **/
    upsert<T extends ReligionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionUpsertArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionCountArgs} args - Arguments to filter Religions to count.
     * @example
     * // Count the number of Religions
     * const count = await prisma.religion.count({
     *   where: {
     *     // ... the filter for the Religions we want to count
     *   }
     * })
    **/
    count<T extends ReligionCountArgs>(
      args?: Subset<T, ReligionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReligionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Religion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReligionAggregateArgs>(args: Subset<T, ReligionAggregateArgs>): Prisma.PrismaPromise<GetReligionAggregateType<T>>

    /**
     * Group by Religion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReligionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReligionGroupByArgs['orderBy'] }
        : { orderBy?: ReligionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReligionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReligionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Religion model
   */
  readonly fields: ReligionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Religion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReligionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Diversity<T extends Religion$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, Religion$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    Preference<T extends Religion$PreferenceArgs<ExtArgs> = {}>(args?: Subset<T, Religion$PreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Religion model
   */ 
  interface ReligionFieldRefs {
    readonly id: FieldRef<"Religion", 'Int'>
    readonly title: FieldRef<"Religion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Religion findUnique
   */
  export type ReligionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion findUniqueOrThrow
   */
  export type ReligionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion findFirst
   */
  export type ReligionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Religions.
     */
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion findFirstOrThrow
   */
  export type ReligionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Religions.
     */
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion findMany
   */
  export type ReligionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religions to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion create
   */
  export type ReligionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The data needed to create a Religion.
     */
    data: XOR<ReligionCreateInput, ReligionUncheckedCreateInput>
  }

  /**
   * Religion createMany
   */
  export type ReligionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Religions.
     */
    data: ReligionCreateManyInput | ReligionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Religion update
   */
  export type ReligionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The data needed to update a Religion.
     */
    data: XOR<ReligionUpdateInput, ReligionUncheckedUpdateInput>
    /**
     * Choose, which Religion to update.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion updateMany
   */
  export type ReligionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Religions.
     */
    data: XOR<ReligionUpdateManyMutationInput, ReligionUncheckedUpdateManyInput>
    /**
     * Filter which Religions to update
     */
    where?: ReligionWhereInput
  }

  /**
   * Religion upsert
   */
  export type ReligionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The filter to search for the Religion to update in case it exists.
     */
    where: ReligionWhereUniqueInput
    /**
     * In case the Religion found by the `where` argument doesn't exist, create a new Religion with this data.
     */
    create: XOR<ReligionCreateInput, ReligionUncheckedCreateInput>
    /**
     * In case the Religion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReligionUpdateInput, ReligionUncheckedUpdateInput>
  }

  /**
   * Religion delete
   */
  export type ReligionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter which Religion to delete.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion deleteMany
   */
  export type ReligionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Religions to delete
     */
    where?: ReligionWhereInput
  }

  /**
   * Religion.Diversity
   */
  export type Religion$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Religion.Preference
   */
  export type Religion$PreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    where?: PreferenceWhereInput
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    cursor?: PreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * Religion without action
   */
  export type ReligionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    title: string
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    cities?: boolean | Country$citiesArgs<ExtArgs>
    Diversity?: boolean | Country$DiversityArgs<ExtArgs>
    Preference?: boolean | Country$PreferenceArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Country$citiesArgs<ExtArgs>
    Diversity?: boolean | Country$DiversityArgs<ExtArgs>
    Preference?: boolean | Country$PreferenceArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      Preference: Prisma.$PreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["country"]>
    composites: {}
  }


  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryCreateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cities<T extends Country$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Country$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findMany'> | Null>;

    Diversity<T extends Country$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, Country$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    Preference<T extends Country$PreferenceArgs<ExtArgs> = {}>(args?: Subset<T, Country$PreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly title: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }

  /**
   * Country.cities
   */
  export type Country$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Country.Diversity
   */
  export type Country$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Country.Preference
   */
  export type Country$PreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    where?: PreferenceWhereInput
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    cursor?: PreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    title: string | null
    countryId: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    title: string | null
    countryId: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    title: number
    countryId: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    title?: true
    countryId?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    title?: true
    countryId?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    title?: true
    countryId?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: number
    title: string
    countryId: number
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    Diversity?: boolean | City$DiversityArgs<ExtArgs>
    Preference?: boolean | City$PreferenceArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    title?: boolean
    countryId?: boolean
  }


  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    Diversity?: boolean | City$DiversityArgs<ExtArgs>
    Preference?: boolean | City$PreferenceArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      Preference: Prisma.$PreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      countryId: number
    }, ExtArgs["result"]["city"]>
    composites: {}
  }


  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CityCreateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CityDeleteArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpsertArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Diversity<T extends City$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, City$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    Preference<T extends City$PreferenceArgs<ExtArgs> = {}>(args?: Subset<T, City$PreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'Int'>
    readonly title: FieldRef<"City", 'String'>
    readonly countryId: FieldRef<"City", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }

  /**
   * City.Diversity
   */
  export type City$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * City.Preference
   */
  export type City$PreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    where?: PreferenceWhereInput
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    cursor?: PreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    id: number | null
  }

  export type CommunitySumAggregateOutputType = {
    id: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    id?: true
  }

  export type CommunitySumAggregateInputType = {
    id?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: number
    title: string
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    Diversity?: boolean | Community$DiversityArgs<ExtArgs>
    Preference?: boolean | Community$PreferenceArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | Community$DiversityArgs<ExtArgs>
    Preference?: boolean | Community$PreferenceArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      Preference: Prisma.$PreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["community"]>
    composites: {}
  }


  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Community that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
    **/
    create<T extends CommunityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Communities.
     *     @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     *     @example
     *     // Create many Communities
     *     const community = await prisma.community.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
    **/
    delete<T extends CommunityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Diversity<T extends Community$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, Community$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    Preference<T extends Community$PreferenceArgs<ExtArgs> = {}>(args?: Subset<T, Community$PreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Community model
   */ 
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'Int'>
    readonly title: FieldRef<"Community", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
  }

  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
  }

  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
  }

  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
  }

  /**
   * Community.Diversity
   */
  export type Community$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Community.Preference
   */
  export type Community$PreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    where?: PreferenceWhereInput
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    cursor?: PreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
  }


  /**
   * Model MotherTongue
   */

  export type AggregateMotherTongue = {
    _count: MotherTongueCountAggregateOutputType | null
    _avg: MotherTongueAvgAggregateOutputType | null
    _sum: MotherTongueSumAggregateOutputType | null
    _min: MotherTongueMinAggregateOutputType | null
    _max: MotherTongueMaxAggregateOutputType | null
  }

  export type MotherTongueAvgAggregateOutputType = {
    id: number | null
  }

  export type MotherTongueSumAggregateOutputType = {
    id: number | null
  }

  export type MotherTongueMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type MotherTongueMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type MotherTongueCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type MotherTongueAvgAggregateInputType = {
    id?: true
  }

  export type MotherTongueSumAggregateInputType = {
    id?: true
  }

  export type MotherTongueMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type MotherTongueMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type MotherTongueCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type MotherTongueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MotherTongue to aggregate.
     */
    where?: MotherTongueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MotherTongues to fetch.
     */
    orderBy?: MotherTongueOrderByWithRelationInput | MotherTongueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MotherTongueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MotherTongues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MotherTongues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MotherTongues
    **/
    _count?: true | MotherTongueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotherTongueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotherTongueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotherTongueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotherTongueMaxAggregateInputType
  }

  export type GetMotherTongueAggregateType<T extends MotherTongueAggregateArgs> = {
        [P in keyof T & keyof AggregateMotherTongue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotherTongue[P]>
      : GetScalarType<T[P], AggregateMotherTongue[P]>
  }




  export type MotherTongueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MotherTongueWhereInput
    orderBy?: MotherTongueOrderByWithAggregationInput | MotherTongueOrderByWithAggregationInput[]
    by: MotherTongueScalarFieldEnum[] | MotherTongueScalarFieldEnum
    having?: MotherTongueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotherTongueCountAggregateInputType | true
    _avg?: MotherTongueAvgAggregateInputType
    _sum?: MotherTongueSumAggregateInputType
    _min?: MotherTongueMinAggregateInputType
    _max?: MotherTongueMaxAggregateInputType
  }

  export type MotherTongueGroupByOutputType = {
    id: number
    title: string
    _count: MotherTongueCountAggregateOutputType | null
    _avg: MotherTongueAvgAggregateOutputType | null
    _sum: MotherTongueSumAggregateOutputType | null
    _min: MotherTongueMinAggregateOutputType | null
    _max: MotherTongueMaxAggregateOutputType | null
  }

  type GetMotherTongueGroupByPayload<T extends MotherTongueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotherTongueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotherTongueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotherTongueGroupByOutputType[P]>
            : GetScalarType<T[P], MotherTongueGroupByOutputType[P]>
        }
      >
    >


  export type MotherTongueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    Diversity?: boolean | MotherTongue$DiversityArgs<ExtArgs>
    Preference?: boolean | MotherTongue$PreferenceArgs<ExtArgs>
    _count?: boolean | MotherTongueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motherTongue"]>

  export type MotherTongueSelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type MotherTongueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | MotherTongue$DiversityArgs<ExtArgs>
    Preference?: boolean | MotherTongue$PreferenceArgs<ExtArgs>
    _count?: boolean | MotherTongueCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MotherTonguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MotherTongue"
    objects: {
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      Preference: Prisma.$PreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["motherTongue"]>
    composites: {}
  }


  type MotherTongueGetPayload<S extends boolean | null | undefined | MotherTongueDefaultArgs> = $Result.GetResult<Prisma.$MotherTonguePayload, S>

  type MotherTongueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MotherTongueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MotherTongueCountAggregateInputType | true
    }

  export interface MotherTongueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MotherTongue'], meta: { name: 'MotherTongue' } }
    /**
     * Find zero or one MotherTongue that matches the filter.
     * @param {MotherTongueFindUniqueArgs} args - Arguments to find a MotherTongue
     * @example
     * // Get one MotherTongue
     * const motherTongue = await prisma.motherTongue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MotherTongueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueFindUniqueArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MotherTongue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MotherTongueFindUniqueOrThrowArgs} args - Arguments to find a MotherTongue
     * @example
     * // Get one MotherTongue
     * const motherTongue = await prisma.motherTongue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MotherTongueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MotherTongue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueFindFirstArgs} args - Arguments to find a MotherTongue
     * @example
     * // Get one MotherTongue
     * const motherTongue = await prisma.motherTongue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MotherTongueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueFindFirstArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MotherTongue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueFindFirstOrThrowArgs} args - Arguments to find a MotherTongue
     * @example
     * // Get one MotherTongue
     * const motherTongue = await prisma.motherTongue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MotherTongueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MotherTongues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MotherTongues
     * const motherTongues = await prisma.motherTongue.findMany()
     * 
     * // Get first 10 MotherTongues
     * const motherTongues = await prisma.motherTongue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motherTongueWithIdOnly = await prisma.motherTongue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MotherTongueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MotherTongue.
     * @param {MotherTongueCreateArgs} args - Arguments to create a MotherTongue.
     * @example
     * // Create one MotherTongue
     * const MotherTongue = await prisma.motherTongue.create({
     *   data: {
     *     // ... data to create a MotherTongue
     *   }
     * })
     * 
    **/
    create<T extends MotherTongueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueCreateArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MotherTongues.
     *     @param {MotherTongueCreateManyArgs} args - Arguments to create many MotherTongues.
     *     @example
     *     // Create many MotherTongues
     *     const motherTongue = await prisma.motherTongue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MotherTongueCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MotherTongue.
     * @param {MotherTongueDeleteArgs} args - Arguments to delete one MotherTongue.
     * @example
     * // Delete one MotherTongue
     * const MotherTongue = await prisma.motherTongue.delete({
     *   where: {
     *     // ... filter to delete one MotherTongue
     *   }
     * })
     * 
    **/
    delete<T extends MotherTongueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueDeleteArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MotherTongue.
     * @param {MotherTongueUpdateArgs} args - Arguments to update one MotherTongue.
     * @example
     * // Update one MotherTongue
     * const motherTongue = await prisma.motherTongue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MotherTongueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueUpdateArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MotherTongues.
     * @param {MotherTongueDeleteManyArgs} args - Arguments to filter MotherTongues to delete.
     * @example
     * // Delete a few MotherTongues
     * const { count } = await prisma.motherTongue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MotherTongueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MotherTongues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MotherTongues
     * const motherTongue = await prisma.motherTongue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MotherTongueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MotherTongue.
     * @param {MotherTongueUpsertArgs} args - Arguments to update or create a MotherTongue.
     * @example
     * // Update or create a MotherTongue
     * const motherTongue = await prisma.motherTongue.upsert({
     *   create: {
     *     // ... data to create a MotherTongue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MotherTongue we want to update
     *   }
     * })
    **/
    upsert<T extends MotherTongueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueUpsertArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MotherTongues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueCountArgs} args - Arguments to filter MotherTongues to count.
     * @example
     * // Count the number of MotherTongues
     * const count = await prisma.motherTongue.count({
     *   where: {
     *     // ... the filter for the MotherTongues we want to count
     *   }
     * })
    **/
    count<T extends MotherTongueCountArgs>(
      args?: Subset<T, MotherTongueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotherTongueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MotherTongue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotherTongueAggregateArgs>(args: Subset<T, MotherTongueAggregateArgs>): Prisma.PrismaPromise<GetMotherTongueAggregateType<T>>

    /**
     * Group by MotherTongue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MotherTongueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MotherTongueGroupByArgs['orderBy'] }
        : { orderBy?: MotherTongueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MotherTongueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotherTongueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MotherTongue model
   */
  readonly fields: MotherTongueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MotherTongue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MotherTongueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Diversity<T extends MotherTongue$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, MotherTongue$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    Preference<T extends MotherTongue$PreferenceArgs<ExtArgs> = {}>(args?: Subset<T, MotherTongue$PreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MotherTongue model
   */ 
  interface MotherTongueFieldRefs {
    readonly id: FieldRef<"MotherTongue", 'Int'>
    readonly title: FieldRef<"MotherTongue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MotherTongue findUnique
   */
  export type MotherTongueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongue to fetch.
     */
    where: MotherTongueWhereUniqueInput
  }

  /**
   * MotherTongue findUniqueOrThrow
   */
  export type MotherTongueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongue to fetch.
     */
    where: MotherTongueWhereUniqueInput
  }

  /**
   * MotherTongue findFirst
   */
  export type MotherTongueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongue to fetch.
     */
    where?: MotherTongueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MotherTongues to fetch.
     */
    orderBy?: MotherTongueOrderByWithRelationInput | MotherTongueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MotherTongues.
     */
    cursor?: MotherTongueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MotherTongues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MotherTongues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MotherTongues.
     */
    distinct?: MotherTongueScalarFieldEnum | MotherTongueScalarFieldEnum[]
  }

  /**
   * MotherTongue findFirstOrThrow
   */
  export type MotherTongueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongue to fetch.
     */
    where?: MotherTongueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MotherTongues to fetch.
     */
    orderBy?: MotherTongueOrderByWithRelationInput | MotherTongueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MotherTongues.
     */
    cursor?: MotherTongueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MotherTongues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MotherTongues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MotherTongues.
     */
    distinct?: MotherTongueScalarFieldEnum | MotherTongueScalarFieldEnum[]
  }

  /**
   * MotherTongue findMany
   */
  export type MotherTongueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongues to fetch.
     */
    where?: MotherTongueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MotherTongues to fetch.
     */
    orderBy?: MotherTongueOrderByWithRelationInput | MotherTongueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MotherTongues.
     */
    cursor?: MotherTongueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MotherTongues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MotherTongues.
     */
    skip?: number
    distinct?: MotherTongueScalarFieldEnum | MotherTongueScalarFieldEnum[]
  }

  /**
   * MotherTongue create
   */
  export type MotherTongueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * The data needed to create a MotherTongue.
     */
    data: XOR<MotherTongueCreateInput, MotherTongueUncheckedCreateInput>
  }

  /**
   * MotherTongue createMany
   */
  export type MotherTongueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MotherTongues.
     */
    data: MotherTongueCreateManyInput | MotherTongueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MotherTongue update
   */
  export type MotherTongueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * The data needed to update a MotherTongue.
     */
    data: XOR<MotherTongueUpdateInput, MotherTongueUncheckedUpdateInput>
    /**
     * Choose, which MotherTongue to update.
     */
    where: MotherTongueWhereUniqueInput
  }

  /**
   * MotherTongue updateMany
   */
  export type MotherTongueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MotherTongues.
     */
    data: XOR<MotherTongueUpdateManyMutationInput, MotherTongueUncheckedUpdateManyInput>
    /**
     * Filter which MotherTongues to update
     */
    where?: MotherTongueWhereInput
  }

  /**
   * MotherTongue upsert
   */
  export type MotherTongueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * The filter to search for the MotherTongue to update in case it exists.
     */
    where: MotherTongueWhereUniqueInput
    /**
     * In case the MotherTongue found by the `where` argument doesn't exist, create a new MotherTongue with this data.
     */
    create: XOR<MotherTongueCreateInput, MotherTongueUncheckedCreateInput>
    /**
     * In case the MotherTongue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MotherTongueUpdateInput, MotherTongueUncheckedUpdateInput>
  }

  /**
   * MotherTongue delete
   */
  export type MotherTongueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter which MotherTongue to delete.
     */
    where: MotherTongueWhereUniqueInput
  }

  /**
   * MotherTongue deleteMany
   */
  export type MotherTongueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MotherTongues to delete
     */
    where?: MotherTongueWhereInput
  }

  /**
   * MotherTongue.Diversity
   */
  export type MotherTongue$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * MotherTongue.Preference
   */
  export type MotherTongue$PreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preference
     */
    select?: PreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceInclude<ExtArgs> | null
    where?: PreferenceWhereInput
    orderBy?: PreferenceOrderByWithRelationInput | PreferenceOrderByWithRelationInput[]
    cursor?: PreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferenceScalarFieldEnum | PreferenceScalarFieldEnum[]
  }

  /**
   * MotherTongue without action
   */
  export type MotherTongueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
  }


  /**
   * Model Astrology
   */

  export type AggregateAstrology = {
    _count: AstrologyCountAggregateOutputType | null
    _avg: AstrologyAvgAggregateOutputType | null
    _sum: AstrologySumAggregateOutputType | null
    _min: AstrologyMinAggregateOutputType | null
    _max: AstrologyMaxAggregateOutputType | null
  }

  export type AstrologyAvgAggregateOutputType = {
    id: number | null
  }

  export type AstrologySumAggregateOutputType = {
    id: number | null
  }

  export type AstrologyMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type AstrologyMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type AstrologyCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type AstrologyAvgAggregateInputType = {
    id?: true
  }

  export type AstrologySumAggregateInputType = {
    id?: true
  }

  export type AstrologyMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type AstrologyMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type AstrologyCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type AstrologyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Astrology to aggregate.
     */
    where?: AstrologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Astrologies to fetch.
     */
    orderBy?: AstrologyOrderByWithRelationInput | AstrologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AstrologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Astrologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Astrologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Astrologies
    **/
    _count?: true | AstrologyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AstrologyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AstrologySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AstrologyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AstrologyMaxAggregateInputType
  }

  export type GetAstrologyAggregateType<T extends AstrologyAggregateArgs> = {
        [P in keyof T & keyof AggregateAstrology]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAstrology[P]>
      : GetScalarType<T[P], AggregateAstrology[P]>
  }




  export type AstrologyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AstrologyWhereInput
    orderBy?: AstrologyOrderByWithAggregationInput | AstrologyOrderByWithAggregationInput[]
    by: AstrologyScalarFieldEnum[] | AstrologyScalarFieldEnum
    having?: AstrologyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AstrologyCountAggregateInputType | true
    _avg?: AstrologyAvgAggregateInputType
    _sum?: AstrologySumAggregateInputType
    _min?: AstrologyMinAggregateInputType
    _max?: AstrologyMaxAggregateInputType
  }

  export type AstrologyGroupByOutputType = {
    id: number
    title: string
    _count: AstrologyCountAggregateOutputType | null
    _avg: AstrologyAvgAggregateOutputType | null
    _sum: AstrologySumAggregateOutputType | null
    _min: AstrologyMinAggregateOutputType | null
    _max: AstrologyMaxAggregateOutputType | null
  }

  type GetAstrologyGroupByPayload<T extends AstrologyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AstrologyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AstrologyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AstrologyGroupByOutputType[P]>
            : GetScalarType<T[P], AstrologyGroupByOutputType[P]>
        }
      >
    >


  export type AstrologySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    AdditionalDetail?: boolean | Astrology$AdditionalDetailArgs<ExtArgs>
    _count?: boolean | AstrologyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["astrology"]>

  export type AstrologySelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type AstrologyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdditionalDetail?: boolean | Astrology$AdditionalDetailArgs<ExtArgs>
    _count?: boolean | AstrologyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AstrologyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Astrology"
    objects: {
      AdditionalDetail: Prisma.$AdditionalDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["astrology"]>
    composites: {}
  }


  type AstrologyGetPayload<S extends boolean | null | undefined | AstrologyDefaultArgs> = $Result.GetResult<Prisma.$AstrologyPayload, S>

  type AstrologyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AstrologyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AstrologyCountAggregateInputType | true
    }

  export interface AstrologyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Astrology'], meta: { name: 'Astrology' } }
    /**
     * Find zero or one Astrology that matches the filter.
     * @param {AstrologyFindUniqueArgs} args - Arguments to find a Astrology
     * @example
     * // Get one Astrology
     * const astrology = await prisma.astrology.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AstrologyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyFindUniqueArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Astrology that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AstrologyFindUniqueOrThrowArgs} args - Arguments to find a Astrology
     * @example
     * // Get one Astrology
     * const astrology = await prisma.astrology.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AstrologyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Astrology that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyFindFirstArgs} args - Arguments to find a Astrology
     * @example
     * // Get one Astrology
     * const astrology = await prisma.astrology.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AstrologyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyFindFirstArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Astrology that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyFindFirstOrThrowArgs} args - Arguments to find a Astrology
     * @example
     * // Get one Astrology
     * const astrology = await prisma.astrology.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AstrologyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Astrologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Astrologies
     * const astrologies = await prisma.astrology.findMany()
     * 
     * // Get first 10 Astrologies
     * const astrologies = await prisma.astrology.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const astrologyWithIdOnly = await prisma.astrology.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AstrologyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Astrology.
     * @param {AstrologyCreateArgs} args - Arguments to create a Astrology.
     * @example
     * // Create one Astrology
     * const Astrology = await prisma.astrology.create({
     *   data: {
     *     // ... data to create a Astrology
     *   }
     * })
     * 
    **/
    create<T extends AstrologyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyCreateArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Astrologies.
     *     @param {AstrologyCreateManyArgs} args - Arguments to create many Astrologies.
     *     @example
     *     // Create many Astrologies
     *     const astrology = await prisma.astrology.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AstrologyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Astrology.
     * @param {AstrologyDeleteArgs} args - Arguments to delete one Astrology.
     * @example
     * // Delete one Astrology
     * const Astrology = await prisma.astrology.delete({
     *   where: {
     *     // ... filter to delete one Astrology
     *   }
     * })
     * 
    **/
    delete<T extends AstrologyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyDeleteArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Astrology.
     * @param {AstrologyUpdateArgs} args - Arguments to update one Astrology.
     * @example
     * // Update one Astrology
     * const astrology = await prisma.astrology.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AstrologyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyUpdateArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Astrologies.
     * @param {AstrologyDeleteManyArgs} args - Arguments to filter Astrologies to delete.
     * @example
     * // Delete a few Astrologies
     * const { count } = await prisma.astrology.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AstrologyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Astrologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Astrologies
     * const astrology = await prisma.astrology.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AstrologyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Astrology.
     * @param {AstrologyUpsertArgs} args - Arguments to update or create a Astrology.
     * @example
     * // Update or create a Astrology
     * const astrology = await prisma.astrology.upsert({
     *   create: {
     *     // ... data to create a Astrology
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Astrology we want to update
     *   }
     * })
    **/
    upsert<T extends AstrologyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyUpsertArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Astrologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyCountArgs} args - Arguments to filter Astrologies to count.
     * @example
     * // Count the number of Astrologies
     * const count = await prisma.astrology.count({
     *   where: {
     *     // ... the filter for the Astrologies we want to count
     *   }
     * })
    **/
    count<T extends AstrologyCountArgs>(
      args?: Subset<T, AstrologyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AstrologyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Astrology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AstrologyAggregateArgs>(args: Subset<T, AstrologyAggregateArgs>): Prisma.PrismaPromise<GetAstrologyAggregateType<T>>

    /**
     * Group by Astrology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AstrologyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AstrologyGroupByArgs['orderBy'] }
        : { orderBy?: AstrologyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AstrologyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAstrologyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Astrology model
   */
  readonly fields: AstrologyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Astrology.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AstrologyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    AdditionalDetail<T extends Astrology$AdditionalDetailArgs<ExtArgs> = {}>(args?: Subset<T, Astrology$AdditionalDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Astrology model
   */ 
  interface AstrologyFieldRefs {
    readonly id: FieldRef<"Astrology", 'Int'>
    readonly title: FieldRef<"Astrology", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Astrology findUnique
   */
  export type AstrologyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrology to fetch.
     */
    where: AstrologyWhereUniqueInput
  }

  /**
   * Astrology findUniqueOrThrow
   */
  export type AstrologyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrology to fetch.
     */
    where: AstrologyWhereUniqueInput
  }

  /**
   * Astrology findFirst
   */
  export type AstrologyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrology to fetch.
     */
    where?: AstrologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Astrologies to fetch.
     */
    orderBy?: AstrologyOrderByWithRelationInput | AstrologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Astrologies.
     */
    cursor?: AstrologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Astrologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Astrologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Astrologies.
     */
    distinct?: AstrologyScalarFieldEnum | AstrologyScalarFieldEnum[]
  }

  /**
   * Astrology findFirstOrThrow
   */
  export type AstrologyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrology to fetch.
     */
    where?: AstrologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Astrologies to fetch.
     */
    orderBy?: AstrologyOrderByWithRelationInput | AstrologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Astrologies.
     */
    cursor?: AstrologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Astrologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Astrologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Astrologies.
     */
    distinct?: AstrologyScalarFieldEnum | AstrologyScalarFieldEnum[]
  }

  /**
   * Astrology findMany
   */
  export type AstrologyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrologies to fetch.
     */
    where?: AstrologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Astrologies to fetch.
     */
    orderBy?: AstrologyOrderByWithRelationInput | AstrologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Astrologies.
     */
    cursor?: AstrologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Astrologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Astrologies.
     */
    skip?: number
    distinct?: AstrologyScalarFieldEnum | AstrologyScalarFieldEnum[]
  }

  /**
   * Astrology create
   */
  export type AstrologyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * The data needed to create a Astrology.
     */
    data: XOR<AstrologyCreateInput, AstrologyUncheckedCreateInput>
  }

  /**
   * Astrology createMany
   */
  export type AstrologyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Astrologies.
     */
    data: AstrologyCreateManyInput | AstrologyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Astrology update
   */
  export type AstrologyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * The data needed to update a Astrology.
     */
    data: XOR<AstrologyUpdateInput, AstrologyUncheckedUpdateInput>
    /**
     * Choose, which Astrology to update.
     */
    where: AstrologyWhereUniqueInput
  }

  /**
   * Astrology updateMany
   */
  export type AstrologyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Astrologies.
     */
    data: XOR<AstrologyUpdateManyMutationInput, AstrologyUncheckedUpdateManyInput>
    /**
     * Filter which Astrologies to update
     */
    where?: AstrologyWhereInput
  }

  /**
   * Astrology upsert
   */
  export type AstrologyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * The filter to search for the Astrology to update in case it exists.
     */
    where: AstrologyWhereUniqueInput
    /**
     * In case the Astrology found by the `where` argument doesn't exist, create a new Astrology with this data.
     */
    create: XOR<AstrologyCreateInput, AstrologyUncheckedCreateInput>
    /**
     * In case the Astrology was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AstrologyUpdateInput, AstrologyUncheckedUpdateInput>
  }

  /**
   * Astrology delete
   */
  export type AstrologyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter which Astrology to delete.
     */
    where: AstrologyWhereUniqueInput
  }

  /**
   * Astrology deleteMany
   */
  export type AstrologyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Astrologies to delete
     */
    where?: AstrologyWhereInput
  }

  /**
   * Astrology.AdditionalDetail
   */
  export type Astrology$AdditionalDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    where?: AdditionalDetailWhereInput
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    cursor?: AdditionalDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdditionalDetailScalarFieldEnum | AdditionalDetailScalarFieldEnum[]
  }

  /**
   * Astrology without action
   */
  export type AstrologyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
  }


  /**
   * Model Connection
   */

  export type AggregateConnection = {
    _count: ConnectionCountAggregateOutputType | null
    _avg: ConnectionAvgAggregateOutputType | null
    _sum: ConnectionSumAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  export type ConnectionAvgAggregateOutputType = {
    id: number | null
    sentById: number | null
    receivedById: number | null
  }

  export type ConnectionSumAggregateOutputType = {
    id: number | null
    sentById: number | null
    receivedById: number | null
  }

  export type ConnectionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sentById: number | null
    receivedById: number | null
    status: string | null
  }

  export type ConnectionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sentById: number | null
    receivedById: number | null
    status: string | null
  }

  export type ConnectionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    sentById: number
    receivedById: number
    status: number
    _all: number
  }


  export type ConnectionAvgAggregateInputType = {
    id?: true
    sentById?: true
    receivedById?: true
  }

  export type ConnectionSumAggregateInputType = {
    id?: true
    sentById?: true
    receivedById?: true
  }

  export type ConnectionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    sentById?: true
    receivedById?: true
    status?: true
  }

  export type ConnectionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    sentById?: true
    receivedById?: true
    status?: true
  }

  export type ConnectionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    sentById?: true
    receivedById?: true
    status?: true
    _all?: true
  }

  export type ConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connection to aggregate.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Connections
    **/
    _count?: true | ConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConnectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConnectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionMaxAggregateInputType
  }

  export type GetConnectionAggregateType<T extends ConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnection[P]>
      : GetScalarType<T[P], AggregateConnection[P]>
  }




  export type ConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithAggregationInput | ConnectionOrderByWithAggregationInput[]
    by: ConnectionScalarFieldEnum[] | ConnectionScalarFieldEnum
    having?: ConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionCountAggregateInputType | true
    _avg?: ConnectionAvgAggregateInputType
    _sum?: ConnectionSumAggregateInputType
    _min?: ConnectionMinAggregateInputType
    _max?: ConnectionMaxAggregateInputType
  }

  export type ConnectionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    sentById: number
    receivedById: number
    status: string
    _count: ConnectionCountAggregateOutputType | null
    _avg: ConnectionAvgAggregateOutputType | null
    _sum: ConnectionSumAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  type GetConnectionGroupByPayload<T extends ConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentById?: boolean
    receivedById?: boolean
    status?: boolean
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentById?: boolean
    receivedById?: boolean
    status?: boolean
  }


  export type ConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Connection"
    objects: {
      sentBy: Prisma.$UserPayload<ExtArgs>
      receivedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      sentById: number
      receivedById: number
      status: string
    }, ExtArgs["result"]["connection"]>
    composites: {}
  }


  type ConnectionGetPayload<S extends boolean | null | undefined | ConnectionDefaultArgs> = $Result.GetResult<Prisma.$ConnectionPayload, S>

  type ConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConnectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConnectionCountAggregateInputType | true
    }

  export interface ConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Connection'], meta: { name: 'Connection' } }
    /**
     * Find zero or one Connection that matches the filter.
     * @param {ConnectionFindUniqueArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConnectionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionFindUniqueArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Connection that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConnectionFindUniqueOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConnectionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Connection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConnectionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionFindFirstArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Connection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConnectionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Connections
     * const connections = await prisma.connection.findMany()
     * 
     * // Get first 10 Connections
     * const connections = await prisma.connection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectionWithIdOnly = await prisma.connection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConnectionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Connection.
     * @param {ConnectionCreateArgs} args - Arguments to create a Connection.
     * @example
     * // Create one Connection
     * const Connection = await prisma.connection.create({
     *   data: {
     *     // ... data to create a Connection
     *   }
     * })
     * 
    **/
    create<T extends ConnectionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionCreateArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Connections.
     *     @param {ConnectionCreateManyArgs} args - Arguments to create many Connections.
     *     @example
     *     // Create many Connections
     *     const connection = await prisma.connection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConnectionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Connection.
     * @param {ConnectionDeleteArgs} args - Arguments to delete one Connection.
     * @example
     * // Delete one Connection
     * const Connection = await prisma.connection.delete({
     *   where: {
     *     // ... filter to delete one Connection
     *   }
     * })
     * 
    **/
    delete<T extends ConnectionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionDeleteArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Connection.
     * @param {ConnectionUpdateArgs} args - Arguments to update one Connection.
     * @example
     * // Update one Connection
     * const connection = await prisma.connection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConnectionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionUpdateArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Connections.
     * @param {ConnectionDeleteManyArgs} args - Arguments to filter Connections to delete.
     * @example
     * // Delete a few Connections
     * const { count } = await prisma.connection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConnectionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConnectionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Connection.
     * @param {ConnectionUpsertArgs} args - Arguments to update or create a Connection.
     * @example
     * // Update or create a Connection
     * const connection = await prisma.connection.upsert({
     *   create: {
     *     // ... data to create a Connection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Connection we want to update
     *   }
     * })
    **/
    upsert<T extends ConnectionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionUpsertArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionCountArgs} args - Arguments to filter Connections to count.
     * @example
     * // Count the number of Connections
     * const count = await prisma.connection.count({
     *   where: {
     *     // ... the filter for the Connections we want to count
     *   }
     * })
    **/
    count<T extends ConnectionCountArgs>(
      args?: Subset<T, ConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionAggregateArgs>(args: Subset<T, ConnectionAggregateArgs>): Prisma.PrismaPromise<GetConnectionAggregateType<T>>

    /**
     * Group by Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Connection model
   */
  readonly fields: ConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Connection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sentBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    receivedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Connection model
   */ 
  interface ConnectionFieldRefs {
    readonly id: FieldRef<"Connection", 'Int'>
    readonly createdAt: FieldRef<"Connection", 'DateTime'>
    readonly updatedAt: FieldRef<"Connection", 'DateTime'>
    readonly sentById: FieldRef<"Connection", 'Int'>
    readonly receivedById: FieldRef<"Connection", 'Int'>
    readonly status: FieldRef<"Connection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Connection findUnique
   */
  export type ConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findUniqueOrThrow
   */
  export type ConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findFirst
   */
  export type ConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findFirstOrThrow
   */
  export type ConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findMany
   */
  export type ConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connections to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection create
   */
  export type ConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Connection.
     */
    data: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
  }

  /**
   * Connection createMany
   */
  export type ConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Connection update
   */
  export type ConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Connection.
     */
    data: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
    /**
     * Choose, which Connection to update.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection updateMany
   */
  export type ConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput
  }

  /**
   * Connection upsert
   */
  export type ConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Connection to update in case it exists.
     */
    where: ConnectionWhereUniqueInput
    /**
     * In case the Connection found by the `where` argument doesn't exist, create a new Connection with this data.
     */
    create: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
    /**
     * In case the Connection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
  }

  /**
   * Connection delete
   */
  export type ConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter which Connection to delete.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection deleteMany
   */
  export type ConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connections to delete
     */
    where?: ConnectionWhereInput
  }

  /**
   * Connection without action
   */
  export type ConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    bio: 'bio',
    image: 'image',
    maritalStatusId: 'maritalStatusId',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DiversityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    religionId: 'religionId',
    countryId: 'countryId',
    cityId: 'cityId',
    communityId: 'communityId',
    motherTongueId: 'motherTongueId'
  };

  export type DiversityScalarFieldEnum = (typeof DiversityScalarFieldEnum)[keyof typeof DiversityScalarFieldEnum]


  export const AdditionalDetailScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    astrologicalId: 'astrologicalId',
    facebookProfileLink: 'facebookProfileLink',
    contactNumber: 'contactNumber'
  };

  export type AdditionalDetailScalarFieldEnum = (typeof AdditionalDetailScalarFieldEnum)[keyof typeof AdditionalDetailScalarFieldEnum]


  export const PreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    countryId: 'countryId',
    cityId: 'cityId',
    motherTongueId: 'motherTongueId',
    communityId: 'communityId',
    religionId: 'religionId',
    maritalStatusId: 'maritalStatusId'
  };

  export type PreferenceScalarFieldEnum = (typeof PreferenceScalarFieldEnum)[keyof typeof PreferenceScalarFieldEnum]


  export const MaritalStatusScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type MaritalStatusScalarFieldEnum = (typeof MaritalStatusScalarFieldEnum)[keyof typeof MaritalStatusScalarFieldEnum]


  export const ReligionScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type ReligionScalarFieldEnum = (typeof ReligionScalarFieldEnum)[keyof typeof ReligionScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    countryId: 'countryId'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const MotherTongueScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type MotherTongueScalarFieldEnum = (typeof MotherTongueScalarFieldEnum)[keyof typeof MotherTongueScalarFieldEnum]


  export const AstrologyScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type AstrologyScalarFieldEnum = (typeof AstrologyScalarFieldEnum)[keyof typeof AstrologyScalarFieldEnum]


  export const ConnectionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sentById: 'sentById',
    receivedById: 'receivedById',
    status: 'status'
  };

  export type ConnectionScalarFieldEnum = (typeof ConnectionScalarFieldEnum)[keyof typeof ConnectionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeFilter<"User"> | Date | string
    gender?: StringFilter<"User"> | string
    bio?: StringFilter<"User"> | string
    image?: StringFilter<"User"> | string
    maritalStatusId?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
    maritalStatus?: XOR<MaritalStatusRelationFilter, MaritalStatusWhereInput>
    diversity?: XOR<DiversityNullableRelationFilter, DiversityWhereInput> | null
    additionalDetail?: XOR<AdditionalDetailNullableRelationFilter, AdditionalDetailWhereInput> | null
    Preference?: XOR<PreferenceNullableRelationFilter, PreferenceWhereInput> | null
    sentConnections?: ConnectionListRelationFilter
    receivedConnections?: ConnectionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
    maritalStatus?: MaritalStatusOrderByWithRelationInput
    diversity?: DiversityOrderByWithRelationInput
    additionalDetail?: AdditionalDetailOrderByWithRelationInput
    Preference?: PreferenceOrderByWithRelationInput
    sentConnections?: ConnectionOrderByRelationAggregateInput
    receivedConnections?: ConnectionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeFilter<"User"> | Date | string
    gender?: StringFilter<"User"> | string
    bio?: StringFilter<"User"> | string
    image?: StringFilter<"User"> | string
    maritalStatusId?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
    maritalStatus?: XOR<MaritalStatusRelationFilter, MaritalStatusWhereInput>
    diversity?: XOR<DiversityNullableRelationFilter, DiversityWhereInput> | null
    additionalDetail?: XOR<AdditionalDetailNullableRelationFilter, AdditionalDetailWhereInput> | null
    Preference?: XOR<PreferenceNullableRelationFilter, PreferenceWhereInput> | null
    sentConnections?: ConnectionListRelationFilter
    receivedConnections?: ConnectionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"User"> | Date | string
    gender?: StringWithAggregatesFilter<"User"> | string
    bio?: StringWithAggregatesFilter<"User"> | string
    image?: StringWithAggregatesFilter<"User"> | string
    maritalStatusId?: IntWithAggregatesFilter<"User"> | number
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type DiversityWhereInput = {
    AND?: DiversityWhereInput | DiversityWhereInput[]
    OR?: DiversityWhereInput[]
    NOT?: DiversityWhereInput | DiversityWhereInput[]
    id?: IntFilter<"Diversity"> | number
    userId?: IntFilter<"Diversity"> | number
    religionId?: IntFilter<"Diversity"> | number
    countryId?: IntFilter<"Diversity"> | number
    cityId?: IntFilter<"Diversity"> | number
    communityId?: IntFilter<"Diversity"> | number
    motherTongueId?: IntFilter<"Diversity"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    religion?: XOR<ReligionRelationFilter, ReligionWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    motherTongue?: XOR<MotherTongueRelationFilter, MotherTongueWhereInput>
  }

  export type DiversityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
    user?: UserOrderByWithRelationInput
    religion?: ReligionOrderByWithRelationInput
    country?: CountryOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
    motherTongue?: MotherTongueOrderByWithRelationInput
  }

  export type DiversityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: DiversityWhereInput | DiversityWhereInput[]
    OR?: DiversityWhereInput[]
    NOT?: DiversityWhereInput | DiversityWhereInput[]
    religionId?: IntFilter<"Diversity"> | number
    countryId?: IntFilter<"Diversity"> | number
    cityId?: IntFilter<"Diversity"> | number
    communityId?: IntFilter<"Diversity"> | number
    motherTongueId?: IntFilter<"Diversity"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    religion?: XOR<ReligionRelationFilter, ReligionWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    motherTongue?: XOR<MotherTongueRelationFilter, MotherTongueWhereInput>
  }, "id" | "userId">

  export type DiversityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
    _count?: DiversityCountOrderByAggregateInput
    _avg?: DiversityAvgOrderByAggregateInput
    _max?: DiversityMaxOrderByAggregateInput
    _min?: DiversityMinOrderByAggregateInput
    _sum?: DiversitySumOrderByAggregateInput
  }

  export type DiversityScalarWhereWithAggregatesInput = {
    AND?: DiversityScalarWhereWithAggregatesInput | DiversityScalarWhereWithAggregatesInput[]
    OR?: DiversityScalarWhereWithAggregatesInput[]
    NOT?: DiversityScalarWhereWithAggregatesInput | DiversityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Diversity"> | number
    userId?: IntWithAggregatesFilter<"Diversity"> | number
    religionId?: IntWithAggregatesFilter<"Diversity"> | number
    countryId?: IntWithAggregatesFilter<"Diversity"> | number
    cityId?: IntWithAggregatesFilter<"Diversity"> | number
    communityId?: IntWithAggregatesFilter<"Diversity"> | number
    motherTongueId?: IntWithAggregatesFilter<"Diversity"> | number
  }

  export type AdditionalDetailWhereInput = {
    AND?: AdditionalDetailWhereInput | AdditionalDetailWhereInput[]
    OR?: AdditionalDetailWhereInput[]
    NOT?: AdditionalDetailWhereInput | AdditionalDetailWhereInput[]
    id?: IntFilter<"AdditionalDetail"> | number
    userId?: IntFilter<"AdditionalDetail"> | number
    astrologicalId?: IntFilter<"AdditionalDetail"> | number
    facebookProfileLink?: StringFilter<"AdditionalDetail"> | string
    contactNumber?: StringFilter<"AdditionalDetail"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    astrology?: XOR<AstrologyRelationFilter, AstrologyWhereInput>
  }

  export type AdditionalDetailOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
    user?: UserOrderByWithRelationInput
    astrology?: AstrologyOrderByWithRelationInput
  }

  export type AdditionalDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AdditionalDetailWhereInput | AdditionalDetailWhereInput[]
    OR?: AdditionalDetailWhereInput[]
    NOT?: AdditionalDetailWhereInput | AdditionalDetailWhereInput[]
    astrologicalId?: IntFilter<"AdditionalDetail"> | number
    facebookProfileLink?: StringFilter<"AdditionalDetail"> | string
    contactNumber?: StringFilter<"AdditionalDetail"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    astrology?: XOR<AstrologyRelationFilter, AstrologyWhereInput>
  }, "id" | "userId">

  export type AdditionalDetailOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
    _count?: AdditionalDetailCountOrderByAggregateInput
    _avg?: AdditionalDetailAvgOrderByAggregateInput
    _max?: AdditionalDetailMaxOrderByAggregateInput
    _min?: AdditionalDetailMinOrderByAggregateInput
    _sum?: AdditionalDetailSumOrderByAggregateInput
  }

  export type AdditionalDetailScalarWhereWithAggregatesInput = {
    AND?: AdditionalDetailScalarWhereWithAggregatesInput | AdditionalDetailScalarWhereWithAggregatesInput[]
    OR?: AdditionalDetailScalarWhereWithAggregatesInput[]
    NOT?: AdditionalDetailScalarWhereWithAggregatesInput | AdditionalDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdditionalDetail"> | number
    userId?: IntWithAggregatesFilter<"AdditionalDetail"> | number
    astrologicalId?: IntWithAggregatesFilter<"AdditionalDetail"> | number
    facebookProfileLink?: StringWithAggregatesFilter<"AdditionalDetail"> | string
    contactNumber?: StringWithAggregatesFilter<"AdditionalDetail"> | string
  }

  export type PreferenceWhereInput = {
    AND?: PreferenceWhereInput | PreferenceWhereInput[]
    OR?: PreferenceWhereInput[]
    NOT?: PreferenceWhereInput | PreferenceWhereInput[]
    id?: IntFilter<"Preference"> | number
    userId?: IntFilter<"Preference"> | number
    countryId?: IntFilter<"Preference"> | number
    cityId?: IntFilter<"Preference"> | number
    motherTongueId?: IntFilter<"Preference"> | number
    communityId?: IntFilter<"Preference"> | number
    religionId?: IntFilter<"Preference"> | number
    maritalStatusId?: IntFilter<"Preference"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    motherTongue?: XOR<MotherTongueRelationFilter, MotherTongueWhereInput>
    community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    religion?: XOR<ReligionRelationFilter, ReligionWhereInput>
    maritalStatus?: XOR<MaritalStatusRelationFilter, MaritalStatusWhereInput>
  }

  export type PreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    maritalStatusId?: SortOrder
    user?: UserOrderByWithRelationInput
    country?: CountryOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    motherTongue?: MotherTongueOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
    religion?: ReligionOrderByWithRelationInput
    maritalStatus?: MaritalStatusOrderByWithRelationInput
  }

  export type PreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: PreferenceWhereInput | PreferenceWhereInput[]
    OR?: PreferenceWhereInput[]
    NOT?: PreferenceWhereInput | PreferenceWhereInput[]
    countryId?: IntFilter<"Preference"> | number
    cityId?: IntFilter<"Preference"> | number
    motherTongueId?: IntFilter<"Preference"> | number
    communityId?: IntFilter<"Preference"> | number
    religionId?: IntFilter<"Preference"> | number
    maritalStatusId?: IntFilter<"Preference"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    motherTongue?: XOR<MotherTongueRelationFilter, MotherTongueWhereInput>
    community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    religion?: XOR<ReligionRelationFilter, ReligionWhereInput>
    maritalStatus?: XOR<MaritalStatusRelationFilter, MaritalStatusWhereInput>
  }, "id" | "userId">

  export type PreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    maritalStatusId?: SortOrder
    _count?: PreferenceCountOrderByAggregateInput
    _avg?: PreferenceAvgOrderByAggregateInput
    _max?: PreferenceMaxOrderByAggregateInput
    _min?: PreferenceMinOrderByAggregateInput
    _sum?: PreferenceSumOrderByAggregateInput
  }

  export type PreferenceScalarWhereWithAggregatesInput = {
    AND?: PreferenceScalarWhereWithAggregatesInput | PreferenceScalarWhereWithAggregatesInput[]
    OR?: PreferenceScalarWhereWithAggregatesInput[]
    NOT?: PreferenceScalarWhereWithAggregatesInput | PreferenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Preference"> | number
    userId?: IntWithAggregatesFilter<"Preference"> | number
    countryId?: IntWithAggregatesFilter<"Preference"> | number
    cityId?: IntWithAggregatesFilter<"Preference"> | number
    motherTongueId?: IntWithAggregatesFilter<"Preference"> | number
    communityId?: IntWithAggregatesFilter<"Preference"> | number
    religionId?: IntWithAggregatesFilter<"Preference"> | number
    maritalStatusId?: IntWithAggregatesFilter<"Preference"> | number
  }

  export type MaritalStatusWhereInput = {
    AND?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    OR?: MaritalStatusWhereInput[]
    NOT?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    id?: IntFilter<"MaritalStatus"> | number
    title?: StringFilter<"MaritalStatus"> | string
    users?: UserListRelationFilter
    Preference?: PreferenceListRelationFilter
  }

  export type MaritalStatusOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    users?: UserOrderByRelationAggregateInput
    Preference?: PreferenceOrderByRelationAggregateInput
  }

  export type MaritalStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    OR?: MaritalStatusWhereInput[]
    NOT?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    users?: UserListRelationFilter
    Preference?: PreferenceListRelationFilter
  }, "id" | "title">

  export type MaritalStatusOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: MaritalStatusCountOrderByAggregateInput
    _avg?: MaritalStatusAvgOrderByAggregateInput
    _max?: MaritalStatusMaxOrderByAggregateInput
    _min?: MaritalStatusMinOrderByAggregateInput
    _sum?: MaritalStatusSumOrderByAggregateInput
  }

  export type MaritalStatusScalarWhereWithAggregatesInput = {
    AND?: MaritalStatusScalarWhereWithAggregatesInput | MaritalStatusScalarWhereWithAggregatesInput[]
    OR?: MaritalStatusScalarWhereWithAggregatesInput[]
    NOT?: MaritalStatusScalarWhereWithAggregatesInput | MaritalStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaritalStatus"> | number
    title?: StringWithAggregatesFilter<"MaritalStatus"> | string
  }

  export type ReligionWhereInput = {
    AND?: ReligionWhereInput | ReligionWhereInput[]
    OR?: ReligionWhereInput[]
    NOT?: ReligionWhereInput | ReligionWhereInput[]
    id?: IntFilter<"Religion"> | number
    title?: StringFilter<"Religion"> | string
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }

  export type ReligionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    Diversity?: DiversityOrderByRelationAggregateInput
    Preference?: PreferenceOrderByRelationAggregateInput
  }

  export type ReligionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: ReligionWhereInput | ReligionWhereInput[]
    OR?: ReligionWhereInput[]
    NOT?: ReligionWhereInput | ReligionWhereInput[]
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }, "id" | "title">

  export type ReligionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: ReligionCountOrderByAggregateInput
    _avg?: ReligionAvgOrderByAggregateInput
    _max?: ReligionMaxOrderByAggregateInput
    _min?: ReligionMinOrderByAggregateInput
    _sum?: ReligionSumOrderByAggregateInput
  }

  export type ReligionScalarWhereWithAggregatesInput = {
    AND?: ReligionScalarWhereWithAggregatesInput | ReligionScalarWhereWithAggregatesInput[]
    OR?: ReligionScalarWhereWithAggregatesInput[]
    NOT?: ReligionScalarWhereWithAggregatesInput | ReligionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Religion"> | number
    title?: StringWithAggregatesFilter<"Religion"> | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    title?: StringFilter<"Country"> | string
    cities?: CityListRelationFilter
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    cities?: CityOrderByRelationAggregateInput
    Diversity?: DiversityOrderByRelationAggregateInput
    Preference?: PreferenceOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    cities?: CityListRelationFilter
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }, "id" | "title">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    title?: StringWithAggregatesFilter<"Country"> | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: IntFilter<"City"> | number
    title?: StringFilter<"City"> | string
    countryId?: IntFilter<"City"> | number
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
    country?: CountryOrderByWithRelationInput
    Diversity?: DiversityOrderByRelationAggregateInput
    Preference?: PreferenceOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    countryId?: IntFilter<"City"> | number
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }, "id" | "title">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"City"> | number
    title?: StringWithAggregatesFilter<"City"> | string
    countryId?: IntWithAggregatesFilter<"City"> | number
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: IntFilter<"Community"> | number
    title?: StringFilter<"Community"> | string
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    Diversity?: DiversityOrderByRelationAggregateInput
    Preference?: PreferenceOrderByRelationAggregateInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }, "id" | "title">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Community"> | number
    title?: StringWithAggregatesFilter<"Community"> | string
  }

  export type MotherTongueWhereInput = {
    AND?: MotherTongueWhereInput | MotherTongueWhereInput[]
    OR?: MotherTongueWhereInput[]
    NOT?: MotherTongueWhereInput | MotherTongueWhereInput[]
    id?: IntFilter<"MotherTongue"> | number
    title?: StringFilter<"MotherTongue"> | string
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }

  export type MotherTongueOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    Diversity?: DiversityOrderByRelationAggregateInput
    Preference?: PreferenceOrderByRelationAggregateInput
  }

  export type MotherTongueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: MotherTongueWhereInput | MotherTongueWhereInput[]
    OR?: MotherTongueWhereInput[]
    NOT?: MotherTongueWhereInput | MotherTongueWhereInput[]
    Diversity?: DiversityListRelationFilter
    Preference?: PreferenceListRelationFilter
  }, "id" | "title">

  export type MotherTongueOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: MotherTongueCountOrderByAggregateInput
    _avg?: MotherTongueAvgOrderByAggregateInput
    _max?: MotherTongueMaxOrderByAggregateInput
    _min?: MotherTongueMinOrderByAggregateInput
    _sum?: MotherTongueSumOrderByAggregateInput
  }

  export type MotherTongueScalarWhereWithAggregatesInput = {
    AND?: MotherTongueScalarWhereWithAggregatesInput | MotherTongueScalarWhereWithAggregatesInput[]
    OR?: MotherTongueScalarWhereWithAggregatesInput[]
    NOT?: MotherTongueScalarWhereWithAggregatesInput | MotherTongueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MotherTongue"> | number
    title?: StringWithAggregatesFilter<"MotherTongue"> | string
  }

  export type AstrologyWhereInput = {
    AND?: AstrologyWhereInput | AstrologyWhereInput[]
    OR?: AstrologyWhereInput[]
    NOT?: AstrologyWhereInput | AstrologyWhereInput[]
    id?: IntFilter<"Astrology"> | number
    title?: StringFilter<"Astrology"> | string
    AdditionalDetail?: AdditionalDetailListRelationFilter
  }

  export type AstrologyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    AdditionalDetail?: AdditionalDetailOrderByRelationAggregateInput
  }

  export type AstrologyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: AstrologyWhereInput | AstrologyWhereInput[]
    OR?: AstrologyWhereInput[]
    NOT?: AstrologyWhereInput | AstrologyWhereInput[]
    AdditionalDetail?: AdditionalDetailListRelationFilter
  }, "id" | "title">

  export type AstrologyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: AstrologyCountOrderByAggregateInput
    _avg?: AstrologyAvgOrderByAggregateInput
    _max?: AstrologyMaxOrderByAggregateInput
    _min?: AstrologyMinOrderByAggregateInput
    _sum?: AstrologySumOrderByAggregateInput
  }

  export type AstrologyScalarWhereWithAggregatesInput = {
    AND?: AstrologyScalarWhereWithAggregatesInput | AstrologyScalarWhereWithAggregatesInput[]
    OR?: AstrologyScalarWhereWithAggregatesInput[]
    NOT?: AstrologyScalarWhereWithAggregatesInput | AstrologyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Astrology"> | number
    title?: StringWithAggregatesFilter<"Astrology"> | string
  }

  export type ConnectionWhereInput = {
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    id?: IntFilter<"Connection"> | number
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    updatedAt?: DateTimeFilter<"Connection"> | Date | string
    sentById?: IntFilter<"Connection"> | number
    receivedById?: IntFilter<"Connection"> | number
    status?: StringFilter<"Connection"> | string
    sentBy?: XOR<UserRelationFilter, UserWhereInput>
    receivedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConnectionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentById?: SortOrder
    receivedById?: SortOrder
    status?: SortOrder
    sentBy?: UserOrderByWithRelationInput
    receivedBy?: UserOrderByWithRelationInput
  }

  export type ConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    updatedAt?: DateTimeFilter<"Connection"> | Date | string
    sentById?: IntFilter<"Connection"> | number
    receivedById?: IntFilter<"Connection"> | number
    status?: StringFilter<"Connection"> | string
    sentBy?: XOR<UserRelationFilter, UserWhereInput>
    receivedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentById?: SortOrder
    receivedById?: SortOrder
    status?: SortOrder
    _count?: ConnectionCountOrderByAggregateInput
    _avg?: ConnectionAvgOrderByAggregateInput
    _max?: ConnectionMaxOrderByAggregateInput
    _min?: ConnectionMinOrderByAggregateInput
    _sum?: ConnectionSumOrderByAggregateInput
  }

  export type ConnectionScalarWhereWithAggregatesInput = {
    AND?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    OR?: ConnectionScalarWhereWithAggregatesInput[]
    NOT?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Connection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Connection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Connection"> | Date | string
    sentById?: IntWithAggregatesFilter<"Connection"> | number
    receivedById?: IntWithAggregatesFilter<"Connection"> | number
    status?: StringWithAggregatesFilter<"Connection"> | string
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    diversity?: DiversityCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    Preference?: PreferenceCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionCreateNestedManyWithoutReceivedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    Preference?: PreferenceUncheckedCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionUncheckedCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionUncheckedCreateNestedManyWithoutReceivedByInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUpdateManyWithoutReceivedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUncheckedUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUncheckedUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUncheckedUpdateManyWithoutReceivedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
  }

  export type DiversityCreateInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityUpdateInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityUpdateManyMutationInput = {

  }

  export type DiversityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type AdditionalDetailCreateInput = {
    facebookProfileLink: string
    contactNumber: string
    user: UserCreateNestedOneWithoutAdditionalDetailInput
    astrology?: AstrologyCreateNestedOneWithoutAdditionalDetailInput
  }

  export type AdditionalDetailUncheckedCreateInput = {
    id?: number
    userId: number
    astrologicalId?: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailUpdateInput = {
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdditionalDetailNestedInput
    astrology?: AstrologyUpdateOneRequiredWithoutAdditionalDetailNestedInput
  }

  export type AdditionalDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalDetailCreateManyInput = {
    id?: number
    userId: number
    astrologicalId?: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailUpdateManyMutationInput = {
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type PreferenceCreateInput = {
    user: UserCreateNestedOneWithoutPreferenceInput
    country: CountryCreateNestedOneWithoutPreferenceInput
    city: CityCreateNestedOneWithoutPreferenceInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferenceInput
    community: CommunityCreateNestedOneWithoutPreferenceInput
    religion: ReligionCreateNestedOneWithoutPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutPreferenceInput
  }

  export type PreferenceUncheckedCreateInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type PreferenceUpdateInput = {
    user?: UserUpdateOneRequiredWithoutPreferenceNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferenceNestedInput
    city?: CityUpdateOneRequiredWithoutPreferenceNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferenceNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferenceNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutPreferenceNestedInput
  }

  export type PreferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceCreateManyInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type PreferenceUpdateManyMutationInput = {

  }

  export type PreferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type MaritalStatusCreateInput = {
    title: string
    users?: UserCreateNestedManyWithoutMaritalStatusInput
    Preference?: PreferenceCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUncheckedCreateInput = {
    id?: number
    title: string
    users?: UserUncheckedCreateNestedManyWithoutMaritalStatusInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutMaritalStatusNestedInput
    Preference?: PreferenceUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMaritalStatusNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusCreateManyInput = {
    id?: number
    title: string
  }

  export type MaritalStatusUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type MaritalStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionCreateInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutReligionInput
    Preference?: PreferenceCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutReligionInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutReligionNestedInput
    Preference?: PreferenceUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutReligionNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type ReligionCreateManyInput = {
    id?: number
    title: string
  }

  export type ReligionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateInput = {
    title: string
    cities?: CityCreateNestedManyWithoutCountryInput
    Diversity?: DiversityCreateNestedManyWithoutCountryInput
    Preference?: PreferenceCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    title: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCountryInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    Diversity?: DiversityUpdateManyWithoutCountryNestedInput
    Preference?: PreferenceUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    Diversity?: DiversityUncheckedUpdateManyWithoutCountryNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    title: string
  }

  export type CountryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    title: string
    country: CountryCreateNestedOneWithoutCitiesInput
    Diversity?: DiversityCreateNestedManyWithoutCityInput
    Preference?: PreferenceCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    title: string
    countryId: number
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCityInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    Diversity?: DiversityUpdateManyWithoutCityNestedInput
    Preference?: PreferenceUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    Diversity?: DiversityUncheckedUpdateManyWithoutCityNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: number
    title: string
    countryId: number
  }

  export type CityUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityCreateInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutCommunityInput
    Preference?: PreferenceCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCommunityInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutCommunityNestedInput
    Preference?: PreferenceUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutCommunityNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: number
    title: string
  }

  export type CommunityUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type MotherTongueCreateInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutMotherTongueInput
    Preference?: PreferenceCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueUncheckedCreateInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutMotherTongueInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutMotherTongueNestedInput
    Preference?: PreferenceUpdateManyWithoutMotherTongueNestedInput
  }

  export type MotherTongueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutMotherTongueNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutMotherTongueNestedInput
  }

  export type MotherTongueCreateManyInput = {
    id?: number
    title: string
  }

  export type MotherTongueUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type MotherTongueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AstrologyCreateInput = {
    title: string
    AdditionalDetail?: AdditionalDetailCreateNestedManyWithoutAstrologyInput
  }

  export type AstrologyUncheckedCreateInput = {
    id?: number
    title: string
    AdditionalDetail?: AdditionalDetailUncheckedCreateNestedManyWithoutAstrologyInput
  }

  export type AstrologyUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    AdditionalDetail?: AdditionalDetailUpdateManyWithoutAstrologyNestedInput
  }

  export type AstrologyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    AdditionalDetail?: AdditionalDetailUncheckedUpdateManyWithoutAstrologyNestedInput
  }

  export type AstrologyCreateManyInput = {
    id?: number
    title: string
  }

  export type AstrologyUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AstrologyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    sentBy: UserCreateNestedOneWithoutSentConnectionsInput
    receivedBy: UserCreateNestedOneWithoutReceivedConnectionsInput
  }

  export type ConnectionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentById: number
    receivedById: number
    status: string
  }

  export type ConnectionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentBy?: UserUpdateOneRequiredWithoutSentConnectionsNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutReceivedConnectionsNestedInput
  }

  export type ConnectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: IntFieldUpdateOperationsInput | number
    receivedById?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentById: number
    receivedById: number
    status: string
  }

  export type ConnectionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: IntFieldUpdateOperationsInput | number
    receivedById?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type MaritalStatusRelationFilter = {
    is?: MaritalStatusWhereInput
    isNot?: MaritalStatusWhereInput
  }

  export type DiversityNullableRelationFilter = {
    is?: DiversityWhereInput | null
    isNot?: DiversityWhereInput | null
  }

  export type AdditionalDetailNullableRelationFilter = {
    is?: AdditionalDetailWhereInput | null
    isNot?: AdditionalDetailWhereInput | null
  }

  export type PreferenceNullableRelationFilter = {
    is?: PreferenceWhereInput | null
    isNot?: PreferenceWhereInput | null
  }

  export type ConnectionListRelationFilter = {
    every?: ConnectionWhereInput
    some?: ConnectionWhereInput
    none?: ConnectionWhereInput
  }

  export type ConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ReligionRelationFilter = {
    is?: ReligionWhereInput
    isNot?: ReligionWhereInput
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type CommunityRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type MotherTongueRelationFilter = {
    is?: MotherTongueWhereInput
    isNot?: MotherTongueWhereInput
  }

  export type DiversityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type DiversityAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type DiversityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type DiversityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type DiversitySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type AstrologyRelationFilter = {
    is?: AstrologyWhereInput
    isNot?: AstrologyWhereInput
  }

  export type AdditionalDetailCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
  }

  export type AdditionalDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
  }

  export type AdditionalDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
  }

  export type AdditionalDetailMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
  }

  export type AdditionalDetailSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
  }

  export type PreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type PreferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type PreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type PreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type PreferenceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PreferenceListRelationFilter = {
    every?: PreferenceWhereInput
    some?: PreferenceWhereInput
    none?: PreferenceWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaritalStatusCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaritalStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaritalStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaritalStatusMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaritalStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiversityListRelationFilter = {
    every?: DiversityWhereInput
    some?: DiversityWhereInput
    none?: DiversityWhereInput
  }

  export type DiversityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReligionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ReligionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReligionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ReligionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ReligionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MotherTongueCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MotherTongueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MotherTongueMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MotherTongueMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MotherTongueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdditionalDetailListRelationFilter = {
    every?: AdditionalDetailWhereInput
    some?: AdditionalDetailWhereInput
    none?: AdditionalDetailWhereInput
  }

  export type AdditionalDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AstrologyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type AstrologyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AstrologyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type AstrologyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type AstrologySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentById?: SortOrder
    receivedById?: SortOrder
    status?: SortOrder
  }

  export type ConnectionAvgOrderByAggregateInput = {
    id?: SortOrder
    sentById?: SortOrder
    receivedById?: SortOrder
  }

  export type ConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentById?: SortOrder
    receivedById?: SortOrder
    status?: SortOrder
  }

  export type ConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentById?: SortOrder
    receivedById?: SortOrder
    status?: SortOrder
  }

  export type ConnectionSumOrderByAggregateInput = {
    id?: SortOrder
    sentById?: SortOrder
    receivedById?: SortOrder
  }

  export type MaritalStatusCreateNestedOneWithoutUsersInput = {
    create?: XOR<MaritalStatusCreateWithoutUsersInput, MaritalStatusUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutUsersInput
    connect?: MaritalStatusWhereUniqueInput
  }

  export type DiversityCreateNestedOneWithoutUserInput = {
    create?: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiversityCreateOrConnectWithoutUserInput
    connect?: DiversityWhereUniqueInput
  }

  export type AdditionalDetailCreateNestedOneWithoutUserInput = {
    create?: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutUserInput
    connect?: AdditionalDetailWhereUniqueInput
  }

  export type PreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<PreferenceCreateWithoutUserInput, PreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: PreferenceCreateOrConnectWithoutUserInput
    connect?: PreferenceWhereUniqueInput
  }

  export type ConnectionCreateNestedManyWithoutSentByInput = {
    create?: XOR<ConnectionCreateWithoutSentByInput, ConnectionUncheckedCreateWithoutSentByInput> | ConnectionCreateWithoutSentByInput[] | ConnectionUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutSentByInput | ConnectionCreateOrConnectWithoutSentByInput[]
    createMany?: ConnectionCreateManySentByInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<ConnectionCreateWithoutReceivedByInput, ConnectionUncheckedCreateWithoutReceivedByInput> | ConnectionCreateWithoutReceivedByInput[] | ConnectionUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutReceivedByInput | ConnectionCreateOrConnectWithoutReceivedByInput[]
    createMany?: ConnectionCreateManyReceivedByInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiversityCreateOrConnectWithoutUserInput
    connect?: DiversityWhereUniqueInput
  }

  export type AdditionalDetailUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutUserInput
    connect?: AdditionalDetailWhereUniqueInput
  }

  export type PreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PreferenceCreateWithoutUserInput, PreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: PreferenceCreateOrConnectWithoutUserInput
    connect?: PreferenceWhereUniqueInput
  }

  export type ConnectionUncheckedCreateNestedManyWithoutSentByInput = {
    create?: XOR<ConnectionCreateWithoutSentByInput, ConnectionUncheckedCreateWithoutSentByInput> | ConnectionCreateWithoutSentByInput[] | ConnectionUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutSentByInput | ConnectionCreateOrConnectWithoutSentByInput[]
    createMany?: ConnectionCreateManySentByInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<ConnectionCreateWithoutReceivedByInput, ConnectionUncheckedCreateWithoutReceivedByInput> | ConnectionCreateWithoutReceivedByInput[] | ConnectionUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutReceivedByInput | ConnectionCreateOrConnectWithoutReceivedByInput[]
    createMany?: ConnectionCreateManyReceivedByInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type MaritalStatusUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<MaritalStatusCreateWithoutUsersInput, MaritalStatusUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutUsersInput
    upsert?: MaritalStatusUpsertWithoutUsersInput
    connect?: MaritalStatusWhereUniqueInput
    update?: XOR<XOR<MaritalStatusUpdateToOneWithWhereWithoutUsersInput, MaritalStatusUpdateWithoutUsersInput>, MaritalStatusUncheckedUpdateWithoutUsersInput>
  }

  export type DiversityUpdateOneWithoutUserNestedInput = {
    create?: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiversityCreateOrConnectWithoutUserInput
    upsert?: DiversityUpsertWithoutUserInput
    disconnect?: DiversityWhereInput | boolean
    delete?: DiversityWhereInput | boolean
    connect?: DiversityWhereUniqueInput
    update?: XOR<XOR<DiversityUpdateToOneWithWhereWithoutUserInput, DiversityUpdateWithoutUserInput>, DiversityUncheckedUpdateWithoutUserInput>
  }

  export type AdditionalDetailUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutUserInput
    upsert?: AdditionalDetailUpsertWithoutUserInput
    disconnect?: AdditionalDetailWhereInput | boolean
    delete?: AdditionalDetailWhereInput | boolean
    connect?: AdditionalDetailWhereUniqueInput
    update?: XOR<XOR<AdditionalDetailUpdateToOneWithWhereWithoutUserInput, AdditionalDetailUpdateWithoutUserInput>, AdditionalDetailUncheckedUpdateWithoutUserInput>
  }

  export type PreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<PreferenceCreateWithoutUserInput, PreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: PreferenceCreateOrConnectWithoutUserInput
    upsert?: PreferenceUpsertWithoutUserInput
    disconnect?: PreferenceWhereInput | boolean
    delete?: PreferenceWhereInput | boolean
    connect?: PreferenceWhereUniqueInput
    update?: XOR<XOR<PreferenceUpdateToOneWithWhereWithoutUserInput, PreferenceUpdateWithoutUserInput>, PreferenceUncheckedUpdateWithoutUserInput>
  }

  export type ConnectionUpdateManyWithoutSentByNestedInput = {
    create?: XOR<ConnectionCreateWithoutSentByInput, ConnectionUncheckedCreateWithoutSentByInput> | ConnectionCreateWithoutSentByInput[] | ConnectionUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutSentByInput | ConnectionCreateOrConnectWithoutSentByInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutSentByInput | ConnectionUpsertWithWhereUniqueWithoutSentByInput[]
    createMany?: ConnectionCreateManySentByInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutSentByInput | ConnectionUpdateWithWhereUniqueWithoutSentByInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutSentByInput | ConnectionUpdateManyWithWhereWithoutSentByInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<ConnectionCreateWithoutReceivedByInput, ConnectionUncheckedCreateWithoutReceivedByInput> | ConnectionCreateWithoutReceivedByInput[] | ConnectionUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutReceivedByInput | ConnectionCreateOrConnectWithoutReceivedByInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutReceivedByInput | ConnectionUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: ConnectionCreateManyReceivedByInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutReceivedByInput | ConnectionUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutReceivedByInput | ConnectionUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DiversityUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiversityCreateOrConnectWithoutUserInput
    upsert?: DiversityUpsertWithoutUserInput
    disconnect?: DiversityWhereInput | boolean
    delete?: DiversityWhereInput | boolean
    connect?: DiversityWhereUniqueInput
    update?: XOR<XOR<DiversityUpdateToOneWithWhereWithoutUserInput, DiversityUpdateWithoutUserInput>, DiversityUncheckedUpdateWithoutUserInput>
  }

  export type AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutUserInput
    upsert?: AdditionalDetailUpsertWithoutUserInput
    disconnect?: AdditionalDetailWhereInput | boolean
    delete?: AdditionalDetailWhereInput | boolean
    connect?: AdditionalDetailWhereUniqueInput
    update?: XOR<XOR<AdditionalDetailUpdateToOneWithWhereWithoutUserInput, AdditionalDetailUpdateWithoutUserInput>, AdditionalDetailUncheckedUpdateWithoutUserInput>
  }

  export type PreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PreferenceCreateWithoutUserInput, PreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: PreferenceCreateOrConnectWithoutUserInput
    upsert?: PreferenceUpsertWithoutUserInput
    disconnect?: PreferenceWhereInput | boolean
    delete?: PreferenceWhereInput | boolean
    connect?: PreferenceWhereUniqueInput
    update?: XOR<XOR<PreferenceUpdateToOneWithWhereWithoutUserInput, PreferenceUpdateWithoutUserInput>, PreferenceUncheckedUpdateWithoutUserInput>
  }

  export type ConnectionUncheckedUpdateManyWithoutSentByNestedInput = {
    create?: XOR<ConnectionCreateWithoutSentByInput, ConnectionUncheckedCreateWithoutSentByInput> | ConnectionCreateWithoutSentByInput[] | ConnectionUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutSentByInput | ConnectionCreateOrConnectWithoutSentByInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutSentByInput | ConnectionUpsertWithWhereUniqueWithoutSentByInput[]
    createMany?: ConnectionCreateManySentByInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutSentByInput | ConnectionUpdateWithWhereUniqueWithoutSentByInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutSentByInput | ConnectionUpdateManyWithWhereWithoutSentByInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<ConnectionCreateWithoutReceivedByInput, ConnectionUncheckedCreateWithoutReceivedByInput> | ConnectionCreateWithoutReceivedByInput[] | ConnectionUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutReceivedByInput | ConnectionCreateOrConnectWithoutReceivedByInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutReceivedByInput | ConnectionUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: ConnectionCreateManyReceivedByInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutReceivedByInput | ConnectionUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutReceivedByInput | ConnectionUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDiversityInput = {
    create?: XOR<UserCreateWithoutDiversityInput, UserUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiversityInput
    connect?: UserWhereUniqueInput
  }

  export type ReligionCreateNestedOneWithoutDiversityInput = {
    create?: XOR<ReligionCreateWithoutDiversityInput, ReligionUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutDiversityInput
    connect?: ReligionWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutDiversityInput = {
    create?: XOR<CountryCreateWithoutDiversityInput, CountryUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDiversityInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutDiversityInput = {
    create?: XOR<CityCreateWithoutDiversityInput, CityUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CityCreateOrConnectWithoutDiversityInput
    connect?: CityWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutDiversityInput = {
    create?: XOR<CommunityCreateWithoutDiversityInput, CommunityUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutDiversityInput
    connect?: CommunityWhereUniqueInput
  }

  export type MotherTongueCreateNestedOneWithoutDiversityInput = {
    create?: XOR<MotherTongueCreateWithoutDiversityInput, MotherTongueUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: MotherTongueCreateOrConnectWithoutDiversityInput
    connect?: MotherTongueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<UserCreateWithoutDiversityInput, UserUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiversityInput
    upsert?: UserUpsertWithoutDiversityInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDiversityInput, UserUpdateWithoutDiversityInput>, UserUncheckedUpdateWithoutDiversityInput>
  }

  export type ReligionUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<ReligionCreateWithoutDiversityInput, ReligionUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutDiversityInput
    upsert?: ReligionUpsertWithoutDiversityInput
    connect?: ReligionWhereUniqueInput
    update?: XOR<XOR<ReligionUpdateToOneWithWhereWithoutDiversityInput, ReligionUpdateWithoutDiversityInput>, ReligionUncheckedUpdateWithoutDiversityInput>
  }

  export type CountryUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<CountryCreateWithoutDiversityInput, CountryUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDiversityInput
    upsert?: CountryUpsertWithoutDiversityInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutDiversityInput, CountryUpdateWithoutDiversityInput>, CountryUncheckedUpdateWithoutDiversityInput>
  }

  export type CityUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<CityCreateWithoutDiversityInput, CityUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CityCreateOrConnectWithoutDiversityInput
    upsert?: CityUpsertWithoutDiversityInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutDiversityInput, CityUpdateWithoutDiversityInput>, CityUncheckedUpdateWithoutDiversityInput>
  }

  export type CommunityUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<CommunityCreateWithoutDiversityInput, CommunityUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutDiversityInput
    upsert?: CommunityUpsertWithoutDiversityInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutDiversityInput, CommunityUpdateWithoutDiversityInput>, CommunityUncheckedUpdateWithoutDiversityInput>
  }

  export type MotherTongueUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<MotherTongueCreateWithoutDiversityInput, MotherTongueUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: MotherTongueCreateOrConnectWithoutDiversityInput
    upsert?: MotherTongueUpsertWithoutDiversityInput
    connect?: MotherTongueWhereUniqueInput
    update?: XOR<XOR<MotherTongueUpdateToOneWithWhereWithoutDiversityInput, MotherTongueUpdateWithoutDiversityInput>, MotherTongueUncheckedUpdateWithoutDiversityInput>
  }

  export type UserCreateNestedOneWithoutAdditionalDetailInput = {
    create?: XOR<UserCreateWithoutAdditionalDetailInput, UserUncheckedCreateWithoutAdditionalDetailInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdditionalDetailInput
    connect?: UserWhereUniqueInput
  }

  export type AstrologyCreateNestedOneWithoutAdditionalDetailInput = {
    create?: XOR<AstrologyCreateWithoutAdditionalDetailInput, AstrologyUncheckedCreateWithoutAdditionalDetailInput>
    connectOrCreate?: AstrologyCreateOrConnectWithoutAdditionalDetailInput
    connect?: AstrologyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdditionalDetailNestedInput = {
    create?: XOR<UserCreateWithoutAdditionalDetailInput, UserUncheckedCreateWithoutAdditionalDetailInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdditionalDetailInput
    upsert?: UserUpsertWithoutAdditionalDetailInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdditionalDetailInput, UserUpdateWithoutAdditionalDetailInput>, UserUncheckedUpdateWithoutAdditionalDetailInput>
  }

  export type AstrologyUpdateOneRequiredWithoutAdditionalDetailNestedInput = {
    create?: XOR<AstrologyCreateWithoutAdditionalDetailInput, AstrologyUncheckedCreateWithoutAdditionalDetailInput>
    connectOrCreate?: AstrologyCreateOrConnectWithoutAdditionalDetailInput
    upsert?: AstrologyUpsertWithoutAdditionalDetailInput
    connect?: AstrologyWhereUniqueInput
    update?: XOR<XOR<AstrologyUpdateToOneWithWhereWithoutAdditionalDetailInput, AstrologyUpdateWithoutAdditionalDetailInput>, AstrologyUncheckedUpdateWithoutAdditionalDetailInput>
  }

  export type UserCreateNestedOneWithoutPreferenceInput = {
    create?: XOR<UserCreateWithoutPreferenceInput, UserUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutPreferenceInput = {
    create?: XOR<CountryCreateWithoutPreferenceInput, CountryUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: CountryCreateOrConnectWithoutPreferenceInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutPreferenceInput = {
    create?: XOR<CityCreateWithoutPreferenceInput, CityUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: CityCreateOrConnectWithoutPreferenceInput
    connect?: CityWhereUniqueInput
  }

  export type MotherTongueCreateNestedOneWithoutPreferenceInput = {
    create?: XOR<MotherTongueCreateWithoutPreferenceInput, MotherTongueUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: MotherTongueCreateOrConnectWithoutPreferenceInput
    connect?: MotherTongueWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutPreferenceInput = {
    create?: XOR<CommunityCreateWithoutPreferenceInput, CommunityUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPreferenceInput
    connect?: CommunityWhereUniqueInput
  }

  export type ReligionCreateNestedOneWithoutPreferenceInput = {
    create?: XOR<ReligionCreateWithoutPreferenceInput, ReligionUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutPreferenceInput
    connect?: ReligionWhereUniqueInput
  }

  export type MaritalStatusCreateNestedOneWithoutPreferenceInput = {
    create?: XOR<MaritalStatusCreateWithoutPreferenceInput, MaritalStatusUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutPreferenceInput
    connect?: MaritalStatusWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutPreferenceInput, UserUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferenceInput
    upsert?: UserUpsertWithoutPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferenceInput, UserUpdateWithoutPreferenceInput>, UserUncheckedUpdateWithoutPreferenceInput>
  }

  export type CountryUpdateOneRequiredWithoutPreferenceNestedInput = {
    create?: XOR<CountryCreateWithoutPreferenceInput, CountryUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: CountryCreateOrConnectWithoutPreferenceInput
    upsert?: CountryUpsertWithoutPreferenceInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutPreferenceInput, CountryUpdateWithoutPreferenceInput>, CountryUncheckedUpdateWithoutPreferenceInput>
  }

  export type CityUpdateOneRequiredWithoutPreferenceNestedInput = {
    create?: XOR<CityCreateWithoutPreferenceInput, CityUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: CityCreateOrConnectWithoutPreferenceInput
    upsert?: CityUpsertWithoutPreferenceInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutPreferenceInput, CityUpdateWithoutPreferenceInput>, CityUncheckedUpdateWithoutPreferenceInput>
  }

  export type MotherTongueUpdateOneRequiredWithoutPreferenceNestedInput = {
    create?: XOR<MotherTongueCreateWithoutPreferenceInput, MotherTongueUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: MotherTongueCreateOrConnectWithoutPreferenceInput
    upsert?: MotherTongueUpsertWithoutPreferenceInput
    connect?: MotherTongueWhereUniqueInput
    update?: XOR<XOR<MotherTongueUpdateToOneWithWhereWithoutPreferenceInput, MotherTongueUpdateWithoutPreferenceInput>, MotherTongueUncheckedUpdateWithoutPreferenceInput>
  }

  export type CommunityUpdateOneRequiredWithoutPreferenceNestedInput = {
    create?: XOR<CommunityCreateWithoutPreferenceInput, CommunityUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPreferenceInput
    upsert?: CommunityUpsertWithoutPreferenceInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutPreferenceInput, CommunityUpdateWithoutPreferenceInput>, CommunityUncheckedUpdateWithoutPreferenceInput>
  }

  export type ReligionUpdateOneRequiredWithoutPreferenceNestedInput = {
    create?: XOR<ReligionCreateWithoutPreferenceInput, ReligionUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutPreferenceInput
    upsert?: ReligionUpsertWithoutPreferenceInput
    connect?: ReligionWhereUniqueInput
    update?: XOR<XOR<ReligionUpdateToOneWithWhereWithoutPreferenceInput, ReligionUpdateWithoutPreferenceInput>, ReligionUncheckedUpdateWithoutPreferenceInput>
  }

  export type MaritalStatusUpdateOneRequiredWithoutPreferenceNestedInput = {
    create?: XOR<MaritalStatusCreateWithoutPreferenceInput, MaritalStatusUncheckedCreateWithoutPreferenceInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutPreferenceInput
    upsert?: MaritalStatusUpsertWithoutPreferenceInput
    connect?: MaritalStatusWhereUniqueInput
    update?: XOR<XOR<MaritalStatusUpdateToOneWithWhereWithoutPreferenceInput, MaritalStatusUpdateWithoutPreferenceInput>, MaritalStatusUncheckedUpdateWithoutPreferenceInput>
  }

  export type UserCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput> | UserCreateWithoutMaritalStatusInput[] | UserUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMaritalStatusInput | UserCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: UserCreateManyMaritalStatusInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PreferenceCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<PreferenceCreateWithoutMaritalStatusInput, PreferenceUncheckedCreateWithoutMaritalStatusInput> | PreferenceCreateWithoutMaritalStatusInput[] | PreferenceUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutMaritalStatusInput | PreferenceCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: PreferenceCreateManyMaritalStatusInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput> | UserCreateWithoutMaritalStatusInput[] | UserUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMaritalStatusInput | UserCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: UserCreateManyMaritalStatusInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PreferenceUncheckedCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<PreferenceCreateWithoutMaritalStatusInput, PreferenceUncheckedCreateWithoutMaritalStatusInput> | PreferenceCreateWithoutMaritalStatusInput[] | PreferenceUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutMaritalStatusInput | PreferenceCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: PreferenceCreateManyMaritalStatusInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput> | UserCreateWithoutMaritalStatusInput[] | UserUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMaritalStatusInput | UserCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMaritalStatusInput | UserUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: UserCreateManyMaritalStatusInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMaritalStatusInput | UserUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMaritalStatusInput | UserUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PreferenceUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<PreferenceCreateWithoutMaritalStatusInput, PreferenceUncheckedCreateWithoutMaritalStatusInput> | PreferenceCreateWithoutMaritalStatusInput[] | PreferenceUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutMaritalStatusInput | PreferenceCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput | PreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: PreferenceCreateManyMaritalStatusInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput | PreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutMaritalStatusInput | PreferenceUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput> | UserCreateWithoutMaritalStatusInput[] | UserUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMaritalStatusInput | UserCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMaritalStatusInput | UserUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: UserCreateManyMaritalStatusInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMaritalStatusInput | UserUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMaritalStatusInput | UserUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PreferenceUncheckedUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<PreferenceCreateWithoutMaritalStatusInput, PreferenceUncheckedCreateWithoutMaritalStatusInput> | PreferenceCreateWithoutMaritalStatusInput[] | PreferenceUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutMaritalStatusInput | PreferenceCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput | PreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: PreferenceCreateManyMaritalStatusInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput | PreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutMaritalStatusInput | PreferenceUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type DiversityCreateNestedManyWithoutReligionInput = {
    create?: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput> | DiversityCreateWithoutReligionInput[] | DiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutReligionInput | DiversityCreateOrConnectWithoutReligionInput[]
    createMany?: DiversityCreateManyReligionInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceCreateNestedManyWithoutReligionInput = {
    create?: XOR<PreferenceCreateWithoutReligionInput, PreferenceUncheckedCreateWithoutReligionInput> | PreferenceCreateWithoutReligionInput[] | PreferenceUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutReligionInput | PreferenceCreateOrConnectWithoutReligionInput[]
    createMany?: PreferenceCreateManyReligionInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutReligionInput = {
    create?: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput> | DiversityCreateWithoutReligionInput[] | DiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutReligionInput | DiversityCreateOrConnectWithoutReligionInput[]
    createMany?: DiversityCreateManyReligionInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceUncheckedCreateNestedManyWithoutReligionInput = {
    create?: XOR<PreferenceCreateWithoutReligionInput, PreferenceUncheckedCreateWithoutReligionInput> | PreferenceCreateWithoutReligionInput[] | PreferenceUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutReligionInput | PreferenceCreateOrConnectWithoutReligionInput[]
    createMany?: PreferenceCreateManyReligionInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type DiversityUpdateManyWithoutReligionNestedInput = {
    create?: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput> | DiversityCreateWithoutReligionInput[] | DiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutReligionInput | DiversityCreateOrConnectWithoutReligionInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutReligionInput | DiversityUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: DiversityCreateManyReligionInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutReligionInput | DiversityUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutReligionInput | DiversityUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUpdateManyWithoutReligionNestedInput = {
    create?: XOR<PreferenceCreateWithoutReligionInput, PreferenceUncheckedCreateWithoutReligionInput> | PreferenceCreateWithoutReligionInput[] | PreferenceUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutReligionInput | PreferenceCreateOrConnectWithoutReligionInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutReligionInput | PreferenceUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: PreferenceCreateManyReligionInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutReligionInput | PreferenceUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutReligionInput | PreferenceUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutReligionNestedInput = {
    create?: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput> | DiversityCreateWithoutReligionInput[] | DiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutReligionInput | DiversityCreateOrConnectWithoutReligionInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutReligionInput | DiversityUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: DiversityCreateManyReligionInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutReligionInput | DiversityUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutReligionInput | DiversityUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUncheckedUpdateManyWithoutReligionNestedInput = {
    create?: XOR<PreferenceCreateWithoutReligionInput, PreferenceUncheckedCreateWithoutReligionInput> | PreferenceCreateWithoutReligionInput[] | PreferenceUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutReligionInput | PreferenceCreateOrConnectWithoutReligionInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutReligionInput | PreferenceUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: PreferenceCreateManyReligionInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutReligionInput | PreferenceUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutReligionInput | PreferenceUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type CityCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type DiversityCreateNestedManyWithoutCountryInput = {
    create?: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput> | DiversityCreateWithoutCountryInput[] | DiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCountryInput | DiversityCreateOrConnectWithoutCountryInput[]
    createMany?: DiversityCreateManyCountryInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceCreateNestedManyWithoutCountryInput = {
    create?: XOR<PreferenceCreateWithoutCountryInput, PreferenceUncheckedCreateWithoutCountryInput> | PreferenceCreateWithoutCountryInput[] | PreferenceUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCountryInput | PreferenceCreateOrConnectWithoutCountryInput[]
    createMany?: PreferenceCreateManyCountryInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput> | DiversityCreateWithoutCountryInput[] | DiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCountryInput | DiversityCreateOrConnectWithoutCountryInput[]
    createMany?: DiversityCreateManyCountryInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<PreferenceCreateWithoutCountryInput, PreferenceUncheckedCreateWithoutCountryInput> | PreferenceCreateWithoutCountryInput[] | PreferenceUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCountryInput | PreferenceCreateOrConnectWithoutCountryInput[]
    createMany?: PreferenceCreateManyCountryInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type CityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type DiversityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput> | DiversityCreateWithoutCountryInput[] | DiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCountryInput | DiversityCreateOrConnectWithoutCountryInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCountryInput | DiversityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: DiversityCreateManyCountryInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCountryInput | DiversityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCountryInput | DiversityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PreferenceCreateWithoutCountryInput, PreferenceUncheckedCreateWithoutCountryInput> | PreferenceCreateWithoutCountryInput[] | PreferenceUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCountryInput | PreferenceCreateOrConnectWithoutCountryInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutCountryInput | PreferenceUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PreferenceCreateManyCountryInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutCountryInput | PreferenceUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutCountryInput | PreferenceUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput> | DiversityCreateWithoutCountryInput[] | DiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCountryInput | DiversityCreateOrConnectWithoutCountryInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCountryInput | DiversityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: DiversityCreateManyCountryInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCountryInput | DiversityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCountryInput | DiversityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PreferenceCreateWithoutCountryInput, PreferenceUncheckedCreateWithoutCountryInput> | PreferenceCreateWithoutCountryInput[] | PreferenceUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCountryInput | PreferenceCreateOrConnectWithoutCountryInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutCountryInput | PreferenceUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PreferenceCreateManyCountryInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutCountryInput | PreferenceUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutCountryInput | PreferenceUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type DiversityCreateNestedManyWithoutCityInput = {
    create?: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput> | DiversityCreateWithoutCityInput[] | DiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCityInput | DiversityCreateOrConnectWithoutCityInput[]
    createMany?: DiversityCreateManyCityInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceCreateNestedManyWithoutCityInput = {
    create?: XOR<PreferenceCreateWithoutCityInput, PreferenceUncheckedCreateWithoutCityInput> | PreferenceCreateWithoutCityInput[] | PreferenceUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCityInput | PreferenceCreateOrConnectWithoutCityInput[]
    createMany?: PreferenceCreateManyCityInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput> | DiversityCreateWithoutCityInput[] | DiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCityInput | DiversityCreateOrConnectWithoutCityInput[]
    createMany?: DiversityCreateManyCityInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<PreferenceCreateWithoutCityInput, PreferenceUncheckedCreateWithoutCityInput> | PreferenceCreateWithoutCityInput[] | PreferenceUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCityInput | PreferenceCreateOrConnectWithoutCityInput[]
    createMany?: PreferenceCreateManyCityInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCitiesInput, CountryUpdateWithoutCitiesInput>, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type DiversityUpdateManyWithoutCityNestedInput = {
    create?: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput> | DiversityCreateWithoutCityInput[] | DiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCityInput | DiversityCreateOrConnectWithoutCityInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCityInput | DiversityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DiversityCreateManyCityInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCityInput | DiversityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCityInput | DiversityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUpdateManyWithoutCityNestedInput = {
    create?: XOR<PreferenceCreateWithoutCityInput, PreferenceUncheckedCreateWithoutCityInput> | PreferenceCreateWithoutCityInput[] | PreferenceUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCityInput | PreferenceCreateOrConnectWithoutCityInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutCityInput | PreferenceUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: PreferenceCreateManyCityInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutCityInput | PreferenceUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutCityInput | PreferenceUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput> | DiversityCreateWithoutCityInput[] | DiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCityInput | DiversityCreateOrConnectWithoutCityInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCityInput | DiversityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DiversityCreateManyCityInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCityInput | DiversityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCityInput | DiversityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<PreferenceCreateWithoutCityInput, PreferenceUncheckedCreateWithoutCityInput> | PreferenceCreateWithoutCityInput[] | PreferenceUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCityInput | PreferenceCreateOrConnectWithoutCityInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutCityInput | PreferenceUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: PreferenceCreateManyCityInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutCityInput | PreferenceUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutCityInput | PreferenceUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type DiversityCreateNestedManyWithoutCommunityInput = {
    create?: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput> | DiversityCreateWithoutCommunityInput[] | DiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCommunityInput | DiversityCreateOrConnectWithoutCommunityInput[]
    createMany?: DiversityCreateManyCommunityInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PreferenceCreateWithoutCommunityInput, PreferenceUncheckedCreateWithoutCommunityInput> | PreferenceCreateWithoutCommunityInput[] | PreferenceUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCommunityInput | PreferenceCreateOrConnectWithoutCommunityInput[]
    createMany?: PreferenceCreateManyCommunityInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput> | DiversityCreateWithoutCommunityInput[] | DiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCommunityInput | DiversityCreateOrConnectWithoutCommunityInput[]
    createMany?: DiversityCreateManyCommunityInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PreferenceCreateWithoutCommunityInput, PreferenceUncheckedCreateWithoutCommunityInput> | PreferenceCreateWithoutCommunityInput[] | PreferenceUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCommunityInput | PreferenceCreateOrConnectWithoutCommunityInput[]
    createMany?: PreferenceCreateManyCommunityInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type DiversityUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput> | DiversityCreateWithoutCommunityInput[] | DiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCommunityInput | DiversityCreateOrConnectWithoutCommunityInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCommunityInput | DiversityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: DiversityCreateManyCommunityInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCommunityInput | DiversityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCommunityInput | DiversityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PreferenceCreateWithoutCommunityInput, PreferenceUncheckedCreateWithoutCommunityInput> | PreferenceCreateWithoutCommunityInput[] | PreferenceUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCommunityInput | PreferenceCreateOrConnectWithoutCommunityInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutCommunityInput | PreferenceUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PreferenceCreateManyCommunityInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutCommunityInput | PreferenceUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutCommunityInput | PreferenceUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput> | DiversityCreateWithoutCommunityInput[] | DiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCommunityInput | DiversityCreateOrConnectWithoutCommunityInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCommunityInput | DiversityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: DiversityCreateManyCommunityInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCommunityInput | DiversityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCommunityInput | DiversityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PreferenceCreateWithoutCommunityInput, PreferenceUncheckedCreateWithoutCommunityInput> | PreferenceCreateWithoutCommunityInput[] | PreferenceUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutCommunityInput | PreferenceCreateOrConnectWithoutCommunityInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutCommunityInput | PreferenceUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PreferenceCreateManyCommunityInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutCommunityInput | PreferenceUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutCommunityInput | PreferenceUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type DiversityCreateNestedManyWithoutMotherTongueInput = {
    create?: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput> | DiversityCreateWithoutMotherTongueInput[] | DiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutMotherTongueInput | DiversityCreateOrConnectWithoutMotherTongueInput[]
    createMany?: DiversityCreateManyMotherTongueInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceCreateNestedManyWithoutMotherTongueInput = {
    create?: XOR<PreferenceCreateWithoutMotherTongueInput, PreferenceUncheckedCreateWithoutMotherTongueInput> | PreferenceCreateWithoutMotherTongueInput[] | PreferenceUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutMotherTongueInput | PreferenceCreateOrConnectWithoutMotherTongueInput[]
    createMany?: PreferenceCreateManyMotherTongueInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutMotherTongueInput = {
    create?: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput> | DiversityCreateWithoutMotherTongueInput[] | DiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutMotherTongueInput | DiversityCreateOrConnectWithoutMotherTongueInput[]
    createMany?: DiversityCreateManyMotherTongueInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferenceUncheckedCreateNestedManyWithoutMotherTongueInput = {
    create?: XOR<PreferenceCreateWithoutMotherTongueInput, PreferenceUncheckedCreateWithoutMotherTongueInput> | PreferenceCreateWithoutMotherTongueInput[] | PreferenceUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutMotherTongueInput | PreferenceCreateOrConnectWithoutMotherTongueInput[]
    createMany?: PreferenceCreateManyMotherTongueInputEnvelope
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
  }

  export type DiversityUpdateManyWithoutMotherTongueNestedInput = {
    create?: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput> | DiversityCreateWithoutMotherTongueInput[] | DiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutMotherTongueInput | DiversityCreateOrConnectWithoutMotherTongueInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutMotherTongueInput | DiversityUpsertWithWhereUniqueWithoutMotherTongueInput[]
    createMany?: DiversityCreateManyMotherTongueInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutMotherTongueInput | DiversityUpdateWithWhereUniqueWithoutMotherTongueInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutMotherTongueInput | DiversityUpdateManyWithWhereWithoutMotherTongueInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUpdateManyWithoutMotherTongueNestedInput = {
    create?: XOR<PreferenceCreateWithoutMotherTongueInput, PreferenceUncheckedCreateWithoutMotherTongueInput> | PreferenceCreateWithoutMotherTongueInput[] | PreferenceUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutMotherTongueInput | PreferenceCreateOrConnectWithoutMotherTongueInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutMotherTongueInput | PreferenceUpsertWithWhereUniqueWithoutMotherTongueInput[]
    createMany?: PreferenceCreateManyMotherTongueInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutMotherTongueInput | PreferenceUpdateWithWhereUniqueWithoutMotherTongueInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutMotherTongueInput | PreferenceUpdateManyWithWhereWithoutMotherTongueInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutMotherTongueNestedInput = {
    create?: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput> | DiversityCreateWithoutMotherTongueInput[] | DiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutMotherTongueInput | DiversityCreateOrConnectWithoutMotherTongueInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutMotherTongueInput | DiversityUpsertWithWhereUniqueWithoutMotherTongueInput[]
    createMany?: DiversityCreateManyMotherTongueInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutMotherTongueInput | DiversityUpdateWithWhereUniqueWithoutMotherTongueInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutMotherTongueInput | DiversityUpdateManyWithWhereWithoutMotherTongueInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferenceUncheckedUpdateManyWithoutMotherTongueNestedInput = {
    create?: XOR<PreferenceCreateWithoutMotherTongueInput, PreferenceUncheckedCreateWithoutMotherTongueInput> | PreferenceCreateWithoutMotherTongueInput[] | PreferenceUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: PreferenceCreateOrConnectWithoutMotherTongueInput | PreferenceCreateOrConnectWithoutMotherTongueInput[]
    upsert?: PreferenceUpsertWithWhereUniqueWithoutMotherTongueInput | PreferenceUpsertWithWhereUniqueWithoutMotherTongueInput[]
    createMany?: PreferenceCreateManyMotherTongueInputEnvelope
    set?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    disconnect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    delete?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    connect?: PreferenceWhereUniqueInput | PreferenceWhereUniqueInput[]
    update?: PreferenceUpdateWithWhereUniqueWithoutMotherTongueInput | PreferenceUpdateWithWhereUniqueWithoutMotherTongueInput[]
    updateMany?: PreferenceUpdateManyWithWhereWithoutMotherTongueInput | PreferenceUpdateManyWithWhereWithoutMotherTongueInput[]
    deleteMany?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
  }

  export type AdditionalDetailCreateNestedManyWithoutAstrologyInput = {
    create?: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput> | AdditionalDetailCreateWithoutAstrologyInput[] | AdditionalDetailUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutAstrologyInput | AdditionalDetailCreateOrConnectWithoutAstrologyInput[]
    createMany?: AdditionalDetailCreateManyAstrologyInputEnvelope
    connect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
  }

  export type AdditionalDetailUncheckedCreateNestedManyWithoutAstrologyInput = {
    create?: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput> | AdditionalDetailCreateWithoutAstrologyInput[] | AdditionalDetailUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutAstrologyInput | AdditionalDetailCreateOrConnectWithoutAstrologyInput[]
    createMany?: AdditionalDetailCreateManyAstrologyInputEnvelope
    connect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
  }

  export type AdditionalDetailUpdateManyWithoutAstrologyNestedInput = {
    create?: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput> | AdditionalDetailCreateWithoutAstrologyInput[] | AdditionalDetailUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutAstrologyInput | AdditionalDetailCreateOrConnectWithoutAstrologyInput[]
    upsert?: AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput | AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput[]
    createMany?: AdditionalDetailCreateManyAstrologyInputEnvelope
    set?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    disconnect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    delete?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    connect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    update?: AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput | AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput[]
    updateMany?: AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput | AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput[]
    deleteMany?: AdditionalDetailScalarWhereInput | AdditionalDetailScalarWhereInput[]
  }

  export type AdditionalDetailUncheckedUpdateManyWithoutAstrologyNestedInput = {
    create?: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput> | AdditionalDetailCreateWithoutAstrologyInput[] | AdditionalDetailUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutAstrologyInput | AdditionalDetailCreateOrConnectWithoutAstrologyInput[]
    upsert?: AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput | AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput[]
    createMany?: AdditionalDetailCreateManyAstrologyInputEnvelope
    set?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    disconnect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    delete?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    connect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    update?: AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput | AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput[]
    updateMany?: AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput | AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput[]
    deleteMany?: AdditionalDetailScalarWhereInput | AdditionalDetailScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSentConnectionsInput = {
    create?: XOR<UserCreateWithoutSentConnectionsInput, UserUncheckedCreateWithoutSentConnectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentConnectionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedConnectionsInput = {
    create?: XOR<UserCreateWithoutReceivedConnectionsInput, UserUncheckedCreateWithoutReceivedConnectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedConnectionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentConnectionsNestedInput = {
    create?: XOR<UserCreateWithoutSentConnectionsInput, UserUncheckedCreateWithoutSentConnectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentConnectionsInput
    upsert?: UserUpsertWithoutSentConnectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentConnectionsInput, UserUpdateWithoutSentConnectionsInput>, UserUncheckedUpdateWithoutSentConnectionsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedConnectionsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedConnectionsInput, UserUncheckedCreateWithoutReceivedConnectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedConnectionsInput
    upsert?: UserUpsertWithoutReceivedConnectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedConnectionsInput, UserUpdateWithoutReceivedConnectionsInput>, UserUncheckedUpdateWithoutReceivedConnectionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type MaritalStatusCreateWithoutUsersInput = {
    title: string
    Preference?: PreferenceCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    Preference?: PreferenceUncheckedCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusCreateOrConnectWithoutUsersInput = {
    where: MaritalStatusWhereUniqueInput
    create: XOR<MaritalStatusCreateWithoutUsersInput, MaritalStatusUncheckedCreateWithoutUsersInput>
  }

  export type DiversityCreateWithoutUserInput = {
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutUserInput = {
    id?: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutUserInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
  }

  export type AdditionalDetailCreateWithoutUserInput = {
    facebookProfileLink: string
    contactNumber: string
    astrology?: AstrologyCreateNestedOneWithoutAdditionalDetailInput
  }

  export type AdditionalDetailUncheckedCreateWithoutUserInput = {
    id?: number
    astrologicalId?: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailCreateOrConnectWithoutUserInput = {
    where: AdditionalDetailWhereUniqueInput
    create: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
  }

  export type PreferenceCreateWithoutUserInput = {
    country: CountryCreateNestedOneWithoutPreferenceInput
    city: CityCreateNestedOneWithoutPreferenceInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferenceInput
    community: CommunityCreateNestedOneWithoutPreferenceInput
    religion: ReligionCreateNestedOneWithoutPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutPreferenceInput
  }

  export type PreferenceUncheckedCreateWithoutUserInput = {
    id?: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type PreferenceCreateOrConnectWithoutUserInput = {
    where: PreferenceWhereUniqueInput
    create: XOR<PreferenceCreateWithoutUserInput, PreferenceUncheckedCreateWithoutUserInput>
  }

  export type ConnectionCreateWithoutSentByInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    receivedBy: UserCreateNestedOneWithoutReceivedConnectionsInput
  }

  export type ConnectionUncheckedCreateWithoutSentByInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    receivedById: number
    status: string
  }

  export type ConnectionCreateOrConnectWithoutSentByInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutSentByInput, ConnectionUncheckedCreateWithoutSentByInput>
  }

  export type ConnectionCreateManySentByInputEnvelope = {
    data: ConnectionCreateManySentByInput | ConnectionCreateManySentByInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutReceivedByInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    sentBy: UserCreateNestedOneWithoutSentConnectionsInput
  }

  export type ConnectionUncheckedCreateWithoutReceivedByInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentById: number
    status: string
  }

  export type ConnectionCreateOrConnectWithoutReceivedByInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutReceivedByInput, ConnectionUncheckedCreateWithoutReceivedByInput>
  }

  export type ConnectionCreateManyReceivedByInputEnvelope = {
    data: ConnectionCreateManyReceivedByInput | ConnectionCreateManyReceivedByInput[]
    skipDuplicates?: boolean
  }

  export type MaritalStatusUpsertWithoutUsersInput = {
    update: XOR<MaritalStatusUpdateWithoutUsersInput, MaritalStatusUncheckedUpdateWithoutUsersInput>
    create: XOR<MaritalStatusCreateWithoutUsersInput, MaritalStatusUncheckedCreateWithoutUsersInput>
    where?: MaritalStatusWhereInput
  }

  export type MaritalStatusUpdateToOneWithWhereWithoutUsersInput = {
    where?: MaritalStatusWhereInput
    data: XOR<MaritalStatusUpdateWithoutUsersInput, MaritalStatusUncheckedUpdateWithoutUsersInput>
  }

  export type MaritalStatusUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    Preference?: PreferenceUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Preference?: PreferenceUncheckedUpdateManyWithoutMaritalStatusNestedInput
  }

  export type DiversityUpsertWithoutUserInput = {
    update: XOR<DiversityUpdateWithoutUserInput, DiversityUncheckedUpdateWithoutUserInput>
    create: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    where?: DiversityWhereInput
  }

  export type DiversityUpdateToOneWithWhereWithoutUserInput = {
    where?: DiversityWhereInput
    data: XOR<DiversityUpdateWithoutUserInput, DiversityUncheckedUpdateWithoutUserInput>
  }

  export type DiversityUpdateWithoutUserInput = {
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type AdditionalDetailUpsertWithoutUserInput = {
    update: XOR<AdditionalDetailUpdateWithoutUserInput, AdditionalDetailUncheckedUpdateWithoutUserInput>
    create: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    where?: AdditionalDetailWhereInput
  }

  export type AdditionalDetailUpdateToOneWithWhereWithoutUserInput = {
    where?: AdditionalDetailWhereInput
    data: XOR<AdditionalDetailUpdateWithoutUserInput, AdditionalDetailUncheckedUpdateWithoutUserInput>
  }

  export type AdditionalDetailUpdateWithoutUserInput = {
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    astrology?: AstrologyUpdateOneRequiredWithoutAdditionalDetailNestedInput
  }

  export type AdditionalDetailUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type PreferenceUpsertWithoutUserInput = {
    update: XOR<PreferenceUpdateWithoutUserInput, PreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<PreferenceCreateWithoutUserInput, PreferenceUncheckedCreateWithoutUserInput>
    where?: PreferenceWhereInput
  }

  export type PreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: PreferenceWhereInput
    data: XOR<PreferenceUpdateWithoutUserInput, PreferenceUncheckedUpdateWithoutUserInput>
  }

  export type PreferenceUpdateWithoutUserInput = {
    country?: CountryUpdateOneRequiredWithoutPreferenceNestedInput
    city?: CityUpdateOneRequiredWithoutPreferenceNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferenceNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferenceNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutPreferenceNestedInput
  }

  export type PreferenceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type ConnectionUpsertWithWhereUniqueWithoutSentByInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutSentByInput, ConnectionUncheckedUpdateWithoutSentByInput>
    create: XOR<ConnectionCreateWithoutSentByInput, ConnectionUncheckedCreateWithoutSentByInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutSentByInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutSentByInput, ConnectionUncheckedUpdateWithoutSentByInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutSentByInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutSentByInput>
  }

  export type ConnectionScalarWhereInput = {
    AND?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    OR?: ConnectionScalarWhereInput[]
    NOT?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    id?: IntFilter<"Connection"> | number
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    updatedAt?: DateTimeFilter<"Connection"> | Date | string
    sentById?: IntFilter<"Connection"> | number
    receivedById?: IntFilter<"Connection"> | number
    status?: StringFilter<"Connection"> | string
  }

  export type ConnectionUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutReceivedByInput, ConnectionUncheckedUpdateWithoutReceivedByInput>
    create: XOR<ConnectionCreateWithoutReceivedByInput, ConnectionUncheckedCreateWithoutReceivedByInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutReceivedByInput, ConnectionUncheckedUpdateWithoutReceivedByInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutReceivedByInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutReceivedByInput>
  }

  export type UserCreateWithoutDiversityInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    Preference?: PreferenceCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionCreateNestedManyWithoutReceivedByInput
  }

  export type UserUncheckedCreateWithoutDiversityInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    Preference?: PreferenceUncheckedCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionUncheckedCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionUncheckedCreateNestedManyWithoutReceivedByInput
  }

  export type UserCreateOrConnectWithoutDiversityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDiversityInput, UserUncheckedCreateWithoutDiversityInput>
  }

  export type ReligionCreateWithoutDiversityInput = {
    title: string
    Preference?: PreferenceCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    Preference?: PreferenceUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionCreateOrConnectWithoutDiversityInput = {
    where: ReligionWhereUniqueInput
    create: XOR<ReligionCreateWithoutDiversityInput, ReligionUncheckedCreateWithoutDiversityInput>
  }

  export type CountryCreateWithoutDiversityInput = {
    title: string
    cities?: CityCreateNestedManyWithoutCountryInput
    Preference?: PreferenceCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutDiversityInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutDiversityInput, CountryUncheckedCreateWithoutDiversityInput>
  }

  export type CityCreateWithoutDiversityInput = {
    title: string
    country: CountryCreateNestedOneWithoutCitiesInput
    Preference?: PreferenceCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    countryId: number
    Preference?: PreferenceUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutDiversityInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutDiversityInput, CityUncheckedCreateWithoutDiversityInput>
  }

  export type CommunityCreateWithoutDiversityInput = {
    title: string
    Preference?: PreferenceCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    Preference?: PreferenceUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutDiversityInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutDiversityInput, CommunityUncheckedCreateWithoutDiversityInput>
  }

  export type MotherTongueCreateWithoutDiversityInput = {
    title: string
    Preference?: PreferenceCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    Preference?: PreferenceUncheckedCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueCreateOrConnectWithoutDiversityInput = {
    where: MotherTongueWhereUniqueInput
    create: XOR<MotherTongueCreateWithoutDiversityInput, MotherTongueUncheckedCreateWithoutDiversityInput>
  }

  export type UserUpsertWithoutDiversityInput = {
    update: XOR<UserUpdateWithoutDiversityInput, UserUncheckedUpdateWithoutDiversityInput>
    create: XOR<UserCreateWithoutDiversityInput, UserUncheckedCreateWithoutDiversityInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDiversityInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDiversityInput, UserUncheckedUpdateWithoutDiversityInput>
  }

  export type UserUpdateWithoutDiversityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUpdateManyWithoutReceivedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUncheckedUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUncheckedUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUncheckedUpdateManyWithoutReceivedByNestedInput
  }

  export type ReligionUpsertWithoutDiversityInput = {
    update: XOR<ReligionUpdateWithoutDiversityInput, ReligionUncheckedUpdateWithoutDiversityInput>
    create: XOR<ReligionCreateWithoutDiversityInput, ReligionUncheckedCreateWithoutDiversityInput>
    where?: ReligionWhereInput
  }

  export type ReligionUpdateToOneWithWhereWithoutDiversityInput = {
    where?: ReligionWhereInput
    data: XOR<ReligionUpdateWithoutDiversityInput, ReligionUncheckedUpdateWithoutDiversityInput>
  }

  export type ReligionUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    Preference?: PreferenceUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Preference?: PreferenceUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type CountryUpsertWithoutDiversityInput = {
    update: XOR<CountryUpdateWithoutDiversityInput, CountryUncheckedUpdateWithoutDiversityInput>
    create: XOR<CountryCreateWithoutDiversityInput, CountryUncheckedCreateWithoutDiversityInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutDiversityInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutDiversityInput, CountryUncheckedUpdateWithoutDiversityInput>
  }

  export type CountryUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    Preference?: PreferenceUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CityUpsertWithoutDiversityInput = {
    update: XOR<CityUpdateWithoutDiversityInput, CityUncheckedUpdateWithoutDiversityInput>
    create: XOR<CityCreateWithoutDiversityInput, CityUncheckedCreateWithoutDiversityInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutDiversityInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutDiversityInput, CityUncheckedUpdateWithoutDiversityInput>
  }

  export type CityUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    Preference?: PreferenceUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    Preference?: PreferenceUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CommunityUpsertWithoutDiversityInput = {
    update: XOR<CommunityUpdateWithoutDiversityInput, CommunityUncheckedUpdateWithoutDiversityInput>
    create: XOR<CommunityCreateWithoutDiversityInput, CommunityUncheckedCreateWithoutDiversityInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutDiversityInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutDiversityInput, CommunityUncheckedUpdateWithoutDiversityInput>
  }

  export type CommunityUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    Preference?: PreferenceUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Preference?: PreferenceUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type MotherTongueUpsertWithoutDiversityInput = {
    update: XOR<MotherTongueUpdateWithoutDiversityInput, MotherTongueUncheckedUpdateWithoutDiversityInput>
    create: XOR<MotherTongueCreateWithoutDiversityInput, MotherTongueUncheckedCreateWithoutDiversityInput>
    where?: MotherTongueWhereInput
  }

  export type MotherTongueUpdateToOneWithWhereWithoutDiversityInput = {
    where?: MotherTongueWhereInput
    data: XOR<MotherTongueUpdateWithoutDiversityInput, MotherTongueUncheckedUpdateWithoutDiversityInput>
  }

  export type MotherTongueUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    Preference?: PreferenceUpdateManyWithoutMotherTongueNestedInput
  }

  export type MotherTongueUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Preference?: PreferenceUncheckedUpdateManyWithoutMotherTongueNestedInput
  }

  export type UserCreateWithoutAdditionalDetailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    diversity?: DiversityCreateNestedOneWithoutUserInput
    Preference?: PreferenceCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionCreateNestedManyWithoutReceivedByInput
  }

  export type UserUncheckedCreateWithoutAdditionalDetailInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    Preference?: PreferenceUncheckedCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionUncheckedCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionUncheckedCreateNestedManyWithoutReceivedByInput
  }

  export type UserCreateOrConnectWithoutAdditionalDetailInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdditionalDetailInput, UserUncheckedCreateWithoutAdditionalDetailInput>
  }

  export type AstrologyCreateWithoutAdditionalDetailInput = {
    title: string
  }

  export type AstrologyUncheckedCreateWithoutAdditionalDetailInput = {
    id?: number
    title: string
  }

  export type AstrologyCreateOrConnectWithoutAdditionalDetailInput = {
    where: AstrologyWhereUniqueInput
    create: XOR<AstrologyCreateWithoutAdditionalDetailInput, AstrologyUncheckedCreateWithoutAdditionalDetailInput>
  }

  export type UserUpsertWithoutAdditionalDetailInput = {
    update: XOR<UserUpdateWithoutAdditionalDetailInput, UserUncheckedUpdateWithoutAdditionalDetailInput>
    create: XOR<UserCreateWithoutAdditionalDetailInput, UserUncheckedCreateWithoutAdditionalDetailInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdditionalDetailInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdditionalDetailInput, UserUncheckedUpdateWithoutAdditionalDetailInput>
  }

  export type UserUpdateWithoutAdditionalDetailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUpdateManyWithoutReceivedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAdditionalDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUncheckedUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUncheckedUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUncheckedUpdateManyWithoutReceivedByNestedInput
  }

  export type AstrologyUpsertWithoutAdditionalDetailInput = {
    update: XOR<AstrologyUpdateWithoutAdditionalDetailInput, AstrologyUncheckedUpdateWithoutAdditionalDetailInput>
    create: XOR<AstrologyCreateWithoutAdditionalDetailInput, AstrologyUncheckedCreateWithoutAdditionalDetailInput>
    where?: AstrologyWhereInput
  }

  export type AstrologyUpdateToOneWithWhereWithoutAdditionalDetailInput = {
    where?: AstrologyWhereInput
    data: XOR<AstrologyUpdateWithoutAdditionalDetailInput, AstrologyUncheckedUpdateWithoutAdditionalDetailInput>
  }

  export type AstrologyUpdateWithoutAdditionalDetailInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AstrologyUncheckedUpdateWithoutAdditionalDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutPreferenceInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    diversity?: DiversityCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionCreateNestedManyWithoutReceivedByInput
  }

  export type UserUncheckedCreateWithoutPreferenceInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionUncheckedCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionUncheckedCreateNestedManyWithoutReceivedByInput
  }

  export type UserCreateOrConnectWithoutPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferenceInput, UserUncheckedCreateWithoutPreferenceInput>
  }

  export type CountryCreateWithoutPreferenceInput = {
    title: string
    cities?: CityCreateNestedManyWithoutCountryInput
    Diversity?: DiversityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutPreferenceInput = {
    id?: number
    title: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutPreferenceInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutPreferenceInput, CountryUncheckedCreateWithoutPreferenceInput>
  }

  export type CityCreateWithoutPreferenceInput = {
    title: string
    country: CountryCreateNestedOneWithoutCitiesInput
    Diversity?: DiversityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutPreferenceInput = {
    id?: number
    title: string
    countryId: number
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutPreferenceInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutPreferenceInput, CityUncheckedCreateWithoutPreferenceInput>
  }

  export type MotherTongueCreateWithoutPreferenceInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueUncheckedCreateWithoutPreferenceInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueCreateOrConnectWithoutPreferenceInput = {
    where: MotherTongueWhereUniqueInput
    create: XOR<MotherTongueCreateWithoutPreferenceInput, MotherTongueUncheckedCreateWithoutPreferenceInput>
  }

  export type CommunityCreateWithoutPreferenceInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutPreferenceInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutPreferenceInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutPreferenceInput, CommunityUncheckedCreateWithoutPreferenceInput>
  }

  export type ReligionCreateWithoutPreferenceInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateWithoutPreferenceInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionCreateOrConnectWithoutPreferenceInput = {
    where: ReligionWhereUniqueInput
    create: XOR<ReligionCreateWithoutPreferenceInput, ReligionUncheckedCreateWithoutPreferenceInput>
  }

  export type MaritalStatusCreateWithoutPreferenceInput = {
    title: string
    users?: UserCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUncheckedCreateWithoutPreferenceInput = {
    id?: number
    title: string
    users?: UserUncheckedCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusCreateOrConnectWithoutPreferenceInput = {
    where: MaritalStatusWhereUniqueInput
    create: XOR<MaritalStatusCreateWithoutPreferenceInput, MaritalStatusUncheckedCreateWithoutPreferenceInput>
  }

  export type UserUpsertWithoutPreferenceInput = {
    update: XOR<UserUpdateWithoutPreferenceInput, UserUncheckedUpdateWithoutPreferenceInput>
    create: XOR<UserCreateWithoutPreferenceInput, UserUncheckedCreateWithoutPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferenceInput, UserUncheckedUpdateWithoutPreferenceInput>
  }

  export type UserUpdateWithoutPreferenceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUpdateManyWithoutReceivedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUncheckedUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUncheckedUpdateManyWithoutReceivedByNestedInput
  }

  export type CountryUpsertWithoutPreferenceInput = {
    update: XOR<CountryUpdateWithoutPreferenceInput, CountryUncheckedUpdateWithoutPreferenceInput>
    create: XOR<CountryCreateWithoutPreferenceInput, CountryUncheckedCreateWithoutPreferenceInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutPreferenceInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutPreferenceInput, CountryUncheckedUpdateWithoutPreferenceInput>
  }

  export type CountryUpdateWithoutPreferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    Diversity?: DiversityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    Diversity?: DiversityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CityUpsertWithoutPreferenceInput = {
    update: XOR<CityUpdateWithoutPreferenceInput, CityUncheckedUpdateWithoutPreferenceInput>
    create: XOR<CityCreateWithoutPreferenceInput, CityUncheckedCreateWithoutPreferenceInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutPreferenceInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutPreferenceInput, CityUncheckedUpdateWithoutPreferenceInput>
  }

  export type CityUpdateWithoutPreferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    Diversity?: DiversityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    Diversity?: DiversityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type MotherTongueUpsertWithoutPreferenceInput = {
    update: XOR<MotherTongueUpdateWithoutPreferenceInput, MotherTongueUncheckedUpdateWithoutPreferenceInput>
    create: XOR<MotherTongueCreateWithoutPreferenceInput, MotherTongueUncheckedCreateWithoutPreferenceInput>
    where?: MotherTongueWhereInput
  }

  export type MotherTongueUpdateToOneWithWhereWithoutPreferenceInput = {
    where?: MotherTongueWhereInput
    data: XOR<MotherTongueUpdateWithoutPreferenceInput, MotherTongueUncheckedUpdateWithoutPreferenceInput>
  }

  export type MotherTongueUpdateWithoutPreferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutMotherTongueNestedInput
  }

  export type MotherTongueUncheckedUpdateWithoutPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutMotherTongueNestedInput
  }

  export type CommunityUpsertWithoutPreferenceInput = {
    update: XOR<CommunityUpdateWithoutPreferenceInput, CommunityUncheckedUpdateWithoutPreferenceInput>
    create: XOR<CommunityCreateWithoutPreferenceInput, CommunityUncheckedCreateWithoutPreferenceInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutPreferenceInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutPreferenceInput, CommunityUncheckedUpdateWithoutPreferenceInput>
  }

  export type CommunityUpdateWithoutPreferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type ReligionUpsertWithoutPreferenceInput = {
    update: XOR<ReligionUpdateWithoutPreferenceInput, ReligionUncheckedUpdateWithoutPreferenceInput>
    create: XOR<ReligionCreateWithoutPreferenceInput, ReligionUncheckedCreateWithoutPreferenceInput>
    where?: ReligionWhereInput
  }

  export type ReligionUpdateToOneWithWhereWithoutPreferenceInput = {
    where?: ReligionWhereInput
    data: XOR<ReligionUpdateWithoutPreferenceInput, ReligionUncheckedUpdateWithoutPreferenceInput>
  }

  export type ReligionUpdateWithoutPreferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateWithoutPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type MaritalStatusUpsertWithoutPreferenceInput = {
    update: XOR<MaritalStatusUpdateWithoutPreferenceInput, MaritalStatusUncheckedUpdateWithoutPreferenceInput>
    create: XOR<MaritalStatusCreateWithoutPreferenceInput, MaritalStatusUncheckedCreateWithoutPreferenceInput>
    where?: MaritalStatusWhereInput
  }

  export type MaritalStatusUpdateToOneWithWhereWithoutPreferenceInput = {
    where?: MaritalStatusWhereInput
    data: XOR<MaritalStatusUpdateWithoutPreferenceInput, MaritalStatusUncheckedUpdateWithoutPreferenceInput>
  }

  export type MaritalStatusUpdateWithoutPreferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusUncheckedUpdateWithoutPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMaritalStatusNestedInput
  }

  export type UserCreateWithoutMaritalStatusInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    diversity?: DiversityCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    Preference?: PreferenceCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionCreateNestedManyWithoutReceivedByInput
  }

  export type UserUncheckedCreateWithoutMaritalStatusInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    Preference?: PreferenceUncheckedCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionUncheckedCreateNestedManyWithoutSentByInput
    receivedConnections?: ConnectionUncheckedCreateNestedManyWithoutReceivedByInput
  }

  export type UserCreateOrConnectWithoutMaritalStatusInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput>
  }

  export type UserCreateManyMaritalStatusInputEnvelope = {
    data: UserCreateManyMaritalStatusInput | UserCreateManyMaritalStatusInput[]
    skipDuplicates?: boolean
  }

  export type PreferenceCreateWithoutMaritalStatusInput = {
    user: UserCreateNestedOneWithoutPreferenceInput
    country: CountryCreateNestedOneWithoutPreferenceInput
    city: CityCreateNestedOneWithoutPreferenceInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferenceInput
    community: CommunityCreateNestedOneWithoutPreferenceInput
    religion: ReligionCreateNestedOneWithoutPreferenceInput
  }

  export type PreferenceUncheckedCreateWithoutMaritalStatusInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type PreferenceCreateOrConnectWithoutMaritalStatusInput = {
    where: PreferenceWhereUniqueInput
    create: XOR<PreferenceCreateWithoutMaritalStatusInput, PreferenceUncheckedCreateWithoutMaritalStatusInput>
  }

  export type PreferenceCreateManyMaritalStatusInputEnvelope = {
    data: PreferenceCreateManyMaritalStatusInput | PreferenceCreateManyMaritalStatusInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutMaritalStatusInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutMaritalStatusInput, UserUncheckedUpdateWithoutMaritalStatusInput>
    create: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput>
  }

  export type UserUpdateWithWhereUniqueWithoutMaritalStatusInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutMaritalStatusInput, UserUncheckedUpdateWithoutMaritalStatusInput>
  }

  export type UserUpdateManyWithWhereWithoutMaritalStatusInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutMaritalStatusInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeFilter<"User"> | Date | string
    gender?: StringFilter<"User"> | string
    bio?: StringFilter<"User"> | string
    image?: StringFilter<"User"> | string
    maritalStatusId?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
  }

  export type PreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput = {
    where: PreferenceWhereUniqueInput
    update: XOR<PreferenceUpdateWithoutMaritalStatusInput, PreferenceUncheckedUpdateWithoutMaritalStatusInput>
    create: XOR<PreferenceCreateWithoutMaritalStatusInput, PreferenceUncheckedCreateWithoutMaritalStatusInput>
  }

  export type PreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput = {
    where: PreferenceWhereUniqueInput
    data: XOR<PreferenceUpdateWithoutMaritalStatusInput, PreferenceUncheckedUpdateWithoutMaritalStatusInput>
  }

  export type PreferenceUpdateManyWithWhereWithoutMaritalStatusInput = {
    where: PreferenceScalarWhereInput
    data: XOR<PreferenceUpdateManyMutationInput, PreferenceUncheckedUpdateManyWithoutMaritalStatusInput>
  }

  export type PreferenceScalarWhereInput = {
    AND?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
    OR?: PreferenceScalarWhereInput[]
    NOT?: PreferenceScalarWhereInput | PreferenceScalarWhereInput[]
    id?: IntFilter<"Preference"> | number
    userId?: IntFilter<"Preference"> | number
    countryId?: IntFilter<"Preference"> | number
    cityId?: IntFilter<"Preference"> | number
    motherTongueId?: IntFilter<"Preference"> | number
    communityId?: IntFilter<"Preference"> | number
    religionId?: IntFilter<"Preference"> | number
    maritalStatusId?: IntFilter<"Preference"> | number
  }

  export type DiversityCreateWithoutReligionInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutReligionInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutReligionInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput>
  }

  export type DiversityCreateManyReligionInputEnvelope = {
    data: DiversityCreateManyReligionInput | DiversityCreateManyReligionInput[]
    skipDuplicates?: boolean
  }

  export type PreferenceCreateWithoutReligionInput = {
    user: UserCreateNestedOneWithoutPreferenceInput
    country: CountryCreateNestedOneWithoutPreferenceInput
    city: CityCreateNestedOneWithoutPreferenceInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferenceInput
    community: CommunityCreateNestedOneWithoutPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutPreferenceInput
  }

  export type PreferenceUncheckedCreateWithoutReligionInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    maritalStatusId: number
  }

  export type PreferenceCreateOrConnectWithoutReligionInput = {
    where: PreferenceWhereUniqueInput
    create: XOR<PreferenceCreateWithoutReligionInput, PreferenceUncheckedCreateWithoutReligionInput>
  }

  export type PreferenceCreateManyReligionInputEnvelope = {
    data: PreferenceCreateManyReligionInput | PreferenceCreateManyReligionInput[]
    skipDuplicates?: boolean
  }

  export type DiversityUpsertWithWhereUniqueWithoutReligionInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutReligionInput, DiversityUncheckedUpdateWithoutReligionInput>
    create: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutReligionInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutReligionInput, DiversityUncheckedUpdateWithoutReligionInput>
  }

  export type DiversityUpdateManyWithWhereWithoutReligionInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutReligionInput>
  }

  export type DiversityScalarWhereInput = {
    AND?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
    OR?: DiversityScalarWhereInput[]
    NOT?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
    id?: IntFilter<"Diversity"> | number
    userId?: IntFilter<"Diversity"> | number
    religionId?: IntFilter<"Diversity"> | number
    countryId?: IntFilter<"Diversity"> | number
    cityId?: IntFilter<"Diversity"> | number
    communityId?: IntFilter<"Diversity"> | number
    motherTongueId?: IntFilter<"Diversity"> | number
  }

  export type PreferenceUpsertWithWhereUniqueWithoutReligionInput = {
    where: PreferenceWhereUniqueInput
    update: XOR<PreferenceUpdateWithoutReligionInput, PreferenceUncheckedUpdateWithoutReligionInput>
    create: XOR<PreferenceCreateWithoutReligionInput, PreferenceUncheckedCreateWithoutReligionInput>
  }

  export type PreferenceUpdateWithWhereUniqueWithoutReligionInput = {
    where: PreferenceWhereUniqueInput
    data: XOR<PreferenceUpdateWithoutReligionInput, PreferenceUncheckedUpdateWithoutReligionInput>
  }

  export type PreferenceUpdateManyWithWhereWithoutReligionInput = {
    where: PreferenceScalarWhereInput
    data: XOR<PreferenceUpdateManyMutationInput, PreferenceUncheckedUpdateManyWithoutReligionInput>
  }

  export type CityCreateWithoutCountryInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutCityInput
    Preference?: PreferenceCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCityInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityCreateManyCountryInputEnvelope = {
    data: CityCreateManyCountryInput | CityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type DiversityCreateWithoutCountryInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutCountryInput = {
    id?: number
    userId: number
    religionId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutCountryInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput>
  }

  export type DiversityCreateManyCountryInputEnvelope = {
    data: DiversityCreateManyCountryInput | DiversityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type PreferenceCreateWithoutCountryInput = {
    user: UserCreateNestedOneWithoutPreferenceInput
    city: CityCreateNestedOneWithoutPreferenceInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferenceInput
    community: CommunityCreateNestedOneWithoutPreferenceInput
    religion: ReligionCreateNestedOneWithoutPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutPreferenceInput
  }

  export type PreferenceUncheckedCreateWithoutCountryInput = {
    id?: number
    userId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type PreferenceCreateOrConnectWithoutCountryInput = {
    where: PreferenceWhereUniqueInput
    create: XOR<PreferenceCreateWithoutCountryInput, PreferenceUncheckedCreateWithoutCountryInput>
  }

  export type PreferenceCreateManyCountryInputEnvelope = {
    data: PreferenceCreateManyCountryInput | PreferenceCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: IntFilter<"City"> | number
    title?: StringFilter<"City"> | string
    countryId?: IntFilter<"City"> | number
  }

  export type DiversityUpsertWithWhereUniqueWithoutCountryInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutCountryInput, DiversityUncheckedUpdateWithoutCountryInput>
    create: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutCountryInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutCountryInput, DiversityUncheckedUpdateWithoutCountryInput>
  }

  export type DiversityUpdateManyWithWhereWithoutCountryInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutCountryInput>
  }

  export type PreferenceUpsertWithWhereUniqueWithoutCountryInput = {
    where: PreferenceWhereUniqueInput
    update: XOR<PreferenceUpdateWithoutCountryInput, PreferenceUncheckedUpdateWithoutCountryInput>
    create: XOR<PreferenceCreateWithoutCountryInput, PreferenceUncheckedCreateWithoutCountryInput>
  }

  export type PreferenceUpdateWithWhereUniqueWithoutCountryInput = {
    where: PreferenceWhereUniqueInput
    data: XOR<PreferenceUpdateWithoutCountryInput, PreferenceUncheckedUpdateWithoutCountryInput>
  }

  export type PreferenceUpdateManyWithWhereWithoutCountryInput = {
    where: PreferenceScalarWhereInput
    data: XOR<PreferenceUpdateManyMutationInput, PreferenceUncheckedUpdateManyWithoutCountryInput>
  }

  export type CountryCreateWithoutCitiesInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutCountryInput
    Preference?: PreferenceCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCountryInput
    Preference?: PreferenceUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type DiversityCreateWithoutCityInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutCityInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutCityInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput>
  }

  export type DiversityCreateManyCityInputEnvelope = {
    data: DiversityCreateManyCityInput | DiversityCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type PreferenceCreateWithoutCityInput = {
    user: UserCreateNestedOneWithoutPreferenceInput
    country: CountryCreateNestedOneWithoutPreferenceInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferenceInput
    community: CommunityCreateNestedOneWithoutPreferenceInput
    religion: ReligionCreateNestedOneWithoutPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutPreferenceInput
  }

  export type PreferenceUncheckedCreateWithoutCityInput = {
    id?: number
    userId: number
    countryId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type PreferenceCreateOrConnectWithoutCityInput = {
    where: PreferenceWhereUniqueInput
    create: XOR<PreferenceCreateWithoutCityInput, PreferenceUncheckedCreateWithoutCityInput>
  }

  export type PreferenceCreateManyCityInputEnvelope = {
    data: PreferenceCreateManyCityInput | PreferenceCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutCountryNestedInput
    Preference?: PreferenceUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutCountryNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type DiversityUpsertWithWhereUniqueWithoutCityInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutCityInput, DiversityUncheckedUpdateWithoutCityInput>
    create: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutCityInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutCityInput, DiversityUncheckedUpdateWithoutCityInput>
  }

  export type DiversityUpdateManyWithWhereWithoutCityInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutCityInput>
  }

  export type PreferenceUpsertWithWhereUniqueWithoutCityInput = {
    where: PreferenceWhereUniqueInput
    update: XOR<PreferenceUpdateWithoutCityInput, PreferenceUncheckedUpdateWithoutCityInput>
    create: XOR<PreferenceCreateWithoutCityInput, PreferenceUncheckedCreateWithoutCityInput>
  }

  export type PreferenceUpdateWithWhereUniqueWithoutCityInput = {
    where: PreferenceWhereUniqueInput
    data: XOR<PreferenceUpdateWithoutCityInput, PreferenceUncheckedUpdateWithoutCityInput>
  }

  export type PreferenceUpdateManyWithWhereWithoutCityInput = {
    where: PreferenceScalarWhereInput
    data: XOR<PreferenceUpdateManyMutationInput, PreferenceUncheckedUpdateManyWithoutCityInput>
  }

  export type DiversityCreateWithoutCommunityInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutCommunityInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutCommunityInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput>
  }

  export type DiversityCreateManyCommunityInputEnvelope = {
    data: DiversityCreateManyCommunityInput | DiversityCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type PreferenceCreateWithoutCommunityInput = {
    user: UserCreateNestedOneWithoutPreferenceInput
    country: CountryCreateNestedOneWithoutPreferenceInput
    city: CityCreateNestedOneWithoutPreferenceInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferenceInput
    religion: ReligionCreateNestedOneWithoutPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutPreferenceInput
  }

  export type PreferenceUncheckedCreateWithoutCommunityInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    religionId: number
    maritalStatusId: number
  }

  export type PreferenceCreateOrConnectWithoutCommunityInput = {
    where: PreferenceWhereUniqueInput
    create: XOR<PreferenceCreateWithoutCommunityInput, PreferenceUncheckedCreateWithoutCommunityInput>
  }

  export type PreferenceCreateManyCommunityInputEnvelope = {
    data: PreferenceCreateManyCommunityInput | PreferenceCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type DiversityUpsertWithWhereUniqueWithoutCommunityInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutCommunityInput, DiversityUncheckedUpdateWithoutCommunityInput>
    create: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutCommunityInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutCommunityInput, DiversityUncheckedUpdateWithoutCommunityInput>
  }

  export type DiversityUpdateManyWithWhereWithoutCommunityInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutCommunityInput>
  }

  export type PreferenceUpsertWithWhereUniqueWithoutCommunityInput = {
    where: PreferenceWhereUniqueInput
    update: XOR<PreferenceUpdateWithoutCommunityInput, PreferenceUncheckedUpdateWithoutCommunityInput>
    create: XOR<PreferenceCreateWithoutCommunityInput, PreferenceUncheckedCreateWithoutCommunityInput>
  }

  export type PreferenceUpdateWithWhereUniqueWithoutCommunityInput = {
    where: PreferenceWhereUniqueInput
    data: XOR<PreferenceUpdateWithoutCommunityInput, PreferenceUncheckedUpdateWithoutCommunityInput>
  }

  export type PreferenceUpdateManyWithWhereWithoutCommunityInput = {
    where: PreferenceScalarWhereInput
    data: XOR<PreferenceUpdateManyMutationInput, PreferenceUncheckedUpdateManyWithoutCommunityInput>
  }

  export type DiversityCreateWithoutMotherTongueInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutMotherTongueInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
  }

  export type DiversityCreateOrConnectWithoutMotherTongueInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput>
  }

  export type DiversityCreateManyMotherTongueInputEnvelope = {
    data: DiversityCreateManyMotherTongueInput | DiversityCreateManyMotherTongueInput[]
    skipDuplicates?: boolean
  }

  export type PreferenceCreateWithoutMotherTongueInput = {
    user: UserCreateNestedOneWithoutPreferenceInput
    country: CountryCreateNestedOneWithoutPreferenceInput
    city: CityCreateNestedOneWithoutPreferenceInput
    community: CommunityCreateNestedOneWithoutPreferenceInput
    religion: ReligionCreateNestedOneWithoutPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutPreferenceInput
  }

  export type PreferenceUncheckedCreateWithoutMotherTongueInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type PreferenceCreateOrConnectWithoutMotherTongueInput = {
    where: PreferenceWhereUniqueInput
    create: XOR<PreferenceCreateWithoutMotherTongueInput, PreferenceUncheckedCreateWithoutMotherTongueInput>
  }

  export type PreferenceCreateManyMotherTongueInputEnvelope = {
    data: PreferenceCreateManyMotherTongueInput | PreferenceCreateManyMotherTongueInput[]
    skipDuplicates?: boolean
  }

  export type DiversityUpsertWithWhereUniqueWithoutMotherTongueInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutMotherTongueInput, DiversityUncheckedUpdateWithoutMotherTongueInput>
    create: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutMotherTongueInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutMotherTongueInput, DiversityUncheckedUpdateWithoutMotherTongueInput>
  }

  export type DiversityUpdateManyWithWhereWithoutMotherTongueInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutMotherTongueInput>
  }

  export type PreferenceUpsertWithWhereUniqueWithoutMotherTongueInput = {
    where: PreferenceWhereUniqueInput
    update: XOR<PreferenceUpdateWithoutMotherTongueInput, PreferenceUncheckedUpdateWithoutMotherTongueInput>
    create: XOR<PreferenceCreateWithoutMotherTongueInput, PreferenceUncheckedCreateWithoutMotherTongueInput>
  }

  export type PreferenceUpdateWithWhereUniqueWithoutMotherTongueInput = {
    where: PreferenceWhereUniqueInput
    data: XOR<PreferenceUpdateWithoutMotherTongueInput, PreferenceUncheckedUpdateWithoutMotherTongueInput>
  }

  export type PreferenceUpdateManyWithWhereWithoutMotherTongueInput = {
    where: PreferenceScalarWhereInput
    data: XOR<PreferenceUpdateManyMutationInput, PreferenceUncheckedUpdateManyWithoutMotherTongueInput>
  }

  export type AdditionalDetailCreateWithoutAstrologyInput = {
    facebookProfileLink: string
    contactNumber: string
    user: UserCreateNestedOneWithoutAdditionalDetailInput
  }

  export type AdditionalDetailUncheckedCreateWithoutAstrologyInput = {
    id?: number
    userId: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailCreateOrConnectWithoutAstrologyInput = {
    where: AdditionalDetailWhereUniqueInput
    create: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput>
  }

  export type AdditionalDetailCreateManyAstrologyInputEnvelope = {
    data: AdditionalDetailCreateManyAstrologyInput | AdditionalDetailCreateManyAstrologyInput[]
    skipDuplicates?: boolean
  }

  export type AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput = {
    where: AdditionalDetailWhereUniqueInput
    update: XOR<AdditionalDetailUpdateWithoutAstrologyInput, AdditionalDetailUncheckedUpdateWithoutAstrologyInput>
    create: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput>
  }

  export type AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput = {
    where: AdditionalDetailWhereUniqueInput
    data: XOR<AdditionalDetailUpdateWithoutAstrologyInput, AdditionalDetailUncheckedUpdateWithoutAstrologyInput>
  }

  export type AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput = {
    where: AdditionalDetailScalarWhereInput
    data: XOR<AdditionalDetailUpdateManyMutationInput, AdditionalDetailUncheckedUpdateManyWithoutAstrologyInput>
  }

  export type AdditionalDetailScalarWhereInput = {
    AND?: AdditionalDetailScalarWhereInput | AdditionalDetailScalarWhereInput[]
    OR?: AdditionalDetailScalarWhereInput[]
    NOT?: AdditionalDetailScalarWhereInput | AdditionalDetailScalarWhereInput[]
    id?: IntFilter<"AdditionalDetail"> | number
    userId?: IntFilter<"AdditionalDetail"> | number
    astrologicalId?: IntFilter<"AdditionalDetail"> | number
    facebookProfileLink?: StringFilter<"AdditionalDetail"> | string
    contactNumber?: StringFilter<"AdditionalDetail"> | string
  }

  export type UserCreateWithoutSentConnectionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    diversity?: DiversityCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    Preference?: PreferenceCreateNestedOneWithoutUserInput
    receivedConnections?: ConnectionCreateNestedManyWithoutReceivedByInput
  }

  export type UserUncheckedCreateWithoutSentConnectionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    Preference?: PreferenceUncheckedCreateNestedOneWithoutUserInput
    receivedConnections?: ConnectionUncheckedCreateNestedManyWithoutReceivedByInput
  }

  export type UserCreateOrConnectWithoutSentConnectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentConnectionsInput, UserUncheckedCreateWithoutSentConnectionsInput>
  }

  export type UserCreateWithoutReceivedConnectionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    diversity?: DiversityCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    Preference?: PreferenceCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionCreateNestedManyWithoutSentByInput
  }

  export type UserUncheckedCreateWithoutReceivedConnectionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    Preference?: PreferenceUncheckedCreateNestedOneWithoutUserInput
    sentConnections?: ConnectionUncheckedCreateNestedManyWithoutSentByInput
  }

  export type UserCreateOrConnectWithoutReceivedConnectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedConnectionsInput, UserUncheckedCreateWithoutReceivedConnectionsInput>
  }

  export type UserUpsertWithoutSentConnectionsInput = {
    update: XOR<UserUpdateWithoutSentConnectionsInput, UserUncheckedUpdateWithoutSentConnectionsInput>
    create: XOR<UserCreateWithoutSentConnectionsInput, UserUncheckedCreateWithoutSentConnectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentConnectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentConnectionsInput, UserUncheckedUpdateWithoutSentConnectionsInput>
  }

  export type UserUpdateWithoutSentConnectionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUpdateOneWithoutUserNestedInput
    receivedConnections?: ConnectionUpdateManyWithoutReceivedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentConnectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUncheckedUpdateOneWithoutUserNestedInput
    receivedConnections?: ConnectionUncheckedUpdateManyWithoutReceivedByNestedInput
  }

  export type UserUpsertWithoutReceivedConnectionsInput = {
    update: XOR<UserUpdateWithoutReceivedConnectionsInput, UserUncheckedUpdateWithoutReceivedConnectionsInput>
    create: XOR<UserCreateWithoutReceivedConnectionsInput, UserUncheckedCreateWithoutReceivedConnectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedConnectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedConnectionsInput, UserUncheckedUpdateWithoutReceivedConnectionsInput>
  }

  export type UserUpdateWithoutReceivedConnectionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUpdateManyWithoutSentByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedConnectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUncheckedUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUncheckedUpdateManyWithoutSentByNestedInput
  }

  export type ConnectionCreateManySentByInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    receivedById: number
    status: string
  }

  export type ConnectionCreateManyReceivedByInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sentById: number
    status: string
  }

  export type ConnectionUpdateWithoutSentByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    receivedBy?: UserUpdateOneRequiredWithoutReceivedConnectionsNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutSentByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedById?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionUncheckedUpdateManyWithoutSentByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedById?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionUpdateWithoutReceivedByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    sentBy?: UserUpdateOneRequiredWithoutSentConnectionsNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutReceivedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionUncheckedUpdateManyWithoutReceivedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyMaritalStatusInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
  }

  export type PreferenceCreateManyMaritalStatusInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type UserUpdateWithoutMaritalStatusInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUpdateManyWithoutReceivedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    Preference?: PreferenceUncheckedUpdateOneWithoutUserNestedInput
    sentConnections?: ConnectionUncheckedUpdateManyWithoutSentByNestedInput
    receivedConnections?: ConnectionUncheckedUpdateManyWithoutReceivedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type PreferenceUpdateWithoutMaritalStatusInput = {
    user?: UserUpdateOneRequiredWithoutPreferenceNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferenceNestedInput
    city?: CityUpdateOneRequiredWithoutPreferenceNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferenceNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferenceNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferenceNestedInput
  }

  export type PreferenceUncheckedUpdateWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUncheckedUpdateManyWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyReligionInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type PreferenceCreateManyReligionInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    maritalStatusId: number
  }

  export type DiversityUpdateWithoutReligionInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUpdateWithoutReligionInput = {
    user?: UserUpdateOneRequiredWithoutPreferenceNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferenceNestedInput
    city?: CityUpdateOneRequiredWithoutPreferenceNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferenceNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutPreferenceNestedInput
  }

  export type PreferenceUncheckedUpdateWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUncheckedUpdateManyWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type CityCreateManyCountryInput = {
    id?: number
    title: string
  }

  export type DiversityCreateManyCountryInput = {
    id?: number
    userId: number
    religionId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type PreferenceCreateManyCountryInput = {
    id?: number
    userId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type CityUpdateWithoutCountryInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutCityNestedInput
    Preference?: PreferenceUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutCityNestedInput
    Preference?: PreferenceUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type DiversityUpdateWithoutCountryInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUpdateWithoutCountryInput = {
    user?: UserUpdateOneRequiredWithoutPreferenceNestedInput
    city?: CityUpdateOneRequiredWithoutPreferenceNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferenceNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferenceNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutPreferenceNestedInput
  }

  export type PreferenceUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyCityInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    communityId: number
    motherTongueId: number
  }

  export type PreferenceCreateManyCityInput = {
    id?: number
    userId: number
    countryId: number
    motherTongueId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type DiversityUpdateWithoutCityInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUpdateWithoutCityInput = {
    user?: UserUpdateOneRequiredWithoutPreferenceNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferenceNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferenceNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferenceNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutPreferenceNestedInput
  }

  export type PreferenceUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyCommunityInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    motherTongueId: number
  }

  export type PreferenceCreateManyCommunityInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    motherTongueId: number
    religionId: number
    maritalStatusId: number
  }

  export type DiversityUpdateWithoutCommunityInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUpdateWithoutCommunityInput = {
    user?: UserUpdateOneRequiredWithoutPreferenceNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferenceNestedInput
    city?: CityUpdateOneRequiredWithoutPreferenceNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferenceNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutPreferenceNestedInput
  }

  export type PreferenceUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyMotherTongueInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
  }

  export type PreferenceCreateManyMotherTongueInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    communityId: number
    religionId: number
    maritalStatusId: number
  }

  export type DiversityUpdateWithoutMotherTongueInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutMotherTongueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutMotherTongueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUpdateWithoutMotherTongueInput = {
    user?: UserUpdateOneRequiredWithoutPreferenceNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferenceNestedInput
    city?: CityUpdateOneRequiredWithoutPreferenceNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferenceNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutPreferenceNestedInput
  }

  export type PreferenceUncheckedUpdateWithoutMotherTongueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceUncheckedUpdateManyWithoutMotherTongueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type AdditionalDetailCreateManyAstrologyInput = {
    id?: number
    userId: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailUpdateWithoutAstrologyInput = {
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdditionalDetailNestedInput
  }

  export type AdditionalDetailUncheckedUpdateWithoutAstrologyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalDetailUncheckedUpdateManyWithoutAstrologyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaritalStatusCountOutputTypeDefaultArgs instead
     */
    export type MaritalStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaritalStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReligionCountOutputTypeDefaultArgs instead
     */
    export type ReligionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReligionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryCountOutputTypeDefaultArgs instead
     */
    export type CountryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityCountOutputTypeDefaultArgs instead
     */
    export type CommunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MotherTongueCountOutputTypeDefaultArgs instead
     */
    export type MotherTongueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MotherTongueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AstrologyCountOutputTypeDefaultArgs instead
     */
    export type AstrologyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AstrologyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiversityDefaultArgs instead
     */
    export type DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiversityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdditionalDetailDefaultArgs instead
     */
    export type AdditionalDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdditionalDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PreferenceDefaultArgs instead
     */
    export type PreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaritalStatusDefaultArgs instead
     */
    export type MaritalStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaritalStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReligionDefaultArgs instead
     */
    export type ReligionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReligionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryDefaultArgs instead
     */
    export type CountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityDefaultArgs instead
     */
    export type CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MotherTongueDefaultArgs instead
     */
    export type MotherTongueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MotherTongueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AstrologyDefaultArgs instead
     */
    export type AstrologyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AstrologyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConnectionDefaultArgs instead
     */
    export type ConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConnectionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}

/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Diversity
 * 
 */
export type Diversity = $Result.DefaultSelection<Prisma.$DiversityPayload>
/**
 * Model AdditionalDetail
 * 
 */
export type AdditionalDetail = $Result.DefaultSelection<Prisma.$AdditionalDetailPayload>
/**
 * Model UserPreference
 * 
 */
export type UserPreference = $Result.DefaultSelection<Prisma.$UserPreferencePayload>
/**
 * Model PreferredDiversity
 * 
 */
export type PreferredDiversity = $Result.DefaultSelection<Prisma.$PreferredDiversityPayload>
/**
 * Model MaritalStatus
 * 
 */
export type MaritalStatus = $Result.DefaultSelection<Prisma.$MaritalStatusPayload>
/**
 * Model Religion
 * 
 */
export type Religion = $Result.DefaultSelection<Prisma.$ReligionPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model MotherTongue
 * 
 */
export type MotherTongue = $Result.DefaultSelection<Prisma.$MotherTonguePayload>
/**
 * Model Astrology
 * 
 */
export type Astrology = $Result.DefaultSelection<Prisma.$AstrologyPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.diversity`: Exposes CRUD operations for the **Diversity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diversities
    * const diversities = await prisma.diversity.findMany()
    * ```
    */
  get diversity(): Prisma.DiversityDelegate<ExtArgs>;

  /**
   * `prisma.additionalDetail`: Exposes CRUD operations for the **AdditionalDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdditionalDetails
    * const additionalDetails = await prisma.additionalDetail.findMany()
    * ```
    */
  get additionalDetail(): Prisma.AdditionalDetailDelegate<ExtArgs>;

  /**
   * `prisma.userPreference`: Exposes CRUD operations for the **UserPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreference.findMany()
    * ```
    */
  get userPreference(): Prisma.UserPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.preferredDiversity`: Exposes CRUD operations for the **PreferredDiversity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreferredDiversities
    * const preferredDiversities = await prisma.preferredDiversity.findMany()
    * ```
    */
  get preferredDiversity(): Prisma.PreferredDiversityDelegate<ExtArgs>;

  /**
   * `prisma.maritalStatus`: Exposes CRUD operations for the **MaritalStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaritalStatuses
    * const maritalStatuses = await prisma.maritalStatus.findMany()
    * ```
    */
  get maritalStatus(): Prisma.MaritalStatusDelegate<ExtArgs>;

  /**
   * `prisma.religion`: Exposes CRUD operations for the **Religion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Religions
    * const religions = await prisma.religion.findMany()
    * ```
    */
  get religion(): Prisma.ReligionDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs>;

  /**
   * `prisma.motherTongue`: Exposes CRUD operations for the **MotherTongue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MotherTongues
    * const motherTongues = await prisma.motherTongue.findMany()
    * ```
    */
  get motherTongue(): Prisma.MotherTongueDelegate<ExtArgs>;

  /**
   * `prisma.astrology`: Exposes CRUD operations for the **Astrology** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Astrologies
    * const astrologies = await prisma.astrology.findMany()
    * ```
    */
  get astrology(): Prisma.AstrologyDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.13.0
   * Query Engine version: b9a39a7ee606c28e3455d0fd60e78c3ba82b1a2b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Diversity: 'Diversity',
    AdditionalDetail: 'AdditionalDetail',
    UserPreference: 'UserPreference',
    PreferredDiversity: 'PreferredDiversity',
    MaritalStatus: 'MaritalStatus',
    Religion: 'Religion',
    Country: 'Country',
    City: 'City',
    Community: 'Community',
    MotherTongue: 'MotherTongue',
    Astrology: 'Astrology'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'diversity' | 'additionalDetail' | 'userPreference' | 'preferredDiversity' | 'maritalStatus' | 'religion' | 'country' | 'city' | 'community' | 'motherTongue' | 'astrology'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Diversity: {
        payload: Prisma.$DiversityPayload<ExtArgs>
        fields: Prisma.DiversityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiversityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiversityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          findFirst: {
            args: Prisma.DiversityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiversityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          findMany: {
            args: Prisma.DiversityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>[]
          }
          create: {
            args: Prisma.DiversityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          createMany: {
            args: Prisma.DiversityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DiversityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          update: {
            args: Prisma.DiversityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          deleteMany: {
            args: Prisma.DiversityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DiversityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DiversityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiversityPayload>
          }
          aggregate: {
            args: Prisma.DiversityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiversity>
          }
          groupBy: {
            args: Prisma.DiversityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiversityGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiversityCountArgs<ExtArgs>,
            result: $Utils.Optional<DiversityCountAggregateOutputType> | number
          }
        }
      }
      AdditionalDetail: {
        payload: Prisma.$AdditionalDetailPayload<ExtArgs>
        fields: Prisma.AdditionalDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdditionalDetailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdditionalDetailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          findFirst: {
            args: Prisma.AdditionalDetailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdditionalDetailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          findMany: {
            args: Prisma.AdditionalDetailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>[]
          }
          create: {
            args: Prisma.AdditionalDetailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          createMany: {
            args: Prisma.AdditionalDetailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdditionalDetailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          update: {
            args: Prisma.AdditionalDetailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          deleteMany: {
            args: Prisma.AdditionalDetailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdditionalDetailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdditionalDetailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdditionalDetailPayload>
          }
          aggregate: {
            args: Prisma.AdditionalDetailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdditionalDetail>
          }
          groupBy: {
            args: Prisma.AdditionalDetailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdditionalDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdditionalDetailCountArgs<ExtArgs>,
            result: $Utils.Optional<AdditionalDetailCountAggregateOutputType> | number
          }
        }
      }
      UserPreference: {
        payload: Prisma.$UserPreferencePayload<ExtArgs>
        fields: Prisma.UserPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findFirst: {
            args: Prisma.UserPreferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findMany: {
            args: Prisma.UserPreferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          create: {
            args: Prisma.UserPreferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          createMany: {
            args: Prisma.UserPreferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserPreferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          update: {
            args: Prisma.UserPreferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          deleteMany: {
            args: Prisma.UserPreferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserPreferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          aggregate: {
            args: Prisma.UserPreferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPreference>
          }
          groupBy: {
            args: Prisma.UserPreferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPreferenceCountAggregateOutputType> | number
          }
        }
      }
      PreferredDiversity: {
        payload: Prisma.$PreferredDiversityPayload<ExtArgs>
        fields: Prisma.PreferredDiversityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreferredDiversityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreferredDiversityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload>
          }
          findFirst: {
            args: Prisma.PreferredDiversityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreferredDiversityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload>
          }
          findMany: {
            args: Prisma.PreferredDiversityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload>[]
          }
          create: {
            args: Prisma.PreferredDiversityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload>
          }
          createMany: {
            args: Prisma.PreferredDiversityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PreferredDiversityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload>
          }
          update: {
            args: Prisma.PreferredDiversityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload>
          }
          deleteMany: {
            args: Prisma.PreferredDiversityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PreferredDiversityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PreferredDiversityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PreferredDiversityPayload>
          }
          aggregate: {
            args: Prisma.PreferredDiversityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePreferredDiversity>
          }
          groupBy: {
            args: Prisma.PreferredDiversityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PreferredDiversityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreferredDiversityCountArgs<ExtArgs>,
            result: $Utils.Optional<PreferredDiversityCountAggregateOutputType> | number
          }
        }
      }
      MaritalStatus: {
        payload: Prisma.$MaritalStatusPayload<ExtArgs>
        fields: Prisma.MaritalStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaritalStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaritalStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          findFirst: {
            args: Prisma.MaritalStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaritalStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          findMany: {
            args: Prisma.MaritalStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>[]
          }
          create: {
            args: Prisma.MaritalStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          createMany: {
            args: Prisma.MaritalStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MaritalStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          update: {
            args: Prisma.MaritalStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          deleteMany: {
            args: Prisma.MaritalStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MaritalStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MaritalStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          aggregate: {
            args: Prisma.MaritalStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMaritalStatus>
          }
          groupBy: {
            args: Prisma.MaritalStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MaritalStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaritalStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<MaritalStatusCountAggregateOutputType> | number
          }
        }
      }
      Religion: {
        payload: Prisma.$ReligionPayload<ExtArgs>
        fields: Prisma.ReligionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReligionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReligionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          findFirst: {
            args: Prisma.ReligionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReligionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          findMany: {
            args: Prisma.ReligionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>[]
          }
          create: {
            args: Prisma.ReligionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          createMany: {
            args: Prisma.ReligionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReligionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          update: {
            args: Prisma.ReligionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          deleteMany: {
            args: Prisma.ReligionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReligionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReligionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReligionPayload>
          }
          aggregate: {
            args: Prisma.ReligionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReligion>
          }
          groupBy: {
            args: Prisma.ReligionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReligionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReligionCountArgs<ExtArgs>,
            result: $Utils.Optional<ReligionCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>,
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>,
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      MotherTongue: {
        payload: Prisma.$MotherTonguePayload<ExtArgs>
        fields: Prisma.MotherTongueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MotherTongueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MotherTongueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          findFirst: {
            args: Prisma.MotherTongueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MotherTongueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          findMany: {
            args: Prisma.MotherTongueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>[]
          }
          create: {
            args: Prisma.MotherTongueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          createMany: {
            args: Prisma.MotherTongueCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MotherTongueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          update: {
            args: Prisma.MotherTongueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          deleteMany: {
            args: Prisma.MotherTongueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MotherTongueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MotherTongueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MotherTonguePayload>
          }
          aggregate: {
            args: Prisma.MotherTongueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMotherTongue>
          }
          groupBy: {
            args: Prisma.MotherTongueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MotherTongueGroupByOutputType>[]
          }
          count: {
            args: Prisma.MotherTongueCountArgs<ExtArgs>,
            result: $Utils.Optional<MotherTongueCountAggregateOutputType> | number
          }
        }
      }
      Astrology: {
        payload: Prisma.$AstrologyPayload<ExtArgs>
        fields: Prisma.AstrologyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AstrologyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AstrologyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          findFirst: {
            args: Prisma.AstrologyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AstrologyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          findMany: {
            args: Prisma.AstrologyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>[]
          }
          create: {
            args: Prisma.AstrologyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          createMany: {
            args: Prisma.AstrologyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AstrologyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          update: {
            args: Prisma.AstrologyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          deleteMany: {
            args: Prisma.AstrologyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AstrologyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AstrologyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AstrologyPayload>
          }
          aggregate: {
            args: Prisma.AstrologyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAstrology>
          }
          groupBy: {
            args: Prisma.AstrologyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AstrologyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AstrologyCountArgs<ExtArgs>,
            result: $Utils.Optional<AstrologyCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserPreferenceCountOutputType
   */

  export type UserPreferenceCountOutputType = {
    preferredDiversity: number
  }

  export type UserPreferenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preferredDiversity?: boolean | UserPreferenceCountOutputTypeCountPreferredDiversityArgs
  }

  // Custom InputTypes
  /**
   * UserPreferenceCountOutputType without action
   */
  export type UserPreferenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferenceCountOutputType
     */
    select?: UserPreferenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserPreferenceCountOutputType without action
   */
  export type UserPreferenceCountOutputTypeCountPreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferredDiversityWhereInput
  }


  /**
   * Count Type MaritalStatusCountOutputType
   */

  export type MaritalStatusCountOutputType = {
    users: number
    UserPreference: number
  }

  export type MaritalStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MaritalStatusCountOutputTypeCountUsersArgs
    UserPreference?: boolean | MaritalStatusCountOutputTypeCountUserPreferenceArgs
  }

  // Custom InputTypes
  /**
   * MaritalStatusCountOutputType without action
   */
  export type MaritalStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatusCountOutputType
     */
    select?: MaritalStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaritalStatusCountOutputType without action
   */
  export type MaritalStatusCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * MaritalStatusCountOutputType without action
   */
  export type MaritalStatusCountOutputTypeCountUserPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferenceWhereInput
  }


  /**
   * Count Type ReligionCountOutputType
   */

  export type ReligionCountOutputType = {
    Diversity: number
    PreferredDiversity: number
  }

  export type ReligionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | ReligionCountOutputTypeCountDiversityArgs
    PreferredDiversity?: boolean | ReligionCountOutputTypeCountPreferredDiversityArgs
  }

  // Custom InputTypes
  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionCountOutputType
     */
    select?: ReligionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * ReligionCountOutputType without action
   */
  export type ReligionCountOutputTypeCountPreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferredDiversityWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    cities: number
    Diversity: number
    PreferredDiversity: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | CountryCountOutputTypeCountCitiesArgs
    Diversity?: boolean | CountryCountOutputTypeCountDiversityArgs
    PreferredDiversity?: boolean | CountryCountOutputTypeCountPreferredDiversityArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountPreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferredDiversityWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    Diversity: number
    PreferredDiversity: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | CityCountOutputTypeCountDiversityArgs
    PreferredDiversity?: boolean | CityCountOutputTypeCountPreferredDiversityArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountPreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferredDiversityWhereInput
  }


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    Diversity: number
    PreferredDiversity: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | CommunityCountOutputTypeCountDiversityArgs
    PreferredDiversity?: boolean | CommunityCountOutputTypeCountPreferredDiversityArgs
  }

  // Custom InputTypes
  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountPreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferredDiversityWhereInput
  }


  /**
   * Count Type MotherTongueCountOutputType
   */

  export type MotherTongueCountOutputType = {
    Diversity: number
    PreferredDiversity: number
  }

  export type MotherTongueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | MotherTongueCountOutputTypeCountDiversityArgs
    PreferredDiversity?: boolean | MotherTongueCountOutputTypeCountPreferredDiversityArgs
  }

  // Custom InputTypes
  /**
   * MotherTongueCountOutputType without action
   */
  export type MotherTongueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongueCountOutputType
     */
    select?: MotherTongueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MotherTongueCountOutputType without action
   */
  export type MotherTongueCountOutputTypeCountDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
  }

  /**
   * MotherTongueCountOutputType without action
   */
  export type MotherTongueCountOutputTypeCountPreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferredDiversityWhereInput
  }


  /**
   * Count Type AstrologyCountOutputType
   */

  export type AstrologyCountOutputType = {
    AdditionalDetail: number
    UserPreference: number
  }

  export type AstrologyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdditionalDetail?: boolean | AstrologyCountOutputTypeCountAdditionalDetailArgs
    UserPreference?: boolean | AstrologyCountOutputTypeCountUserPreferenceArgs
  }

  // Custom InputTypes
  /**
   * AstrologyCountOutputType without action
   */
  export type AstrologyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AstrologyCountOutputType
     */
    select?: AstrologyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AstrologyCountOutputType without action
   */
  export type AstrologyCountOutputTypeCountAdditionalDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalDetailWhereInput
  }

  /**
   * AstrologyCountOutputType without action
   */
  export type AstrologyCountOutputTypeCountUserPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferenceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    maritalStatusId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    maritalStatusId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: string | null
    bio: string | null
    image: string | null
    maritalStatusId: number | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: string | null
    bio: string | null
    image: string | null
    maritalStatusId: number | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    firstName: number
    lastName: number
    dateOfBirth: number
    gender: number
    bio: number
    image: number
    maritalStatusId: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    maritalStatusId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    maritalStatusId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bio?: true
    image?: true
    maritalStatusId?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bio?: true
    image?: true
    maritalStatusId?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bio?: true
    image?: true
    maritalStatusId?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bio?: boolean
    image?: boolean
    maritalStatusId?: boolean
    password?: boolean
    maritalStatus?: boolean | MaritalStatusDefaultArgs<ExtArgs>
    diversity?: boolean | User$diversityArgs<ExtArgs>
    additionalDetail?: boolean | User$additionalDetailArgs<ExtArgs>
    userPreferences?: boolean | User$userPreferencesArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bio?: boolean
    image?: boolean
    maritalStatusId?: boolean
    password?: boolean
  }


  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maritalStatus?: boolean | MaritalStatusDefaultArgs<ExtArgs>
    diversity?: boolean | User$diversityArgs<ExtArgs>
    additionalDetail?: boolean | User$additionalDetailArgs<ExtArgs>
    userPreferences?: boolean | User$userPreferencesArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      maritalStatus: Prisma.$MaritalStatusPayload<ExtArgs>
      diversity: Prisma.$DiversityPayload<ExtArgs> | null
      additionalDetail: Prisma.$AdditionalDetailPayload<ExtArgs> | null
      userPreferences: Prisma.$UserPreferencePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      email: string
      firstName: string
      lastName: string
      dateOfBirth: Date
      gender: string
      bio: string
      image: string
      maritalStatusId: number
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    maritalStatus<T extends MaritalStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatusDefaultArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    diversity<T extends User$diversityArgs<ExtArgs> = {}>(args?: Subset<T, User$diversityArgs<ExtArgs>>): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    additionalDetail<T extends User$additionalDetailArgs<ExtArgs> = {}>(args?: Subset<T, User$additionalDetailArgs<ExtArgs>>): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    userPreferences<T extends User$userPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$userPreferencesArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly maritalStatusId: FieldRef<"User", 'Int'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.diversity
   */
  export type User$diversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
  }

  /**
   * User.additionalDetail
   */
  export type User$additionalDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    where?: AdditionalDetailWhereInput
  }

  /**
   * User.userPreferences
   */
  export type User$userPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    where?: UserPreferenceWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Diversity
   */

  export type AggregateDiversity = {
    _count: DiversityCountAggregateOutputType | null
    _avg: DiversityAvgAggregateOutputType | null
    _sum: DiversitySumAggregateOutputType | null
    _min: DiversityMinAggregateOutputType | null
    _max: DiversityMaxAggregateOutputType | null
  }

  export type DiversityAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    religionId: number | null
    countryId: number | null
    cityId: number | null
    communityId: number | null
    motherTongueId: number | null
  }

  export type DiversitySumAggregateOutputType = {
    id: number | null
    userId: number | null
    religionId: number | null
    countryId: number | null
    cityId: number | null
    communityId: number | null
    motherTongueId: number | null
  }

  export type DiversityMinAggregateOutputType = {
    id: number | null
    userId: number | null
    religionId: number | null
    countryId: number | null
    cityId: number | null
    communityId: number | null
    motherTongueId: number | null
  }

  export type DiversityMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    religionId: number | null
    countryId: number | null
    cityId: number | null
    communityId: number | null
    motherTongueId: number | null
  }

  export type DiversityCountAggregateOutputType = {
    id: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
    _all: number
  }


  export type DiversityAvgAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
  }

  export type DiversitySumAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
  }

  export type DiversityMinAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
  }

  export type DiversityMaxAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
  }

  export type DiversityCountAggregateInputType = {
    id?: true
    userId?: true
    religionId?: true
    countryId?: true
    cityId?: true
    communityId?: true
    motherTongueId?: true
    _all?: true
  }

  export type DiversityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diversity to aggregate.
     */
    where?: DiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversities to fetch.
     */
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diversities
    **/
    _count?: true | DiversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiversityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiversitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiversityMaxAggregateInputType
  }

  export type GetDiversityAggregateType<T extends DiversityAggregateArgs> = {
        [P in keyof T & keyof AggregateDiversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiversity[P]>
      : GetScalarType<T[P], AggregateDiversity[P]>
  }




  export type DiversityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithAggregationInput | DiversityOrderByWithAggregationInput[]
    by: DiversityScalarFieldEnum[] | DiversityScalarFieldEnum
    having?: DiversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiversityCountAggregateInputType | true
    _avg?: DiversityAvgAggregateInputType
    _sum?: DiversitySumAggregateInputType
    _min?: DiversityMinAggregateInputType
    _max?: DiversityMaxAggregateInputType
  }

  export type DiversityGroupByOutputType = {
    id: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
    _count: DiversityCountAggregateOutputType | null
    _avg: DiversityAvgAggregateOutputType | null
    _sum: DiversitySumAggregateOutputType | null
    _min: DiversityMinAggregateOutputType | null
    _max: DiversityMaxAggregateOutputType | null
  }

  type GetDiversityGroupByPayload<T extends DiversityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiversityGroupByOutputType[P]>
            : GetScalarType<T[P], DiversityGroupByOutputType[P]>
        }
      >
    >


  export type DiversitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    religionId?: boolean
    countryId?: boolean
    cityId?: boolean
    communityId?: boolean
    motherTongueId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    motherTongue?: boolean | MotherTongueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diversity"]>

  export type DiversitySelectScalar = {
    id?: boolean
    userId?: boolean
    religionId?: boolean
    countryId?: boolean
    cityId?: boolean
    communityId?: boolean
    motherTongueId?: boolean
  }


  export type DiversityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    motherTongue?: boolean | MotherTongueDefaultArgs<ExtArgs>
  }


  export type $DiversityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diversity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      religion: Prisma.$ReligionPayload<ExtArgs>
      country: Prisma.$CountryPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      community: Prisma.$CommunityPayload<ExtArgs>
      motherTongue: Prisma.$MotherTonguePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      religionId: number
      countryId: number
      cityId: number
      communityId: number
      motherTongueId: number
    }, ExtArgs["result"]["diversity"]>
    composites: {}
  }


  type DiversityGetPayload<S extends boolean | null | undefined | DiversityDefaultArgs> = $Result.GetResult<Prisma.$DiversityPayload, S>

  type DiversityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiversityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiversityCountAggregateInputType | true
    }

  export interface DiversityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diversity'], meta: { name: 'Diversity' } }
    /**
     * Find zero or one Diversity that matches the filter.
     * @param {DiversityFindUniqueArgs} args - Arguments to find a Diversity
     * @example
     * // Get one Diversity
     * const diversity = await prisma.diversity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiversityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityFindUniqueArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Diversity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DiversityFindUniqueOrThrowArgs} args - Arguments to find a Diversity
     * @example
     * // Get one Diversity
     * const diversity = await prisma.diversity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiversityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Diversity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityFindFirstArgs} args - Arguments to find a Diversity
     * @example
     * // Get one Diversity
     * const diversity = await prisma.diversity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiversityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityFindFirstArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Diversity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityFindFirstOrThrowArgs} args - Arguments to find a Diversity
     * @example
     * // Get one Diversity
     * const diversity = await prisma.diversity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiversityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Diversities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diversities
     * const diversities = await prisma.diversity.findMany()
     * 
     * // Get first 10 Diversities
     * const diversities = await prisma.diversity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diversityWithIdOnly = await prisma.diversity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiversityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Diversity.
     * @param {DiversityCreateArgs} args - Arguments to create a Diversity.
     * @example
     * // Create one Diversity
     * const Diversity = await prisma.diversity.create({
     *   data: {
     *     // ... data to create a Diversity
     *   }
     * })
     * 
    **/
    create<T extends DiversityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityCreateArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Diversities.
     *     @param {DiversityCreateManyArgs} args - Arguments to create many Diversities.
     *     @example
     *     // Create many Diversities
     *     const diversity = await prisma.diversity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiversityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diversity.
     * @param {DiversityDeleteArgs} args - Arguments to delete one Diversity.
     * @example
     * // Delete one Diversity
     * const Diversity = await prisma.diversity.delete({
     *   where: {
     *     // ... filter to delete one Diversity
     *   }
     * })
     * 
    **/
    delete<T extends DiversityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityDeleteArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Diversity.
     * @param {DiversityUpdateArgs} args - Arguments to update one Diversity.
     * @example
     * // Update one Diversity
     * const diversity = await prisma.diversity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiversityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityUpdateArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Diversities.
     * @param {DiversityDeleteManyArgs} args - Arguments to filter Diversities to delete.
     * @example
     * // Delete a few Diversities
     * const { count } = await prisma.diversity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiversityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiversityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diversities
     * const diversity = await prisma.diversity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiversityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diversity.
     * @param {DiversityUpsertArgs} args - Arguments to update or create a Diversity.
     * @example
     * // Update or create a Diversity
     * const diversity = await prisma.diversity.upsert({
     *   create: {
     *     // ... data to create a Diversity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diversity we want to update
     *   }
     * })
    **/
    upsert<T extends DiversityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DiversityUpsertArgs<ExtArgs>>
    ): Prisma__DiversityClient<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Diversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityCountArgs} args - Arguments to filter Diversities to count.
     * @example
     * // Count the number of Diversities
     * const count = await prisma.diversity.count({
     *   where: {
     *     // ... the filter for the Diversities we want to count
     *   }
     * })
    **/
    count<T extends DiversityCountArgs>(
      args?: Subset<T, DiversityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiversityAggregateArgs>(args: Subset<T, DiversityAggregateArgs>): Prisma.PrismaPromise<GetDiversityAggregateType<T>>

    /**
     * Group by Diversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiversityGroupByArgs['orderBy'] }
        : { orderBy?: DiversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diversity model
   */
  readonly fields: DiversityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diversity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiversityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    religion<T extends ReligionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReligionDefaultArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    motherTongue<T extends MotherTongueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MotherTongueDefaultArgs<ExtArgs>>): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Diversity model
   */ 
  interface DiversityFieldRefs {
    readonly id: FieldRef<"Diversity", 'Int'>
    readonly userId: FieldRef<"Diversity", 'Int'>
    readonly religionId: FieldRef<"Diversity", 'Int'>
    readonly countryId: FieldRef<"Diversity", 'Int'>
    readonly cityId: FieldRef<"Diversity", 'Int'>
    readonly communityId: FieldRef<"Diversity", 'Int'>
    readonly motherTongueId: FieldRef<"Diversity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Diversity findUnique
   */
  export type DiversityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversity to fetch.
     */
    where: DiversityWhereUniqueInput
  }

  /**
   * Diversity findUniqueOrThrow
   */
  export type DiversityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversity to fetch.
     */
    where: DiversityWhereUniqueInput
  }

  /**
   * Diversity findFirst
   */
  export type DiversityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversity to fetch.
     */
    where?: DiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversities to fetch.
     */
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diversities.
     */
    cursor?: DiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diversities.
     */
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Diversity findFirstOrThrow
   */
  export type DiversityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversity to fetch.
     */
    where?: DiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversities to fetch.
     */
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diversities.
     */
    cursor?: DiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diversities.
     */
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Diversity findMany
   */
  export type DiversityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter, which Diversities to fetch.
     */
    where?: DiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diversities to fetch.
     */
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diversities.
     */
    cursor?: DiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diversities.
     */
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Diversity create
   */
  export type DiversityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * The data needed to create a Diversity.
     */
    data: XOR<DiversityCreateInput, DiversityUncheckedCreateInput>
  }

  /**
   * Diversity createMany
   */
  export type DiversityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diversities.
     */
    data: DiversityCreateManyInput | DiversityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diversity update
   */
  export type DiversityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * The data needed to update a Diversity.
     */
    data: XOR<DiversityUpdateInput, DiversityUncheckedUpdateInput>
    /**
     * Choose, which Diversity to update.
     */
    where: DiversityWhereUniqueInput
  }

  /**
   * Diversity updateMany
   */
  export type DiversityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diversities.
     */
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyInput>
    /**
     * Filter which Diversities to update
     */
    where?: DiversityWhereInput
  }

  /**
   * Diversity upsert
   */
  export type DiversityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * The filter to search for the Diversity to update in case it exists.
     */
    where: DiversityWhereUniqueInput
    /**
     * In case the Diversity found by the `where` argument doesn't exist, create a new Diversity with this data.
     */
    create: XOR<DiversityCreateInput, DiversityUncheckedCreateInput>
    /**
     * In case the Diversity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiversityUpdateInput, DiversityUncheckedUpdateInput>
  }

  /**
   * Diversity delete
   */
  export type DiversityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    /**
     * Filter which Diversity to delete.
     */
    where: DiversityWhereUniqueInput
  }

  /**
   * Diversity deleteMany
   */
  export type DiversityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diversities to delete
     */
    where?: DiversityWhereInput
  }

  /**
   * Diversity without action
   */
  export type DiversityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
  }


  /**
   * Model AdditionalDetail
   */

  export type AggregateAdditionalDetail = {
    _count: AdditionalDetailCountAggregateOutputType | null
    _avg: AdditionalDetailAvgAggregateOutputType | null
    _sum: AdditionalDetailSumAggregateOutputType | null
    _min: AdditionalDetailMinAggregateOutputType | null
    _max: AdditionalDetailMaxAggregateOutputType | null
  }

  export type AdditionalDetailAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    astrologicalId: number | null
  }

  export type AdditionalDetailSumAggregateOutputType = {
    id: number | null
    userId: number | null
    astrologicalId: number | null
  }

  export type AdditionalDetailMinAggregateOutputType = {
    id: number | null
    userId: number | null
    astrologicalId: number | null
    facebookProfileLink: string | null
    contactNumber: string | null
  }

  export type AdditionalDetailMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    astrologicalId: number | null
    facebookProfileLink: string | null
    contactNumber: string | null
  }

  export type AdditionalDetailCountAggregateOutputType = {
    id: number
    userId: number
    astrologicalId: number
    facebookProfileLink: number
    contactNumber: number
    _all: number
  }


  export type AdditionalDetailAvgAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
  }

  export type AdditionalDetailSumAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
  }

  export type AdditionalDetailMinAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
    facebookProfileLink?: true
    contactNumber?: true
  }

  export type AdditionalDetailMaxAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
    facebookProfileLink?: true
    contactNumber?: true
  }

  export type AdditionalDetailCountAggregateInputType = {
    id?: true
    userId?: true
    astrologicalId?: true
    facebookProfileLink?: true
    contactNumber?: true
    _all?: true
  }

  export type AdditionalDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalDetail to aggregate.
     */
    where?: AdditionalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDetails to fetch.
     */
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdditionalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdditionalDetails
    **/
    _count?: true | AdditionalDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdditionalDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdditionalDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdditionalDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdditionalDetailMaxAggregateInputType
  }

  export type GetAdditionalDetailAggregateType<T extends AdditionalDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateAdditionalDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdditionalDetail[P]>
      : GetScalarType<T[P], AggregateAdditionalDetail[P]>
  }




  export type AdditionalDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdditionalDetailWhereInput
    orderBy?: AdditionalDetailOrderByWithAggregationInput | AdditionalDetailOrderByWithAggregationInput[]
    by: AdditionalDetailScalarFieldEnum[] | AdditionalDetailScalarFieldEnum
    having?: AdditionalDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdditionalDetailCountAggregateInputType | true
    _avg?: AdditionalDetailAvgAggregateInputType
    _sum?: AdditionalDetailSumAggregateInputType
    _min?: AdditionalDetailMinAggregateInputType
    _max?: AdditionalDetailMaxAggregateInputType
  }

  export type AdditionalDetailGroupByOutputType = {
    id: number
    userId: number
    astrologicalId: number
    facebookProfileLink: string
    contactNumber: string
    _count: AdditionalDetailCountAggregateOutputType | null
    _avg: AdditionalDetailAvgAggregateOutputType | null
    _sum: AdditionalDetailSumAggregateOutputType | null
    _min: AdditionalDetailMinAggregateOutputType | null
    _max: AdditionalDetailMaxAggregateOutputType | null
  }

  type GetAdditionalDetailGroupByPayload<T extends AdditionalDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdditionalDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdditionalDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdditionalDetailGroupByOutputType[P]>
            : GetScalarType<T[P], AdditionalDetailGroupByOutputType[P]>
        }
      >
    >


  export type AdditionalDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    astrologicalId?: boolean
    facebookProfileLink?: boolean
    contactNumber?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    astrology?: boolean | AstrologyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["additionalDetail"]>

  export type AdditionalDetailSelectScalar = {
    id?: boolean
    userId?: boolean
    astrologicalId?: boolean
    facebookProfileLink?: boolean
    contactNumber?: boolean
  }


  export type AdditionalDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    astrology?: boolean | AstrologyDefaultArgs<ExtArgs>
  }


  export type $AdditionalDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdditionalDetail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      astrology: Prisma.$AstrologyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      astrologicalId: number
      facebookProfileLink: string
      contactNumber: string
    }, ExtArgs["result"]["additionalDetail"]>
    composites: {}
  }


  type AdditionalDetailGetPayload<S extends boolean | null | undefined | AdditionalDetailDefaultArgs> = $Result.GetResult<Prisma.$AdditionalDetailPayload, S>

  type AdditionalDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdditionalDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdditionalDetailCountAggregateInputType | true
    }

  export interface AdditionalDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdditionalDetail'], meta: { name: 'AdditionalDetail' } }
    /**
     * Find zero or one AdditionalDetail that matches the filter.
     * @param {AdditionalDetailFindUniqueArgs} args - Arguments to find a AdditionalDetail
     * @example
     * // Get one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdditionalDetailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailFindUniqueArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdditionalDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdditionalDetailFindUniqueOrThrowArgs} args - Arguments to find a AdditionalDetail
     * @example
     * // Get one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdditionalDetailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdditionalDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailFindFirstArgs} args - Arguments to find a AdditionalDetail
     * @example
     * // Get one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdditionalDetailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailFindFirstArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdditionalDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailFindFirstOrThrowArgs} args - Arguments to find a AdditionalDetail
     * @example
     * // Get one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdditionalDetailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdditionalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdditionalDetails
     * const additionalDetails = await prisma.additionalDetail.findMany()
     * 
     * // Get first 10 AdditionalDetails
     * const additionalDetails = await prisma.additionalDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const additionalDetailWithIdOnly = await prisma.additionalDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdditionalDetailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdditionalDetail.
     * @param {AdditionalDetailCreateArgs} args - Arguments to create a AdditionalDetail.
     * @example
     * // Create one AdditionalDetail
     * const AdditionalDetail = await prisma.additionalDetail.create({
     *   data: {
     *     // ... data to create a AdditionalDetail
     *   }
     * })
     * 
    **/
    create<T extends AdditionalDetailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailCreateArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdditionalDetails.
     *     @param {AdditionalDetailCreateManyArgs} args - Arguments to create many AdditionalDetails.
     *     @example
     *     // Create many AdditionalDetails
     *     const additionalDetail = await prisma.additionalDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdditionalDetailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdditionalDetail.
     * @param {AdditionalDetailDeleteArgs} args - Arguments to delete one AdditionalDetail.
     * @example
     * // Delete one AdditionalDetail
     * const AdditionalDetail = await prisma.additionalDetail.delete({
     *   where: {
     *     // ... filter to delete one AdditionalDetail
     *   }
     * })
     * 
    **/
    delete<T extends AdditionalDetailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailDeleteArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdditionalDetail.
     * @param {AdditionalDetailUpdateArgs} args - Arguments to update one AdditionalDetail.
     * @example
     * // Update one AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdditionalDetailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailUpdateArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdditionalDetails.
     * @param {AdditionalDetailDeleteManyArgs} args - Arguments to filter AdditionalDetails to delete.
     * @example
     * // Delete a few AdditionalDetails
     * const { count } = await prisma.additionalDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdditionalDetailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdditionalDetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdditionalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdditionalDetails
     * const additionalDetail = await prisma.additionalDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdditionalDetailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdditionalDetail.
     * @param {AdditionalDetailUpsertArgs} args - Arguments to update or create a AdditionalDetail.
     * @example
     * // Update or create a AdditionalDetail
     * const additionalDetail = await prisma.additionalDetail.upsert({
     *   create: {
     *     // ... data to create a AdditionalDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdditionalDetail we want to update
     *   }
     * })
    **/
    upsert<T extends AdditionalDetailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdditionalDetailUpsertArgs<ExtArgs>>
    ): Prisma__AdditionalDetailClient<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdditionalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailCountArgs} args - Arguments to filter AdditionalDetails to count.
     * @example
     * // Count the number of AdditionalDetails
     * const count = await prisma.additionalDetail.count({
     *   where: {
     *     // ... the filter for the AdditionalDetails we want to count
     *   }
     * })
    **/
    count<T extends AdditionalDetailCountArgs>(
      args?: Subset<T, AdditionalDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdditionalDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdditionalDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdditionalDetailAggregateArgs>(args: Subset<T, AdditionalDetailAggregateArgs>): Prisma.PrismaPromise<GetAdditionalDetailAggregateType<T>>

    /**
     * Group by AdditionalDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdditionalDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdditionalDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdditionalDetailGroupByArgs['orderBy'] }
        : { orderBy?: AdditionalDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdditionalDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdditionalDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdditionalDetail model
   */
  readonly fields: AdditionalDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdditionalDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdditionalDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    astrology<T extends AstrologyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AstrologyDefaultArgs<ExtArgs>>): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdditionalDetail model
   */ 
  interface AdditionalDetailFieldRefs {
    readonly id: FieldRef<"AdditionalDetail", 'Int'>
    readonly userId: FieldRef<"AdditionalDetail", 'Int'>
    readonly astrologicalId: FieldRef<"AdditionalDetail", 'Int'>
    readonly facebookProfileLink: FieldRef<"AdditionalDetail", 'String'>
    readonly contactNumber: FieldRef<"AdditionalDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdditionalDetail findUnique
   */
  export type AdditionalDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetail to fetch.
     */
    where: AdditionalDetailWhereUniqueInput
  }

  /**
   * AdditionalDetail findUniqueOrThrow
   */
  export type AdditionalDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetail to fetch.
     */
    where: AdditionalDetailWhereUniqueInput
  }

  /**
   * AdditionalDetail findFirst
   */
  export type AdditionalDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetail to fetch.
     */
    where?: AdditionalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDetails to fetch.
     */
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalDetails.
     */
    cursor?: AdditionalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalDetails.
     */
    distinct?: AdditionalDetailScalarFieldEnum | AdditionalDetailScalarFieldEnum[]
  }

  /**
   * AdditionalDetail findFirstOrThrow
   */
  export type AdditionalDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetail to fetch.
     */
    where?: AdditionalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDetails to fetch.
     */
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdditionalDetails.
     */
    cursor?: AdditionalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdditionalDetails.
     */
    distinct?: AdditionalDetailScalarFieldEnum | AdditionalDetailScalarFieldEnum[]
  }

  /**
   * AdditionalDetail findMany
   */
  export type AdditionalDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter, which AdditionalDetails to fetch.
     */
    where?: AdditionalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdditionalDetails to fetch.
     */
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdditionalDetails.
     */
    cursor?: AdditionalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdditionalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdditionalDetails.
     */
    skip?: number
    distinct?: AdditionalDetailScalarFieldEnum | AdditionalDetailScalarFieldEnum[]
  }

  /**
   * AdditionalDetail create
   */
  export type AdditionalDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a AdditionalDetail.
     */
    data: XOR<AdditionalDetailCreateInput, AdditionalDetailUncheckedCreateInput>
  }

  /**
   * AdditionalDetail createMany
   */
  export type AdditionalDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdditionalDetails.
     */
    data: AdditionalDetailCreateManyInput | AdditionalDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdditionalDetail update
   */
  export type AdditionalDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a AdditionalDetail.
     */
    data: XOR<AdditionalDetailUpdateInput, AdditionalDetailUncheckedUpdateInput>
    /**
     * Choose, which AdditionalDetail to update.
     */
    where: AdditionalDetailWhereUniqueInput
  }

  /**
   * AdditionalDetail updateMany
   */
  export type AdditionalDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdditionalDetails.
     */
    data: XOR<AdditionalDetailUpdateManyMutationInput, AdditionalDetailUncheckedUpdateManyInput>
    /**
     * Filter which AdditionalDetails to update
     */
    where?: AdditionalDetailWhereInput
  }

  /**
   * AdditionalDetail upsert
   */
  export type AdditionalDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the AdditionalDetail to update in case it exists.
     */
    where: AdditionalDetailWhereUniqueInput
    /**
     * In case the AdditionalDetail found by the `where` argument doesn't exist, create a new AdditionalDetail with this data.
     */
    create: XOR<AdditionalDetailCreateInput, AdditionalDetailUncheckedCreateInput>
    /**
     * In case the AdditionalDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdditionalDetailUpdateInput, AdditionalDetailUncheckedUpdateInput>
  }

  /**
   * AdditionalDetail delete
   */
  export type AdditionalDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    /**
     * Filter which AdditionalDetail to delete.
     */
    where: AdditionalDetailWhereUniqueInput
  }

  /**
   * AdditionalDetail deleteMany
   */
  export type AdditionalDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdditionalDetails to delete
     */
    where?: AdditionalDetailWhereInput
  }

  /**
   * AdditionalDetail without action
   */
  export type AdditionalDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
  }


  /**
   * Model UserPreference
   */

  export type AggregateUserPreference = {
    _count: UserPreferenceCountAggregateOutputType | null
    _avg: UserPreferenceAvgAggregateOutputType | null
    _sum: UserPreferenceSumAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  export type UserPreferenceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    minAge: number | null
    maxAge: number | null
    astrologicalId: number | null
    maritalStatusId: number | null
  }

  export type UserPreferenceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    minAge: number | null
    maxAge: number | null
    astrologicalId: number | null
    maritalStatusId: number | null
  }

  export type UserPreferenceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    gender: string | null
    minAge: number | null
    maxAge: number | null
    astrologicalId: number | null
    maritalStatusId: number | null
  }

  export type UserPreferenceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    gender: string | null
    minAge: number | null
    maxAge: number | null
    astrologicalId: number | null
    maritalStatusId: number | null
  }

  export type UserPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    gender: number
    minAge: number
    maxAge: number
    astrologicalId: number
    maritalStatusId: number
    _all: number
  }


  export type UserPreferenceAvgAggregateInputType = {
    id?: true
    userId?: true
    minAge?: true
    maxAge?: true
    astrologicalId?: true
    maritalStatusId?: true
  }

  export type UserPreferenceSumAggregateInputType = {
    id?: true
    userId?: true
    minAge?: true
    maxAge?: true
    astrologicalId?: true
    maritalStatusId?: true
  }

  export type UserPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    minAge?: true
    maxAge?: true
    astrologicalId?: true
    maritalStatusId?: true
  }

  export type UserPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    minAge?: true
    maxAge?: true
    astrologicalId?: true
    maritalStatusId?: true
  }

  export type UserPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    minAge?: true
    maxAge?: true
    astrologicalId?: true
    maritalStatusId?: true
    _all?: true
  }

  export type UserPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreference to aggregate.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type GetUserPreferenceAggregateType<T extends UserPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreference[P]>
      : GetScalarType<T[P], AggregateUserPreference[P]>
  }




  export type UserPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferenceWhereInput
    orderBy?: UserPreferenceOrderByWithAggregationInput | UserPreferenceOrderByWithAggregationInput[]
    by: UserPreferenceScalarFieldEnum[] | UserPreferenceScalarFieldEnum
    having?: UserPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferenceCountAggregateInputType | true
    _avg?: UserPreferenceAvgAggregateInputType
    _sum?: UserPreferenceSumAggregateInputType
    _min?: UserPreferenceMinAggregateInputType
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type UserPreferenceGroupByOutputType = {
    id: number
    userId: number
    gender: string
    minAge: number
    maxAge: number
    astrologicalId: number
    maritalStatusId: number
    _count: UserPreferenceCountAggregateOutputType | null
    _avg: UserPreferenceAvgAggregateOutputType | null
    _sum: UserPreferenceSumAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  type GetUserPreferenceGroupByPayload<T extends UserPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gender?: boolean
    minAge?: boolean
    maxAge?: boolean
    astrologicalId?: boolean
    maritalStatusId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    astrology?: boolean | AstrologyDefaultArgs<ExtArgs>
    maritalStatus?: boolean | MaritalStatusDefaultArgs<ExtArgs>
    preferredDiversity?: boolean | UserPreference$preferredDiversityArgs<ExtArgs>
    _count?: boolean | UserPreferenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    gender?: boolean
    minAge?: boolean
    maxAge?: boolean
    astrologicalId?: boolean
    maritalStatusId?: boolean
  }


  export type UserPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    astrology?: boolean | AstrologyDefaultArgs<ExtArgs>
    maritalStatus?: boolean | MaritalStatusDefaultArgs<ExtArgs>
    preferredDiversity?: boolean | UserPreference$preferredDiversityArgs<ExtArgs>
    _count?: boolean | UserPreferenceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      astrology: Prisma.$AstrologyPayload<ExtArgs>
      maritalStatus: Prisma.$MaritalStatusPayload<ExtArgs>
      preferredDiversity: Prisma.$PreferredDiversityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      gender: string
      minAge: number
      maxAge: number
      astrologicalId: number
      maritalStatusId: number
    }, ExtArgs["result"]["userPreference"]>
    composites: {}
  }


  type UserPreferenceGetPayload<S extends boolean | null | undefined | UserPreferenceDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencePayload, S>

  type UserPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserPreferenceCountAggregateInputType | true
    }

  export interface UserPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreference'], meta: { name: 'UserPreference' } }
    /**
     * Find zero or one UserPreference that matches the filter.
     * @param {UserPreferenceFindUniqueArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPreferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserPreference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPreferenceFindUniqueOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPreferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPreferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferenceFindFirstArgs<ExtArgs>>
    ): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPreferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreference.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserPreferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserPreference.
     * @param {UserPreferenceCreateArgs} args - Arguments to create a UserPreference.
     * @example
     * // Create one UserPreference
     * const UserPreference = await prisma.userPreference.create({
     *   data: {
     *     // ... data to create a UserPreference
     *   }
     * })
     * 
    **/
    create<T extends UserPreferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferenceCreateArgs<ExtArgs>>
    ): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserPreferences.
     *     @param {UserPreferenceCreateManyArgs} args - Arguments to create many UserPreferences.
     *     @example
     *     // Create many UserPreferences
     *     const userPreference = await prisma.userPreference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPreferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPreference.
     * @param {UserPreferenceDeleteArgs} args - Arguments to delete one UserPreference.
     * @example
     * // Delete one UserPreference
     * const UserPreference = await prisma.userPreference.delete({
     *   where: {
     *     // ... filter to delete one UserPreference
     *   }
     * })
     * 
    **/
    delete<T extends UserPreferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferenceDeleteArgs<ExtArgs>>
    ): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserPreference.
     * @param {UserPreferenceUpdateArgs} args - Arguments to update one UserPreference.
     * @example
     * // Update one UserPreference
     * const userPreference = await prisma.userPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPreferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferenceUpdateArgs<ExtArgs>>
    ): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferenceDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPreferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreference = await prisma.userPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPreferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPreference.
     * @param {UserPreferenceUpsertArgs} args - Arguments to update or create a UserPreference.
     * @example
     * // Update or create a UserPreference
     * const userPreference = await prisma.userPreference.upsert({
     *   create: {
     *     // ... data to create a UserPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreference we want to update
     *   }
     * })
    **/
    upsert<T extends UserPreferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferenceUpsertArgs<ExtArgs>>
    ): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreference.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferenceCountArgs>(
      args?: Subset<T, UserPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferenceAggregateArgs>(args: Subset<T, UserPreferenceAggregateArgs>): Prisma.PrismaPromise<GetUserPreferenceAggregateType<T>>

    /**
     * Group by UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreference model
   */
  readonly fields: UserPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    astrology<T extends AstrologyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AstrologyDefaultArgs<ExtArgs>>): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    maritalStatus<T extends MaritalStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatusDefaultArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    preferredDiversity<T extends UserPreference$preferredDiversityArgs<ExtArgs> = {}>(args?: Subset<T, UserPreference$preferredDiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserPreference model
   */ 
  interface UserPreferenceFieldRefs {
    readonly id: FieldRef<"UserPreference", 'Int'>
    readonly userId: FieldRef<"UserPreference", 'Int'>
    readonly gender: FieldRef<"UserPreference", 'String'>
    readonly minAge: FieldRef<"UserPreference", 'Int'>
    readonly maxAge: FieldRef<"UserPreference", 'Int'>
    readonly astrologicalId: FieldRef<"UserPreference", 'Int'>
    readonly maritalStatusId: FieldRef<"UserPreference", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserPreference findUnique
   */
  export type UserPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findUniqueOrThrow
   */
  export type UserPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findFirst
   */
  export type UserPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findFirstOrThrow
   */
  export type UserPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findMany
   */
  export type UserPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference create
   */
  export type UserPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreference.
     */
    data: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
  }

  /**
   * UserPreference createMany
   */
  export type UserPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferenceCreateManyInput | UserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreference update
   */
  export type UserPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreference.
     */
    data: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
    /**
     * Choose, which UserPreference to update.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference updateMany
   */
  export type UserPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferenceWhereInput
  }

  /**
   * UserPreference upsert
   */
  export type UserPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreference to update in case it exists.
     */
    where: UserPreferenceWhereUniqueInput
    /**
     * In case the UserPreference found by the `where` argument doesn't exist, create a new UserPreference with this data.
     */
    create: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
    /**
     * In case the UserPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
  }

  /**
   * UserPreference delete
   */
  export type UserPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter which UserPreference to delete.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference deleteMany
   */
  export type UserPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferenceWhereInput
  }

  /**
   * UserPreference.preferredDiversity
   */
  export type UserPreference$preferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    where?: PreferredDiversityWhereInput
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    cursor?: PreferredDiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * UserPreference without action
   */
  export type UserPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model PreferredDiversity
   */

  export type AggregatePreferredDiversity = {
    _count: PreferredDiversityCountAggregateOutputType | null
    _avg: PreferredDiversityAvgAggregateOutputType | null
    _sum: PreferredDiversitySumAggregateOutputType | null
    _min: PreferredDiversityMinAggregateOutputType | null
    _max: PreferredDiversityMaxAggregateOutputType | null
  }

  export type PreferredDiversityAvgAggregateOutputType = {
    id: number | null
    userPreferencesId: number | null
    countryId: number | null
    cityId: number | null
    motherTongueId: number | null
    communityId: number | null
    religionId: number | null
  }

  export type PreferredDiversitySumAggregateOutputType = {
    id: number | null
    userPreferencesId: number | null
    countryId: number | null
    cityId: number | null
    motherTongueId: number | null
    communityId: number | null
    religionId: number | null
  }

  export type PreferredDiversityMinAggregateOutputType = {
    id: number | null
    userPreferencesId: number | null
    countryId: number | null
    cityId: number | null
    motherTongueId: number | null
    communityId: number | null
    religionId: number | null
  }

  export type PreferredDiversityMaxAggregateOutputType = {
    id: number | null
    userPreferencesId: number | null
    countryId: number | null
    cityId: number | null
    motherTongueId: number | null
    communityId: number | null
    religionId: number | null
  }

  export type PreferredDiversityCountAggregateOutputType = {
    id: number
    userPreferencesId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    _all: number
  }


  export type PreferredDiversityAvgAggregateInputType = {
    id?: true
    userPreferencesId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
  }

  export type PreferredDiversitySumAggregateInputType = {
    id?: true
    userPreferencesId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
  }

  export type PreferredDiversityMinAggregateInputType = {
    id?: true
    userPreferencesId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
  }

  export type PreferredDiversityMaxAggregateInputType = {
    id?: true
    userPreferencesId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
  }

  export type PreferredDiversityCountAggregateInputType = {
    id?: true
    userPreferencesId?: true
    countryId?: true
    cityId?: true
    motherTongueId?: true
    communityId?: true
    religionId?: true
    _all?: true
  }

  export type PreferredDiversityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreferredDiversity to aggregate.
     */
    where?: PreferredDiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferredDiversities to fetch.
     */
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreferredDiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferredDiversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferredDiversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreferredDiversities
    **/
    _count?: true | PreferredDiversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferredDiversityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferredDiversitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferredDiversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferredDiversityMaxAggregateInputType
  }

  export type GetPreferredDiversityAggregateType<T extends PreferredDiversityAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferredDiversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferredDiversity[P]>
      : GetScalarType<T[P], AggregatePreferredDiversity[P]>
  }




  export type PreferredDiversityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferredDiversityWhereInput
    orderBy?: PreferredDiversityOrderByWithAggregationInput | PreferredDiversityOrderByWithAggregationInput[]
    by: PreferredDiversityScalarFieldEnum[] | PreferredDiversityScalarFieldEnum
    having?: PreferredDiversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferredDiversityCountAggregateInputType | true
    _avg?: PreferredDiversityAvgAggregateInputType
    _sum?: PreferredDiversitySumAggregateInputType
    _min?: PreferredDiversityMinAggregateInputType
    _max?: PreferredDiversityMaxAggregateInputType
  }

  export type PreferredDiversityGroupByOutputType = {
    id: number
    userPreferencesId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
    _count: PreferredDiversityCountAggregateOutputType | null
    _avg: PreferredDiversityAvgAggregateOutputType | null
    _sum: PreferredDiversitySumAggregateOutputType | null
    _min: PreferredDiversityMinAggregateOutputType | null
    _max: PreferredDiversityMaxAggregateOutputType | null
  }

  type GetPreferredDiversityGroupByPayload<T extends PreferredDiversityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferredDiversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferredDiversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferredDiversityGroupByOutputType[P]>
            : GetScalarType<T[P], PreferredDiversityGroupByOutputType[P]>
        }
      >
    >


  export type PreferredDiversitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPreferencesId?: boolean
    countryId?: boolean
    cityId?: boolean
    motherTongueId?: boolean
    communityId?: boolean
    religionId?: boolean
    userPreference?: boolean | UserPreferenceDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    motherTongue?: boolean | MotherTongueDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preferredDiversity"]>

  export type PreferredDiversitySelectScalar = {
    id?: boolean
    userPreferencesId?: boolean
    countryId?: boolean
    cityId?: boolean
    motherTongueId?: boolean
    communityId?: boolean
    religionId?: boolean
  }


  export type PreferredDiversityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPreference?: boolean | UserPreferenceDefaultArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    motherTongue?: boolean | MotherTongueDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    religion?: boolean | ReligionDefaultArgs<ExtArgs>
  }


  export type $PreferredDiversityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreferredDiversity"
    objects: {
      userPreference: Prisma.$UserPreferencePayload<ExtArgs>
      country: Prisma.$CountryPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      motherTongue: Prisma.$MotherTonguePayload<ExtArgs>
      community: Prisma.$CommunityPayload<ExtArgs>
      religion: Prisma.$ReligionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userPreferencesId: number
      countryId: number
      cityId: number
      motherTongueId: number
      communityId: number
      religionId: number
    }, ExtArgs["result"]["preferredDiversity"]>
    composites: {}
  }


  type PreferredDiversityGetPayload<S extends boolean | null | undefined | PreferredDiversityDefaultArgs> = $Result.GetResult<Prisma.$PreferredDiversityPayload, S>

  type PreferredDiversityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PreferredDiversityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PreferredDiversityCountAggregateInputType | true
    }

  export interface PreferredDiversityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreferredDiversity'], meta: { name: 'PreferredDiversity' } }
    /**
     * Find zero or one PreferredDiversity that matches the filter.
     * @param {PreferredDiversityFindUniqueArgs} args - Arguments to find a PreferredDiversity
     * @example
     * // Get one PreferredDiversity
     * const preferredDiversity = await prisma.preferredDiversity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PreferredDiversityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PreferredDiversityFindUniqueArgs<ExtArgs>>
    ): Prisma__PreferredDiversityClient<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PreferredDiversity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PreferredDiversityFindUniqueOrThrowArgs} args - Arguments to find a PreferredDiversity
     * @example
     * // Get one PreferredDiversity
     * const preferredDiversity = await prisma.preferredDiversity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PreferredDiversityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferredDiversityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PreferredDiversityClient<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PreferredDiversity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferredDiversityFindFirstArgs} args - Arguments to find a PreferredDiversity
     * @example
     * // Get one PreferredDiversity
     * const preferredDiversity = await prisma.preferredDiversity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PreferredDiversityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferredDiversityFindFirstArgs<ExtArgs>>
    ): Prisma__PreferredDiversityClient<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PreferredDiversity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferredDiversityFindFirstOrThrowArgs} args - Arguments to find a PreferredDiversity
     * @example
     * // Get one PreferredDiversity
     * const preferredDiversity = await prisma.preferredDiversity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PreferredDiversityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferredDiversityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PreferredDiversityClient<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PreferredDiversities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferredDiversityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreferredDiversities
     * const preferredDiversities = await prisma.preferredDiversity.findMany()
     * 
     * // Get first 10 PreferredDiversities
     * const preferredDiversities = await prisma.preferredDiversity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preferredDiversityWithIdOnly = await prisma.preferredDiversity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PreferredDiversityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferredDiversityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PreferredDiversity.
     * @param {PreferredDiversityCreateArgs} args - Arguments to create a PreferredDiversity.
     * @example
     * // Create one PreferredDiversity
     * const PreferredDiversity = await prisma.preferredDiversity.create({
     *   data: {
     *     // ... data to create a PreferredDiversity
     *   }
     * })
     * 
    **/
    create<T extends PreferredDiversityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PreferredDiversityCreateArgs<ExtArgs>>
    ): Prisma__PreferredDiversityClient<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PreferredDiversities.
     *     @param {PreferredDiversityCreateManyArgs} args - Arguments to create many PreferredDiversities.
     *     @example
     *     // Create many PreferredDiversities
     *     const preferredDiversity = await prisma.preferredDiversity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PreferredDiversityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferredDiversityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PreferredDiversity.
     * @param {PreferredDiversityDeleteArgs} args - Arguments to delete one PreferredDiversity.
     * @example
     * // Delete one PreferredDiversity
     * const PreferredDiversity = await prisma.preferredDiversity.delete({
     *   where: {
     *     // ... filter to delete one PreferredDiversity
     *   }
     * })
     * 
    **/
    delete<T extends PreferredDiversityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PreferredDiversityDeleteArgs<ExtArgs>>
    ): Prisma__PreferredDiversityClient<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PreferredDiversity.
     * @param {PreferredDiversityUpdateArgs} args - Arguments to update one PreferredDiversity.
     * @example
     * // Update one PreferredDiversity
     * const preferredDiversity = await prisma.preferredDiversity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PreferredDiversityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PreferredDiversityUpdateArgs<ExtArgs>>
    ): Prisma__PreferredDiversityClient<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PreferredDiversities.
     * @param {PreferredDiversityDeleteManyArgs} args - Arguments to filter PreferredDiversities to delete.
     * @example
     * // Delete a few PreferredDiversities
     * const { count } = await prisma.preferredDiversity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PreferredDiversityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PreferredDiversityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreferredDiversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferredDiversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreferredDiversities
     * const preferredDiversity = await prisma.preferredDiversity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PreferredDiversityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PreferredDiversityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PreferredDiversity.
     * @param {PreferredDiversityUpsertArgs} args - Arguments to update or create a PreferredDiversity.
     * @example
     * // Update or create a PreferredDiversity
     * const preferredDiversity = await prisma.preferredDiversity.upsert({
     *   create: {
     *     // ... data to create a PreferredDiversity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreferredDiversity we want to update
     *   }
     * })
    **/
    upsert<T extends PreferredDiversityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PreferredDiversityUpsertArgs<ExtArgs>>
    ): Prisma__PreferredDiversityClient<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PreferredDiversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferredDiversityCountArgs} args - Arguments to filter PreferredDiversities to count.
     * @example
     * // Count the number of PreferredDiversities
     * const count = await prisma.preferredDiversity.count({
     *   where: {
     *     // ... the filter for the PreferredDiversities we want to count
     *   }
     * })
    **/
    count<T extends PreferredDiversityCountArgs>(
      args?: Subset<T, PreferredDiversityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferredDiversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreferredDiversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferredDiversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferredDiversityAggregateArgs>(args: Subset<T, PreferredDiversityAggregateArgs>): Prisma.PrismaPromise<GetPreferredDiversityAggregateType<T>>

    /**
     * Group by PreferredDiversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferredDiversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreferredDiversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferredDiversityGroupByArgs['orderBy'] }
        : { orderBy?: PreferredDiversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreferredDiversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferredDiversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreferredDiversity model
   */
  readonly fields: PreferredDiversityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreferredDiversity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreferredDiversityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userPreference<T extends UserPreferenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPreferenceDefaultArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    motherTongue<T extends MotherTongueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MotherTongueDefaultArgs<ExtArgs>>): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    religion<T extends ReligionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReligionDefaultArgs<ExtArgs>>): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PreferredDiversity model
   */ 
  interface PreferredDiversityFieldRefs {
    readonly id: FieldRef<"PreferredDiversity", 'Int'>
    readonly userPreferencesId: FieldRef<"PreferredDiversity", 'Int'>
    readonly countryId: FieldRef<"PreferredDiversity", 'Int'>
    readonly cityId: FieldRef<"PreferredDiversity", 'Int'>
    readonly motherTongueId: FieldRef<"PreferredDiversity", 'Int'>
    readonly communityId: FieldRef<"PreferredDiversity", 'Int'>
    readonly religionId: FieldRef<"PreferredDiversity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PreferredDiversity findUnique
   */
  export type PreferredDiversityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * Filter, which PreferredDiversity to fetch.
     */
    where: PreferredDiversityWhereUniqueInput
  }

  /**
   * PreferredDiversity findUniqueOrThrow
   */
  export type PreferredDiversityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * Filter, which PreferredDiversity to fetch.
     */
    where: PreferredDiversityWhereUniqueInput
  }

  /**
   * PreferredDiversity findFirst
   */
  export type PreferredDiversityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * Filter, which PreferredDiversity to fetch.
     */
    where?: PreferredDiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferredDiversities to fetch.
     */
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreferredDiversities.
     */
    cursor?: PreferredDiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferredDiversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferredDiversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreferredDiversities.
     */
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * PreferredDiversity findFirstOrThrow
   */
  export type PreferredDiversityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * Filter, which PreferredDiversity to fetch.
     */
    where?: PreferredDiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferredDiversities to fetch.
     */
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreferredDiversities.
     */
    cursor?: PreferredDiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferredDiversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferredDiversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreferredDiversities.
     */
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * PreferredDiversity findMany
   */
  export type PreferredDiversityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * Filter, which PreferredDiversities to fetch.
     */
    where?: PreferredDiversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferredDiversities to fetch.
     */
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreferredDiversities.
     */
    cursor?: PreferredDiversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferredDiversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferredDiversities.
     */
    skip?: number
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * PreferredDiversity create
   */
  export type PreferredDiversityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * The data needed to create a PreferredDiversity.
     */
    data: XOR<PreferredDiversityCreateInput, PreferredDiversityUncheckedCreateInput>
  }

  /**
   * PreferredDiversity createMany
   */
  export type PreferredDiversityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreferredDiversities.
     */
    data: PreferredDiversityCreateManyInput | PreferredDiversityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PreferredDiversity update
   */
  export type PreferredDiversityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * The data needed to update a PreferredDiversity.
     */
    data: XOR<PreferredDiversityUpdateInput, PreferredDiversityUncheckedUpdateInput>
    /**
     * Choose, which PreferredDiversity to update.
     */
    where: PreferredDiversityWhereUniqueInput
  }

  /**
   * PreferredDiversity updateMany
   */
  export type PreferredDiversityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreferredDiversities.
     */
    data: XOR<PreferredDiversityUpdateManyMutationInput, PreferredDiversityUncheckedUpdateManyInput>
    /**
     * Filter which PreferredDiversities to update
     */
    where?: PreferredDiversityWhereInput
  }

  /**
   * PreferredDiversity upsert
   */
  export type PreferredDiversityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * The filter to search for the PreferredDiversity to update in case it exists.
     */
    where: PreferredDiversityWhereUniqueInput
    /**
     * In case the PreferredDiversity found by the `where` argument doesn't exist, create a new PreferredDiversity with this data.
     */
    create: XOR<PreferredDiversityCreateInput, PreferredDiversityUncheckedCreateInput>
    /**
     * In case the PreferredDiversity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreferredDiversityUpdateInput, PreferredDiversityUncheckedUpdateInput>
  }

  /**
   * PreferredDiversity delete
   */
  export type PreferredDiversityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    /**
     * Filter which PreferredDiversity to delete.
     */
    where: PreferredDiversityWhereUniqueInput
  }

  /**
   * PreferredDiversity deleteMany
   */
  export type PreferredDiversityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreferredDiversities to delete
     */
    where?: PreferredDiversityWhereInput
  }

  /**
   * PreferredDiversity without action
   */
  export type PreferredDiversityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
  }


  /**
   * Model MaritalStatus
   */

  export type AggregateMaritalStatus = {
    _count: MaritalStatusCountAggregateOutputType | null
    _avg: MaritalStatusAvgAggregateOutputType | null
    _sum: MaritalStatusSumAggregateOutputType | null
    _min: MaritalStatusMinAggregateOutputType | null
    _max: MaritalStatusMaxAggregateOutputType | null
  }

  export type MaritalStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type MaritalStatusSumAggregateOutputType = {
    id: number | null
  }

  export type MaritalStatusMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type MaritalStatusMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type MaritalStatusCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type MaritalStatusAvgAggregateInputType = {
    id?: true
  }

  export type MaritalStatusSumAggregateInputType = {
    id?: true
  }

  export type MaritalStatusMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type MaritalStatusMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type MaritalStatusCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type MaritalStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaritalStatus to aggregate.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaritalStatuses
    **/
    _count?: true | MaritalStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaritalStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaritalStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaritalStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaritalStatusMaxAggregateInputType
  }

  export type GetMaritalStatusAggregateType<T extends MaritalStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMaritalStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaritalStatus[P]>
      : GetScalarType<T[P], AggregateMaritalStatus[P]>
  }




  export type MaritalStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaritalStatusWhereInput
    orderBy?: MaritalStatusOrderByWithAggregationInput | MaritalStatusOrderByWithAggregationInput[]
    by: MaritalStatusScalarFieldEnum[] | MaritalStatusScalarFieldEnum
    having?: MaritalStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaritalStatusCountAggregateInputType | true
    _avg?: MaritalStatusAvgAggregateInputType
    _sum?: MaritalStatusSumAggregateInputType
    _min?: MaritalStatusMinAggregateInputType
    _max?: MaritalStatusMaxAggregateInputType
  }

  export type MaritalStatusGroupByOutputType = {
    id: number
    title: string
    _count: MaritalStatusCountAggregateOutputType | null
    _avg: MaritalStatusAvgAggregateOutputType | null
    _sum: MaritalStatusSumAggregateOutputType | null
    _min: MaritalStatusMinAggregateOutputType | null
    _max: MaritalStatusMaxAggregateOutputType | null
  }

  type GetMaritalStatusGroupByPayload<T extends MaritalStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaritalStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaritalStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaritalStatusGroupByOutputType[P]>
            : GetScalarType<T[P], MaritalStatusGroupByOutputType[P]>
        }
      >
    >


  export type MaritalStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    users?: boolean | MaritalStatus$usersArgs<ExtArgs>
    UserPreference?: boolean | MaritalStatus$UserPreferenceArgs<ExtArgs>
    _count?: boolean | MaritalStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maritalStatus"]>

  export type MaritalStatusSelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type MaritalStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MaritalStatus$usersArgs<ExtArgs>
    UserPreference?: boolean | MaritalStatus$UserPreferenceArgs<ExtArgs>
    _count?: boolean | MaritalStatusCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MaritalStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaritalStatus"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      UserPreference: Prisma.$UserPreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["maritalStatus"]>
    composites: {}
  }


  type MaritalStatusGetPayload<S extends boolean | null | undefined | MaritalStatusDefaultArgs> = $Result.GetResult<Prisma.$MaritalStatusPayload, S>

  type MaritalStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaritalStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaritalStatusCountAggregateInputType | true
    }

  export interface MaritalStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaritalStatus'], meta: { name: 'MaritalStatus' } }
    /**
     * Find zero or one MaritalStatus that matches the filter.
     * @param {MaritalStatusFindUniqueArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaritalStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MaritalStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MaritalStatusFindUniqueOrThrowArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MaritalStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MaritalStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindFirstArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaritalStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusFindFirstArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MaritalStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindFirstOrThrowArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MaritalStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MaritalStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaritalStatuses
     * const maritalStatuses = await prisma.maritalStatus.findMany()
     * 
     * // Get first 10 MaritalStatuses
     * const maritalStatuses = await prisma.maritalStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maritalStatusWithIdOnly = await prisma.maritalStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MaritalStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MaritalStatus.
     * @param {MaritalStatusCreateArgs} args - Arguments to create a MaritalStatus.
     * @example
     * // Create one MaritalStatus
     * const MaritalStatus = await prisma.maritalStatus.create({
     *   data: {
     *     // ... data to create a MaritalStatus
     *   }
     * })
     * 
    **/
    create<T extends MaritalStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusCreateArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MaritalStatuses.
     *     @param {MaritalStatusCreateManyArgs} args - Arguments to create many MaritalStatuses.
     *     @example
     *     // Create many MaritalStatuses
     *     const maritalStatus = await prisma.maritalStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaritalStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaritalStatus.
     * @param {MaritalStatusDeleteArgs} args - Arguments to delete one MaritalStatus.
     * @example
     * // Delete one MaritalStatus
     * const MaritalStatus = await prisma.maritalStatus.delete({
     *   where: {
     *     // ... filter to delete one MaritalStatus
     *   }
     * })
     * 
    **/
    delete<T extends MaritalStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusDeleteArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MaritalStatus.
     * @param {MaritalStatusUpdateArgs} args - Arguments to update one MaritalStatus.
     * @example
     * // Update one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaritalStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusUpdateArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MaritalStatuses.
     * @param {MaritalStatusDeleteManyArgs} args - Arguments to filter MaritalStatuses to delete.
     * @example
     * // Delete a few MaritalStatuses
     * const { count } = await prisma.maritalStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaritalStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaritalStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaritalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaritalStatuses
     * const maritalStatus = await prisma.maritalStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaritalStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaritalStatus.
     * @param {MaritalStatusUpsertArgs} args - Arguments to update or create a MaritalStatus.
     * @example
     * // Update or create a MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.upsert({
     *   create: {
     *     // ... data to create a MaritalStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaritalStatus we want to update
     *   }
     * })
    **/
    upsert<T extends MaritalStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MaritalStatusUpsertArgs<ExtArgs>>
    ): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MaritalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusCountArgs} args - Arguments to filter MaritalStatuses to count.
     * @example
     * // Count the number of MaritalStatuses
     * const count = await prisma.maritalStatus.count({
     *   where: {
     *     // ... the filter for the MaritalStatuses we want to count
     *   }
     * })
    **/
    count<T extends MaritalStatusCountArgs>(
      args?: Subset<T, MaritalStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaritalStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaritalStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaritalStatusAggregateArgs>(args: Subset<T, MaritalStatusAggregateArgs>): Prisma.PrismaPromise<GetMaritalStatusAggregateType<T>>

    /**
     * Group by MaritalStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaritalStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaritalStatusGroupByArgs['orderBy'] }
        : { orderBy?: MaritalStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaritalStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaritalStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaritalStatus model
   */
  readonly fields: MaritalStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaritalStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaritalStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends MaritalStatus$usersArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatus$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    UserPreference<T extends MaritalStatus$UserPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatus$UserPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MaritalStatus model
   */ 
  interface MaritalStatusFieldRefs {
    readonly id: FieldRef<"MaritalStatus", 'Int'>
    readonly title: FieldRef<"MaritalStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaritalStatus findUnique
   */
  export type MaritalStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus findUniqueOrThrow
   */
  export type MaritalStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus findFirst
   */
  export type MaritalStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaritalStatuses.
     */
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus findFirstOrThrow
   */
  export type MaritalStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaritalStatuses.
     */
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus findMany
   */
  export type MaritalStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatuses to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus create
   */
  export type MaritalStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a MaritalStatus.
     */
    data: XOR<MaritalStatusCreateInput, MaritalStatusUncheckedCreateInput>
  }

  /**
   * MaritalStatus createMany
   */
  export type MaritalStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaritalStatuses.
     */
    data: MaritalStatusCreateManyInput | MaritalStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaritalStatus update
   */
  export type MaritalStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a MaritalStatus.
     */
    data: XOR<MaritalStatusUpdateInput, MaritalStatusUncheckedUpdateInput>
    /**
     * Choose, which MaritalStatus to update.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus updateMany
   */
  export type MaritalStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaritalStatuses.
     */
    data: XOR<MaritalStatusUpdateManyMutationInput, MaritalStatusUncheckedUpdateManyInput>
    /**
     * Filter which MaritalStatuses to update
     */
    where?: MaritalStatusWhereInput
  }

  /**
   * MaritalStatus upsert
   */
  export type MaritalStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the MaritalStatus to update in case it exists.
     */
    where: MaritalStatusWhereUniqueInput
    /**
     * In case the MaritalStatus found by the `where` argument doesn't exist, create a new MaritalStatus with this data.
     */
    create: XOR<MaritalStatusCreateInput, MaritalStatusUncheckedCreateInput>
    /**
     * In case the MaritalStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaritalStatusUpdateInput, MaritalStatusUncheckedUpdateInput>
  }

  /**
   * MaritalStatus delete
   */
  export type MaritalStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter which MaritalStatus to delete.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus deleteMany
   */
  export type MaritalStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaritalStatuses to delete
     */
    where?: MaritalStatusWhereInput
  }

  /**
   * MaritalStatus.users
   */
  export type MaritalStatus$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * MaritalStatus.UserPreference
   */
  export type MaritalStatus$UserPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    where?: UserPreferenceWhereInput
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    cursor?: UserPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * MaritalStatus without action
   */
  export type MaritalStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
  }


  /**
   * Model Religion
   */

  export type AggregateReligion = {
    _count: ReligionCountAggregateOutputType | null
    _avg: ReligionAvgAggregateOutputType | null
    _sum: ReligionSumAggregateOutputType | null
    _min: ReligionMinAggregateOutputType | null
    _max: ReligionMaxAggregateOutputType | null
  }

  export type ReligionAvgAggregateOutputType = {
    id: number | null
  }

  export type ReligionSumAggregateOutputType = {
    id: number | null
  }

  export type ReligionMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type ReligionMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type ReligionCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type ReligionAvgAggregateInputType = {
    id?: true
  }

  export type ReligionSumAggregateInputType = {
    id?: true
  }

  export type ReligionMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type ReligionMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type ReligionCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type ReligionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Religion to aggregate.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Religions
    **/
    _count?: true | ReligionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReligionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReligionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReligionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReligionMaxAggregateInputType
  }

  export type GetReligionAggregateType<T extends ReligionAggregateArgs> = {
        [P in keyof T & keyof AggregateReligion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReligion[P]>
      : GetScalarType<T[P], AggregateReligion[P]>
  }




  export type ReligionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReligionWhereInput
    orderBy?: ReligionOrderByWithAggregationInput | ReligionOrderByWithAggregationInput[]
    by: ReligionScalarFieldEnum[] | ReligionScalarFieldEnum
    having?: ReligionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReligionCountAggregateInputType | true
    _avg?: ReligionAvgAggregateInputType
    _sum?: ReligionSumAggregateInputType
    _min?: ReligionMinAggregateInputType
    _max?: ReligionMaxAggregateInputType
  }

  export type ReligionGroupByOutputType = {
    id: number
    title: string
    _count: ReligionCountAggregateOutputType | null
    _avg: ReligionAvgAggregateOutputType | null
    _sum: ReligionSumAggregateOutputType | null
    _min: ReligionMinAggregateOutputType | null
    _max: ReligionMaxAggregateOutputType | null
  }

  type GetReligionGroupByPayload<T extends ReligionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReligionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReligionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReligionGroupByOutputType[P]>
            : GetScalarType<T[P], ReligionGroupByOutputType[P]>
        }
      >
    >


  export type ReligionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    Diversity?: boolean | Religion$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | Religion$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | ReligionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["religion"]>

  export type ReligionSelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type ReligionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | Religion$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | Religion$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | ReligionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ReligionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Religion"
    objects: {
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      PreferredDiversity: Prisma.$PreferredDiversityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["religion"]>
    composites: {}
  }


  type ReligionGetPayload<S extends boolean | null | undefined | ReligionDefaultArgs> = $Result.GetResult<Prisma.$ReligionPayload, S>

  type ReligionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReligionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReligionCountAggregateInputType | true
    }

  export interface ReligionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Religion'], meta: { name: 'Religion' } }
    /**
     * Find zero or one Religion that matches the filter.
     * @param {ReligionFindUniqueArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReligionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionFindUniqueArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Religion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReligionFindUniqueOrThrowArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReligionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Religion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindFirstArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReligionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionFindFirstArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Religion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindFirstOrThrowArgs} args - Arguments to find a Religion
     * @example
     * // Get one Religion
     * const religion = await prisma.religion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReligionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Religions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Religions
     * const religions = await prisma.religion.findMany()
     * 
     * // Get first 10 Religions
     * const religions = await prisma.religion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const religionWithIdOnly = await prisma.religion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReligionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Religion.
     * @param {ReligionCreateArgs} args - Arguments to create a Religion.
     * @example
     * // Create one Religion
     * const Religion = await prisma.religion.create({
     *   data: {
     *     // ... data to create a Religion
     *   }
     * })
     * 
    **/
    create<T extends ReligionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionCreateArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Religions.
     *     @param {ReligionCreateManyArgs} args - Arguments to create many Religions.
     *     @example
     *     // Create many Religions
     *     const religion = await prisma.religion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReligionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Religion.
     * @param {ReligionDeleteArgs} args - Arguments to delete one Religion.
     * @example
     * // Delete one Religion
     * const Religion = await prisma.religion.delete({
     *   where: {
     *     // ... filter to delete one Religion
     *   }
     * })
     * 
    **/
    delete<T extends ReligionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionDeleteArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Religion.
     * @param {ReligionUpdateArgs} args - Arguments to update one Religion.
     * @example
     * // Update one Religion
     * const religion = await prisma.religion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReligionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionUpdateArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Religions.
     * @param {ReligionDeleteManyArgs} args - Arguments to filter Religions to delete.
     * @example
     * // Delete a few Religions
     * const { count } = await prisma.religion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReligionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReligionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Religions
     * const religion = await prisma.religion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReligionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Religion.
     * @param {ReligionUpsertArgs} args - Arguments to update or create a Religion.
     * @example
     * // Update or create a Religion
     * const religion = await prisma.religion.upsert({
     *   create: {
     *     // ... data to create a Religion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Religion we want to update
     *   }
     * })
    **/
    upsert<T extends ReligionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReligionUpsertArgs<ExtArgs>>
    ): Prisma__ReligionClient<$Result.GetResult<Prisma.$ReligionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionCountArgs} args - Arguments to filter Religions to count.
     * @example
     * // Count the number of Religions
     * const count = await prisma.religion.count({
     *   where: {
     *     // ... the filter for the Religions we want to count
     *   }
     * })
    **/
    count<T extends ReligionCountArgs>(
      args?: Subset<T, ReligionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReligionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Religion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReligionAggregateArgs>(args: Subset<T, ReligionAggregateArgs>): Prisma.PrismaPromise<GetReligionAggregateType<T>>

    /**
     * Group by Religion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReligionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReligionGroupByArgs['orderBy'] }
        : { orderBy?: ReligionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReligionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReligionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Religion model
   */
  readonly fields: ReligionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Religion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReligionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Diversity<T extends Religion$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, Religion$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    PreferredDiversity<T extends Religion$PreferredDiversityArgs<ExtArgs> = {}>(args?: Subset<T, Religion$PreferredDiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Religion model
   */ 
  interface ReligionFieldRefs {
    readonly id: FieldRef<"Religion", 'Int'>
    readonly title: FieldRef<"Religion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Religion findUnique
   */
  export type ReligionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion findUniqueOrThrow
   */
  export type ReligionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion findFirst
   */
  export type ReligionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Religions.
     */
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion findFirstOrThrow
   */
  export type ReligionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religion to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Religions.
     */
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion findMany
   */
  export type ReligionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter, which Religions to fetch.
     */
    where?: ReligionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Religions to fetch.
     */
    orderBy?: ReligionOrderByWithRelationInput | ReligionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Religions.
     */
    cursor?: ReligionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Religions.
     */
    skip?: number
    distinct?: ReligionScalarFieldEnum | ReligionScalarFieldEnum[]
  }

  /**
   * Religion create
   */
  export type ReligionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The data needed to create a Religion.
     */
    data: XOR<ReligionCreateInput, ReligionUncheckedCreateInput>
  }

  /**
   * Religion createMany
   */
  export type ReligionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Religions.
     */
    data: ReligionCreateManyInput | ReligionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Religion update
   */
  export type ReligionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The data needed to update a Religion.
     */
    data: XOR<ReligionUpdateInput, ReligionUncheckedUpdateInput>
    /**
     * Choose, which Religion to update.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion updateMany
   */
  export type ReligionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Religions.
     */
    data: XOR<ReligionUpdateManyMutationInput, ReligionUncheckedUpdateManyInput>
    /**
     * Filter which Religions to update
     */
    where?: ReligionWhereInput
  }

  /**
   * Religion upsert
   */
  export type ReligionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * The filter to search for the Religion to update in case it exists.
     */
    where: ReligionWhereUniqueInput
    /**
     * In case the Religion found by the `where` argument doesn't exist, create a new Religion with this data.
     */
    create: XOR<ReligionCreateInput, ReligionUncheckedCreateInput>
    /**
     * In case the Religion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReligionUpdateInput, ReligionUncheckedUpdateInput>
  }

  /**
   * Religion delete
   */
  export type ReligionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
    /**
     * Filter which Religion to delete.
     */
    where: ReligionWhereUniqueInput
  }

  /**
   * Religion deleteMany
   */
  export type ReligionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Religions to delete
     */
    where?: ReligionWhereInput
  }

  /**
   * Religion.Diversity
   */
  export type Religion$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Religion.PreferredDiversity
   */
  export type Religion$PreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    where?: PreferredDiversityWhereInput
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    cursor?: PreferredDiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * Religion without action
   */
  export type ReligionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Religion
     */
    select?: ReligionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    title: string
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    cities?: boolean | Country$citiesArgs<ExtArgs>
    Diversity?: boolean | Country$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | Country$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Country$citiesArgs<ExtArgs>
    Diversity?: boolean | Country$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | Country$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      PreferredDiversity: Prisma.$PreferredDiversityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["country"]>
    composites: {}
  }


  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryCreateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cities<T extends Country$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Country$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findMany'> | Null>;

    Diversity<T extends Country$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, Country$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    PreferredDiversity<T extends Country$PreferredDiversityArgs<ExtArgs> = {}>(args?: Subset<T, Country$PreferredDiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly title: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }

  /**
   * Country.cities
   */
  export type Country$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Country.Diversity
   */
  export type Country$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Country.PreferredDiversity
   */
  export type Country$PreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    where?: PreferredDiversityWhereInput
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    cursor?: PreferredDiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    title: string | null
    countryId: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    title: string | null
    countryId: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    title: number
    countryId: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    title?: true
    countryId?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    title?: true
    countryId?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    title?: true
    countryId?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: number
    title: string
    countryId: number
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    Diversity?: boolean | City$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | City$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    title?: boolean
    countryId?: boolean
  }


  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    Diversity?: boolean | City$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | City$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      PreferredDiversity: Prisma.$PreferredDiversityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      countryId: number
    }, ExtArgs["result"]["city"]>
    composites: {}
  }


  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CityCreateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CityDeleteArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpsertArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Diversity<T extends City$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, City$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    PreferredDiversity<T extends City$PreferredDiversityArgs<ExtArgs> = {}>(args?: Subset<T, City$PreferredDiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'Int'>
    readonly title: FieldRef<"City", 'String'>
    readonly countryId: FieldRef<"City", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }

  /**
   * City.Diversity
   */
  export type City$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * City.PreferredDiversity
   */
  export type City$PreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    where?: PreferredDiversityWhereInput
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    cursor?: PreferredDiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    id: number | null
  }

  export type CommunitySumAggregateOutputType = {
    id: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    id?: true
  }

  export type CommunitySumAggregateInputType = {
    id?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: number
    title: string
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    Diversity?: boolean | Community$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | Community$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | Community$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | Community$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      PreferredDiversity: Prisma.$PreferredDiversityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["community"]>
    composites: {}
  }


  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Community that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
    **/
    create<T extends CommunityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Communities.
     *     @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     *     @example
     *     // Create many Communities
     *     const community = await prisma.community.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
    **/
    delete<T extends CommunityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>
    ): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Diversity<T extends Community$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, Community$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    PreferredDiversity<T extends Community$PreferredDiversityArgs<ExtArgs> = {}>(args?: Subset<T, Community$PreferredDiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Community model
   */ 
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'Int'>
    readonly title: FieldRef<"Community", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
  }

  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
  }

  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
  }

  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
  }

  /**
   * Community.Diversity
   */
  export type Community$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * Community.PreferredDiversity
   */
  export type Community$PreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    where?: PreferredDiversityWhereInput
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    cursor?: PreferredDiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
  }


  /**
   * Model MotherTongue
   */

  export type AggregateMotherTongue = {
    _count: MotherTongueCountAggregateOutputType | null
    _avg: MotherTongueAvgAggregateOutputType | null
    _sum: MotherTongueSumAggregateOutputType | null
    _min: MotherTongueMinAggregateOutputType | null
    _max: MotherTongueMaxAggregateOutputType | null
  }

  export type MotherTongueAvgAggregateOutputType = {
    id: number | null
  }

  export type MotherTongueSumAggregateOutputType = {
    id: number | null
  }

  export type MotherTongueMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type MotherTongueMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type MotherTongueCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type MotherTongueAvgAggregateInputType = {
    id?: true
  }

  export type MotherTongueSumAggregateInputType = {
    id?: true
  }

  export type MotherTongueMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type MotherTongueMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type MotherTongueCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type MotherTongueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MotherTongue to aggregate.
     */
    where?: MotherTongueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MotherTongues to fetch.
     */
    orderBy?: MotherTongueOrderByWithRelationInput | MotherTongueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MotherTongueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MotherTongues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MotherTongues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MotherTongues
    **/
    _count?: true | MotherTongueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotherTongueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotherTongueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotherTongueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotherTongueMaxAggregateInputType
  }

  export type GetMotherTongueAggregateType<T extends MotherTongueAggregateArgs> = {
        [P in keyof T & keyof AggregateMotherTongue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotherTongue[P]>
      : GetScalarType<T[P], AggregateMotherTongue[P]>
  }




  export type MotherTongueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MotherTongueWhereInput
    orderBy?: MotherTongueOrderByWithAggregationInput | MotherTongueOrderByWithAggregationInput[]
    by: MotherTongueScalarFieldEnum[] | MotherTongueScalarFieldEnum
    having?: MotherTongueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotherTongueCountAggregateInputType | true
    _avg?: MotherTongueAvgAggregateInputType
    _sum?: MotherTongueSumAggregateInputType
    _min?: MotherTongueMinAggregateInputType
    _max?: MotherTongueMaxAggregateInputType
  }

  export type MotherTongueGroupByOutputType = {
    id: number
    title: string
    _count: MotherTongueCountAggregateOutputType | null
    _avg: MotherTongueAvgAggregateOutputType | null
    _sum: MotherTongueSumAggregateOutputType | null
    _min: MotherTongueMinAggregateOutputType | null
    _max: MotherTongueMaxAggregateOutputType | null
  }

  type GetMotherTongueGroupByPayload<T extends MotherTongueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotherTongueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotherTongueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotherTongueGroupByOutputType[P]>
            : GetScalarType<T[P], MotherTongueGroupByOutputType[P]>
        }
      >
    >


  export type MotherTongueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    Diversity?: boolean | MotherTongue$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | MotherTongue$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | MotherTongueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motherTongue"]>

  export type MotherTongueSelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type MotherTongueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Diversity?: boolean | MotherTongue$DiversityArgs<ExtArgs>
    PreferredDiversity?: boolean | MotherTongue$PreferredDiversityArgs<ExtArgs>
    _count?: boolean | MotherTongueCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MotherTonguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MotherTongue"
    objects: {
      Diversity: Prisma.$DiversityPayload<ExtArgs>[]
      PreferredDiversity: Prisma.$PreferredDiversityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["motherTongue"]>
    composites: {}
  }


  type MotherTongueGetPayload<S extends boolean | null | undefined | MotherTongueDefaultArgs> = $Result.GetResult<Prisma.$MotherTonguePayload, S>

  type MotherTongueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MotherTongueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MotherTongueCountAggregateInputType | true
    }

  export interface MotherTongueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MotherTongue'], meta: { name: 'MotherTongue' } }
    /**
     * Find zero or one MotherTongue that matches the filter.
     * @param {MotherTongueFindUniqueArgs} args - Arguments to find a MotherTongue
     * @example
     * // Get one MotherTongue
     * const motherTongue = await prisma.motherTongue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MotherTongueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueFindUniqueArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MotherTongue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MotherTongueFindUniqueOrThrowArgs} args - Arguments to find a MotherTongue
     * @example
     * // Get one MotherTongue
     * const motherTongue = await prisma.motherTongue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MotherTongueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MotherTongue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueFindFirstArgs} args - Arguments to find a MotherTongue
     * @example
     * // Get one MotherTongue
     * const motherTongue = await prisma.motherTongue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MotherTongueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueFindFirstArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MotherTongue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueFindFirstOrThrowArgs} args - Arguments to find a MotherTongue
     * @example
     * // Get one MotherTongue
     * const motherTongue = await prisma.motherTongue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MotherTongueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MotherTongues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MotherTongues
     * const motherTongues = await prisma.motherTongue.findMany()
     * 
     * // Get first 10 MotherTongues
     * const motherTongues = await prisma.motherTongue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motherTongueWithIdOnly = await prisma.motherTongue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MotherTongueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MotherTongue.
     * @param {MotherTongueCreateArgs} args - Arguments to create a MotherTongue.
     * @example
     * // Create one MotherTongue
     * const MotherTongue = await prisma.motherTongue.create({
     *   data: {
     *     // ... data to create a MotherTongue
     *   }
     * })
     * 
    **/
    create<T extends MotherTongueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueCreateArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MotherTongues.
     *     @param {MotherTongueCreateManyArgs} args - Arguments to create many MotherTongues.
     *     @example
     *     // Create many MotherTongues
     *     const motherTongue = await prisma.motherTongue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MotherTongueCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MotherTongue.
     * @param {MotherTongueDeleteArgs} args - Arguments to delete one MotherTongue.
     * @example
     * // Delete one MotherTongue
     * const MotherTongue = await prisma.motherTongue.delete({
     *   where: {
     *     // ... filter to delete one MotherTongue
     *   }
     * })
     * 
    **/
    delete<T extends MotherTongueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueDeleteArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MotherTongue.
     * @param {MotherTongueUpdateArgs} args - Arguments to update one MotherTongue.
     * @example
     * // Update one MotherTongue
     * const motherTongue = await prisma.motherTongue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MotherTongueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueUpdateArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MotherTongues.
     * @param {MotherTongueDeleteManyArgs} args - Arguments to filter MotherTongues to delete.
     * @example
     * // Delete a few MotherTongues
     * const { count } = await prisma.motherTongue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MotherTongueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MotherTongueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MotherTongues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MotherTongues
     * const motherTongue = await prisma.motherTongue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MotherTongueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MotherTongue.
     * @param {MotherTongueUpsertArgs} args - Arguments to update or create a MotherTongue.
     * @example
     * // Update or create a MotherTongue
     * const motherTongue = await prisma.motherTongue.upsert({
     *   create: {
     *     // ... data to create a MotherTongue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MotherTongue we want to update
     *   }
     * })
    **/
    upsert<T extends MotherTongueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MotherTongueUpsertArgs<ExtArgs>>
    ): Prisma__MotherTongueClient<$Result.GetResult<Prisma.$MotherTonguePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MotherTongues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueCountArgs} args - Arguments to filter MotherTongues to count.
     * @example
     * // Count the number of MotherTongues
     * const count = await prisma.motherTongue.count({
     *   where: {
     *     // ... the filter for the MotherTongues we want to count
     *   }
     * })
    **/
    count<T extends MotherTongueCountArgs>(
      args?: Subset<T, MotherTongueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotherTongueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MotherTongue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotherTongueAggregateArgs>(args: Subset<T, MotherTongueAggregateArgs>): Prisma.PrismaPromise<GetMotherTongueAggregateType<T>>

    /**
     * Group by MotherTongue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotherTongueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MotherTongueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MotherTongueGroupByArgs['orderBy'] }
        : { orderBy?: MotherTongueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MotherTongueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotherTongueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MotherTongue model
   */
  readonly fields: MotherTongueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MotherTongue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MotherTongueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Diversity<T extends MotherTongue$DiversityArgs<ExtArgs> = {}>(args?: Subset<T, MotherTongue$DiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    PreferredDiversity<T extends MotherTongue$PreferredDiversityArgs<ExtArgs> = {}>(args?: Subset<T, MotherTongue$PreferredDiversityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferredDiversityPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MotherTongue model
   */ 
  interface MotherTongueFieldRefs {
    readonly id: FieldRef<"MotherTongue", 'Int'>
    readonly title: FieldRef<"MotherTongue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MotherTongue findUnique
   */
  export type MotherTongueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongue to fetch.
     */
    where: MotherTongueWhereUniqueInput
  }

  /**
   * MotherTongue findUniqueOrThrow
   */
  export type MotherTongueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongue to fetch.
     */
    where: MotherTongueWhereUniqueInput
  }

  /**
   * MotherTongue findFirst
   */
  export type MotherTongueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongue to fetch.
     */
    where?: MotherTongueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MotherTongues to fetch.
     */
    orderBy?: MotherTongueOrderByWithRelationInput | MotherTongueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MotherTongues.
     */
    cursor?: MotherTongueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MotherTongues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MotherTongues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MotherTongues.
     */
    distinct?: MotherTongueScalarFieldEnum | MotherTongueScalarFieldEnum[]
  }

  /**
   * MotherTongue findFirstOrThrow
   */
  export type MotherTongueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongue to fetch.
     */
    where?: MotherTongueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MotherTongues to fetch.
     */
    orderBy?: MotherTongueOrderByWithRelationInput | MotherTongueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MotherTongues.
     */
    cursor?: MotherTongueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MotherTongues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MotherTongues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MotherTongues.
     */
    distinct?: MotherTongueScalarFieldEnum | MotherTongueScalarFieldEnum[]
  }

  /**
   * MotherTongue findMany
   */
  export type MotherTongueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter, which MotherTongues to fetch.
     */
    where?: MotherTongueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MotherTongues to fetch.
     */
    orderBy?: MotherTongueOrderByWithRelationInput | MotherTongueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MotherTongues.
     */
    cursor?: MotherTongueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MotherTongues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MotherTongues.
     */
    skip?: number
    distinct?: MotherTongueScalarFieldEnum | MotherTongueScalarFieldEnum[]
  }

  /**
   * MotherTongue create
   */
  export type MotherTongueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * The data needed to create a MotherTongue.
     */
    data: XOR<MotherTongueCreateInput, MotherTongueUncheckedCreateInput>
  }

  /**
   * MotherTongue createMany
   */
  export type MotherTongueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MotherTongues.
     */
    data: MotherTongueCreateManyInput | MotherTongueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MotherTongue update
   */
  export type MotherTongueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * The data needed to update a MotherTongue.
     */
    data: XOR<MotherTongueUpdateInput, MotherTongueUncheckedUpdateInput>
    /**
     * Choose, which MotherTongue to update.
     */
    where: MotherTongueWhereUniqueInput
  }

  /**
   * MotherTongue updateMany
   */
  export type MotherTongueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MotherTongues.
     */
    data: XOR<MotherTongueUpdateManyMutationInput, MotherTongueUncheckedUpdateManyInput>
    /**
     * Filter which MotherTongues to update
     */
    where?: MotherTongueWhereInput
  }

  /**
   * MotherTongue upsert
   */
  export type MotherTongueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * The filter to search for the MotherTongue to update in case it exists.
     */
    where: MotherTongueWhereUniqueInput
    /**
     * In case the MotherTongue found by the `where` argument doesn't exist, create a new MotherTongue with this data.
     */
    create: XOR<MotherTongueCreateInput, MotherTongueUncheckedCreateInput>
    /**
     * In case the MotherTongue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MotherTongueUpdateInput, MotherTongueUncheckedUpdateInput>
  }

  /**
   * MotherTongue delete
   */
  export type MotherTongueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
    /**
     * Filter which MotherTongue to delete.
     */
    where: MotherTongueWhereUniqueInput
  }

  /**
   * MotherTongue deleteMany
   */
  export type MotherTongueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MotherTongues to delete
     */
    where?: MotherTongueWhereInput
  }

  /**
   * MotherTongue.Diversity
   */
  export type MotherTongue$DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diversity
     */
    select?: DiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiversityInclude<ExtArgs> | null
    where?: DiversityWhereInput
    orderBy?: DiversityOrderByWithRelationInput | DiversityOrderByWithRelationInput[]
    cursor?: DiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiversityScalarFieldEnum | DiversityScalarFieldEnum[]
  }

  /**
   * MotherTongue.PreferredDiversity
   */
  export type MotherTongue$PreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferredDiversity
     */
    select?: PreferredDiversitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferredDiversityInclude<ExtArgs> | null
    where?: PreferredDiversityWhereInput
    orderBy?: PreferredDiversityOrderByWithRelationInput | PreferredDiversityOrderByWithRelationInput[]
    cursor?: PreferredDiversityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferredDiversityScalarFieldEnum | PreferredDiversityScalarFieldEnum[]
  }

  /**
   * MotherTongue without action
   */
  export type MotherTongueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotherTongue
     */
    select?: MotherTongueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotherTongueInclude<ExtArgs> | null
  }


  /**
   * Model Astrology
   */

  export type AggregateAstrology = {
    _count: AstrologyCountAggregateOutputType | null
    _avg: AstrologyAvgAggregateOutputType | null
    _sum: AstrologySumAggregateOutputType | null
    _min: AstrologyMinAggregateOutputType | null
    _max: AstrologyMaxAggregateOutputType | null
  }

  export type AstrologyAvgAggregateOutputType = {
    id: number | null
  }

  export type AstrologySumAggregateOutputType = {
    id: number | null
  }

  export type AstrologyMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type AstrologyMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type AstrologyCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type AstrologyAvgAggregateInputType = {
    id?: true
  }

  export type AstrologySumAggregateInputType = {
    id?: true
  }

  export type AstrologyMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type AstrologyMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type AstrologyCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type AstrologyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Astrology to aggregate.
     */
    where?: AstrologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Astrologies to fetch.
     */
    orderBy?: AstrologyOrderByWithRelationInput | AstrologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AstrologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Astrologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Astrologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Astrologies
    **/
    _count?: true | AstrologyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AstrologyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AstrologySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AstrologyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AstrologyMaxAggregateInputType
  }

  export type GetAstrologyAggregateType<T extends AstrologyAggregateArgs> = {
        [P in keyof T & keyof AggregateAstrology]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAstrology[P]>
      : GetScalarType<T[P], AggregateAstrology[P]>
  }




  export type AstrologyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AstrologyWhereInput
    orderBy?: AstrologyOrderByWithAggregationInput | AstrologyOrderByWithAggregationInput[]
    by: AstrologyScalarFieldEnum[] | AstrologyScalarFieldEnum
    having?: AstrologyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AstrologyCountAggregateInputType | true
    _avg?: AstrologyAvgAggregateInputType
    _sum?: AstrologySumAggregateInputType
    _min?: AstrologyMinAggregateInputType
    _max?: AstrologyMaxAggregateInputType
  }

  export type AstrologyGroupByOutputType = {
    id: number
    title: string
    _count: AstrologyCountAggregateOutputType | null
    _avg: AstrologyAvgAggregateOutputType | null
    _sum: AstrologySumAggregateOutputType | null
    _min: AstrologyMinAggregateOutputType | null
    _max: AstrologyMaxAggregateOutputType | null
  }

  type GetAstrologyGroupByPayload<T extends AstrologyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AstrologyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AstrologyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AstrologyGroupByOutputType[P]>
            : GetScalarType<T[P], AstrologyGroupByOutputType[P]>
        }
      >
    >


  export type AstrologySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    AdditionalDetail?: boolean | Astrology$AdditionalDetailArgs<ExtArgs>
    UserPreference?: boolean | Astrology$UserPreferenceArgs<ExtArgs>
    _count?: boolean | AstrologyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["astrology"]>

  export type AstrologySelectScalar = {
    id?: boolean
    title?: boolean
  }


  export type AstrologyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdditionalDetail?: boolean | Astrology$AdditionalDetailArgs<ExtArgs>
    UserPreference?: boolean | Astrology$UserPreferenceArgs<ExtArgs>
    _count?: boolean | AstrologyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AstrologyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Astrology"
    objects: {
      AdditionalDetail: Prisma.$AdditionalDetailPayload<ExtArgs>[]
      UserPreference: Prisma.$UserPreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["astrology"]>
    composites: {}
  }


  type AstrologyGetPayload<S extends boolean | null | undefined | AstrologyDefaultArgs> = $Result.GetResult<Prisma.$AstrologyPayload, S>

  type AstrologyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AstrologyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AstrologyCountAggregateInputType | true
    }

  export interface AstrologyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Astrology'], meta: { name: 'Astrology' } }
    /**
     * Find zero or one Astrology that matches the filter.
     * @param {AstrologyFindUniqueArgs} args - Arguments to find a Astrology
     * @example
     * // Get one Astrology
     * const astrology = await prisma.astrology.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AstrologyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyFindUniqueArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Astrology that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AstrologyFindUniqueOrThrowArgs} args - Arguments to find a Astrology
     * @example
     * // Get one Astrology
     * const astrology = await prisma.astrology.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AstrologyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Astrology that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyFindFirstArgs} args - Arguments to find a Astrology
     * @example
     * // Get one Astrology
     * const astrology = await prisma.astrology.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AstrologyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyFindFirstArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Astrology that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyFindFirstOrThrowArgs} args - Arguments to find a Astrology
     * @example
     * // Get one Astrology
     * const astrology = await prisma.astrology.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AstrologyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Astrologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Astrologies
     * const astrologies = await prisma.astrology.findMany()
     * 
     * // Get first 10 Astrologies
     * const astrologies = await prisma.astrology.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const astrologyWithIdOnly = await prisma.astrology.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AstrologyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Astrology.
     * @param {AstrologyCreateArgs} args - Arguments to create a Astrology.
     * @example
     * // Create one Astrology
     * const Astrology = await prisma.astrology.create({
     *   data: {
     *     // ... data to create a Astrology
     *   }
     * })
     * 
    **/
    create<T extends AstrologyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyCreateArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Astrologies.
     *     @param {AstrologyCreateManyArgs} args - Arguments to create many Astrologies.
     *     @example
     *     // Create many Astrologies
     *     const astrology = await prisma.astrology.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AstrologyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Astrology.
     * @param {AstrologyDeleteArgs} args - Arguments to delete one Astrology.
     * @example
     * // Delete one Astrology
     * const Astrology = await prisma.astrology.delete({
     *   where: {
     *     // ... filter to delete one Astrology
     *   }
     * })
     * 
    **/
    delete<T extends AstrologyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyDeleteArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Astrology.
     * @param {AstrologyUpdateArgs} args - Arguments to update one Astrology.
     * @example
     * // Update one Astrology
     * const astrology = await prisma.astrology.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AstrologyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyUpdateArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Astrologies.
     * @param {AstrologyDeleteManyArgs} args - Arguments to filter Astrologies to delete.
     * @example
     * // Delete a few Astrologies
     * const { count } = await prisma.astrology.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AstrologyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AstrologyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Astrologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Astrologies
     * const astrology = await prisma.astrology.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AstrologyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Astrology.
     * @param {AstrologyUpsertArgs} args - Arguments to update or create a Astrology.
     * @example
     * // Update or create a Astrology
     * const astrology = await prisma.astrology.upsert({
     *   create: {
     *     // ... data to create a Astrology
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Astrology we want to update
     *   }
     * })
    **/
    upsert<T extends AstrologyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AstrologyUpsertArgs<ExtArgs>>
    ): Prisma__AstrologyClient<$Result.GetResult<Prisma.$AstrologyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Astrologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyCountArgs} args - Arguments to filter Astrologies to count.
     * @example
     * // Count the number of Astrologies
     * const count = await prisma.astrology.count({
     *   where: {
     *     // ... the filter for the Astrologies we want to count
     *   }
     * })
    **/
    count<T extends AstrologyCountArgs>(
      args?: Subset<T, AstrologyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AstrologyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Astrology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AstrologyAggregateArgs>(args: Subset<T, AstrologyAggregateArgs>): Prisma.PrismaPromise<GetAstrologyAggregateType<T>>

    /**
     * Group by Astrology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AstrologyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AstrologyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AstrologyGroupByArgs['orderBy'] }
        : { orderBy?: AstrologyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AstrologyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAstrologyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Astrology model
   */
  readonly fields: AstrologyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Astrology.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AstrologyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    AdditionalDetail<T extends Astrology$AdditionalDetailArgs<ExtArgs> = {}>(args?: Subset<T, Astrology$AdditionalDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdditionalDetailPayload<ExtArgs>, T, 'findMany'> | Null>;

    UserPreference<T extends Astrology$UserPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, Astrology$UserPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Astrology model
   */ 
  interface AstrologyFieldRefs {
    readonly id: FieldRef<"Astrology", 'Int'>
    readonly title: FieldRef<"Astrology", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Astrology findUnique
   */
  export type AstrologyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrology to fetch.
     */
    where: AstrologyWhereUniqueInput
  }

  /**
   * Astrology findUniqueOrThrow
   */
  export type AstrologyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrology to fetch.
     */
    where: AstrologyWhereUniqueInput
  }

  /**
   * Astrology findFirst
   */
  export type AstrologyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrology to fetch.
     */
    where?: AstrologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Astrologies to fetch.
     */
    orderBy?: AstrologyOrderByWithRelationInput | AstrologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Astrologies.
     */
    cursor?: AstrologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Astrologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Astrologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Astrologies.
     */
    distinct?: AstrologyScalarFieldEnum | AstrologyScalarFieldEnum[]
  }

  /**
   * Astrology findFirstOrThrow
   */
  export type AstrologyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrology to fetch.
     */
    where?: AstrologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Astrologies to fetch.
     */
    orderBy?: AstrologyOrderByWithRelationInput | AstrologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Astrologies.
     */
    cursor?: AstrologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Astrologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Astrologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Astrologies.
     */
    distinct?: AstrologyScalarFieldEnum | AstrologyScalarFieldEnum[]
  }

  /**
   * Astrology findMany
   */
  export type AstrologyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter, which Astrologies to fetch.
     */
    where?: AstrologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Astrologies to fetch.
     */
    orderBy?: AstrologyOrderByWithRelationInput | AstrologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Astrologies.
     */
    cursor?: AstrologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Astrologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Astrologies.
     */
    skip?: number
    distinct?: AstrologyScalarFieldEnum | AstrologyScalarFieldEnum[]
  }

  /**
   * Astrology create
   */
  export type AstrologyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * The data needed to create a Astrology.
     */
    data: XOR<AstrologyCreateInput, AstrologyUncheckedCreateInput>
  }

  /**
   * Astrology createMany
   */
  export type AstrologyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Astrologies.
     */
    data: AstrologyCreateManyInput | AstrologyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Astrology update
   */
  export type AstrologyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * The data needed to update a Astrology.
     */
    data: XOR<AstrologyUpdateInput, AstrologyUncheckedUpdateInput>
    /**
     * Choose, which Astrology to update.
     */
    where: AstrologyWhereUniqueInput
  }

  /**
   * Astrology updateMany
   */
  export type AstrologyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Astrologies.
     */
    data: XOR<AstrologyUpdateManyMutationInput, AstrologyUncheckedUpdateManyInput>
    /**
     * Filter which Astrologies to update
     */
    where?: AstrologyWhereInput
  }

  /**
   * Astrology upsert
   */
  export type AstrologyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * The filter to search for the Astrology to update in case it exists.
     */
    where: AstrologyWhereUniqueInput
    /**
     * In case the Astrology found by the `where` argument doesn't exist, create a new Astrology with this data.
     */
    create: XOR<AstrologyCreateInput, AstrologyUncheckedCreateInput>
    /**
     * In case the Astrology was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AstrologyUpdateInput, AstrologyUncheckedUpdateInput>
  }

  /**
   * Astrology delete
   */
  export type AstrologyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
    /**
     * Filter which Astrology to delete.
     */
    where: AstrologyWhereUniqueInput
  }

  /**
   * Astrology deleteMany
   */
  export type AstrologyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Astrologies to delete
     */
    where?: AstrologyWhereInput
  }

  /**
   * Astrology.AdditionalDetail
   */
  export type Astrology$AdditionalDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalDetail
     */
    select?: AdditionalDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdditionalDetailInclude<ExtArgs> | null
    where?: AdditionalDetailWhereInput
    orderBy?: AdditionalDetailOrderByWithRelationInput | AdditionalDetailOrderByWithRelationInput[]
    cursor?: AdditionalDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdditionalDetailScalarFieldEnum | AdditionalDetailScalarFieldEnum[]
  }

  /**
   * Astrology.UserPreference
   */
  export type Astrology$UserPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    where?: UserPreferenceWhereInput
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    cursor?: UserPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * Astrology without action
   */
  export type AstrologyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Astrology
     */
    select?: AstrologySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AstrologyInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    bio: 'bio',
    image: 'image',
    maritalStatusId: 'maritalStatusId',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DiversityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    religionId: 'religionId',
    countryId: 'countryId',
    cityId: 'cityId',
    communityId: 'communityId',
    motherTongueId: 'motherTongueId'
  };

  export type DiversityScalarFieldEnum = (typeof DiversityScalarFieldEnum)[keyof typeof DiversityScalarFieldEnum]


  export const AdditionalDetailScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    astrologicalId: 'astrologicalId',
    facebookProfileLink: 'facebookProfileLink',
    contactNumber: 'contactNumber'
  };

  export type AdditionalDetailScalarFieldEnum = (typeof AdditionalDetailScalarFieldEnum)[keyof typeof AdditionalDetailScalarFieldEnum]


  export const UserPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gender: 'gender',
    minAge: 'minAge',
    maxAge: 'maxAge',
    astrologicalId: 'astrologicalId',
    maritalStatusId: 'maritalStatusId'
  };

  export type UserPreferenceScalarFieldEnum = (typeof UserPreferenceScalarFieldEnum)[keyof typeof UserPreferenceScalarFieldEnum]


  export const PreferredDiversityScalarFieldEnum: {
    id: 'id',
    userPreferencesId: 'userPreferencesId',
    countryId: 'countryId',
    cityId: 'cityId',
    motherTongueId: 'motherTongueId',
    communityId: 'communityId',
    religionId: 'religionId'
  };

  export type PreferredDiversityScalarFieldEnum = (typeof PreferredDiversityScalarFieldEnum)[keyof typeof PreferredDiversityScalarFieldEnum]


  export const MaritalStatusScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type MaritalStatusScalarFieldEnum = (typeof MaritalStatusScalarFieldEnum)[keyof typeof MaritalStatusScalarFieldEnum]


  export const ReligionScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type ReligionScalarFieldEnum = (typeof ReligionScalarFieldEnum)[keyof typeof ReligionScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    countryId: 'countryId'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const MotherTongueScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type MotherTongueScalarFieldEnum = (typeof MotherTongueScalarFieldEnum)[keyof typeof MotherTongueScalarFieldEnum]


  export const AstrologyScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type AstrologyScalarFieldEnum = (typeof AstrologyScalarFieldEnum)[keyof typeof AstrologyScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeFilter<"User"> | Date | string
    gender?: StringFilter<"User"> | string
    bio?: StringFilter<"User"> | string
    image?: StringFilter<"User"> | string
    maritalStatusId?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
    maritalStatus?: XOR<MaritalStatusRelationFilter, MaritalStatusWhereInput>
    diversity?: XOR<DiversityNullableRelationFilter, DiversityWhereInput> | null
    additionalDetail?: XOR<AdditionalDetailNullableRelationFilter, AdditionalDetailWhereInput> | null
    userPreferences?: XOR<UserPreferenceNullableRelationFilter, UserPreferenceWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
    maritalStatus?: MaritalStatusOrderByWithRelationInput
    diversity?: DiversityOrderByWithRelationInput
    additionalDetail?: AdditionalDetailOrderByWithRelationInput
    userPreferences?: UserPreferenceOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeFilter<"User"> | Date | string
    gender?: StringFilter<"User"> | string
    bio?: StringFilter<"User"> | string
    image?: StringFilter<"User"> | string
    maritalStatusId?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
    maritalStatus?: XOR<MaritalStatusRelationFilter, MaritalStatusWhereInput>
    diversity?: XOR<DiversityNullableRelationFilter, DiversityWhereInput> | null
    additionalDetail?: XOR<AdditionalDetailNullableRelationFilter, AdditionalDetailWhereInput> | null
    userPreferences?: XOR<UserPreferenceNullableRelationFilter, UserPreferenceWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"User"> | Date | string
    gender?: StringWithAggregatesFilter<"User"> | string
    bio?: StringWithAggregatesFilter<"User"> | string
    image?: StringWithAggregatesFilter<"User"> | string
    maritalStatusId?: IntWithAggregatesFilter<"User"> | number
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type DiversityWhereInput = {
    AND?: DiversityWhereInput | DiversityWhereInput[]
    OR?: DiversityWhereInput[]
    NOT?: DiversityWhereInput | DiversityWhereInput[]
    id?: IntFilter<"Diversity"> | number
    userId?: IntFilter<"Diversity"> | number
    religionId?: IntFilter<"Diversity"> | number
    countryId?: IntFilter<"Diversity"> | number
    cityId?: IntFilter<"Diversity"> | number
    communityId?: IntFilter<"Diversity"> | number
    motherTongueId?: IntFilter<"Diversity"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    religion?: XOR<ReligionRelationFilter, ReligionWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    motherTongue?: XOR<MotherTongueRelationFilter, MotherTongueWhereInput>
  }

  export type DiversityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
    user?: UserOrderByWithRelationInput
    religion?: ReligionOrderByWithRelationInput
    country?: CountryOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
    motherTongue?: MotherTongueOrderByWithRelationInput
  }

  export type DiversityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: DiversityWhereInput | DiversityWhereInput[]
    OR?: DiversityWhereInput[]
    NOT?: DiversityWhereInput | DiversityWhereInput[]
    religionId?: IntFilter<"Diversity"> | number
    countryId?: IntFilter<"Diversity"> | number
    cityId?: IntFilter<"Diversity"> | number
    communityId?: IntFilter<"Diversity"> | number
    motherTongueId?: IntFilter<"Diversity"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    religion?: XOR<ReligionRelationFilter, ReligionWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    motherTongue?: XOR<MotherTongueRelationFilter, MotherTongueWhereInput>
  }, "id" | "userId">

  export type DiversityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
    _count?: DiversityCountOrderByAggregateInput
    _avg?: DiversityAvgOrderByAggregateInput
    _max?: DiversityMaxOrderByAggregateInput
    _min?: DiversityMinOrderByAggregateInput
    _sum?: DiversitySumOrderByAggregateInput
  }

  export type DiversityScalarWhereWithAggregatesInput = {
    AND?: DiversityScalarWhereWithAggregatesInput | DiversityScalarWhereWithAggregatesInput[]
    OR?: DiversityScalarWhereWithAggregatesInput[]
    NOT?: DiversityScalarWhereWithAggregatesInput | DiversityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Diversity"> | number
    userId?: IntWithAggregatesFilter<"Diversity"> | number
    religionId?: IntWithAggregatesFilter<"Diversity"> | number
    countryId?: IntWithAggregatesFilter<"Diversity"> | number
    cityId?: IntWithAggregatesFilter<"Diversity"> | number
    communityId?: IntWithAggregatesFilter<"Diversity"> | number
    motherTongueId?: IntWithAggregatesFilter<"Diversity"> | number
  }

  export type AdditionalDetailWhereInput = {
    AND?: AdditionalDetailWhereInput | AdditionalDetailWhereInput[]
    OR?: AdditionalDetailWhereInput[]
    NOT?: AdditionalDetailWhereInput | AdditionalDetailWhereInput[]
    id?: IntFilter<"AdditionalDetail"> | number
    userId?: IntFilter<"AdditionalDetail"> | number
    astrologicalId?: IntFilter<"AdditionalDetail"> | number
    facebookProfileLink?: StringFilter<"AdditionalDetail"> | string
    contactNumber?: StringFilter<"AdditionalDetail"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    astrology?: XOR<AstrologyRelationFilter, AstrologyWhereInput>
  }

  export type AdditionalDetailOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
    user?: UserOrderByWithRelationInput
    astrology?: AstrologyOrderByWithRelationInput
  }

  export type AdditionalDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AdditionalDetailWhereInput | AdditionalDetailWhereInput[]
    OR?: AdditionalDetailWhereInput[]
    NOT?: AdditionalDetailWhereInput | AdditionalDetailWhereInput[]
    astrologicalId?: IntFilter<"AdditionalDetail"> | number
    facebookProfileLink?: StringFilter<"AdditionalDetail"> | string
    contactNumber?: StringFilter<"AdditionalDetail"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    astrology?: XOR<AstrologyRelationFilter, AstrologyWhereInput>
  }, "id" | "userId">

  export type AdditionalDetailOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
    _count?: AdditionalDetailCountOrderByAggregateInput
    _avg?: AdditionalDetailAvgOrderByAggregateInput
    _max?: AdditionalDetailMaxOrderByAggregateInput
    _min?: AdditionalDetailMinOrderByAggregateInput
    _sum?: AdditionalDetailSumOrderByAggregateInput
  }

  export type AdditionalDetailScalarWhereWithAggregatesInput = {
    AND?: AdditionalDetailScalarWhereWithAggregatesInput | AdditionalDetailScalarWhereWithAggregatesInput[]
    OR?: AdditionalDetailScalarWhereWithAggregatesInput[]
    NOT?: AdditionalDetailScalarWhereWithAggregatesInput | AdditionalDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdditionalDetail"> | number
    userId?: IntWithAggregatesFilter<"AdditionalDetail"> | number
    astrologicalId?: IntWithAggregatesFilter<"AdditionalDetail"> | number
    facebookProfileLink?: StringWithAggregatesFilter<"AdditionalDetail"> | string
    contactNumber?: StringWithAggregatesFilter<"AdditionalDetail"> | string
  }

  export type UserPreferenceWhereInput = {
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    id?: IntFilter<"UserPreference"> | number
    userId?: IntFilter<"UserPreference"> | number
    gender?: StringFilter<"UserPreference"> | string
    minAge?: IntFilter<"UserPreference"> | number
    maxAge?: IntFilter<"UserPreference"> | number
    astrologicalId?: IntFilter<"UserPreference"> | number
    maritalStatusId?: IntFilter<"UserPreference"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    astrology?: XOR<AstrologyRelationFilter, AstrologyWhereInput>
    maritalStatus?: XOR<MaritalStatusRelationFilter, MaritalStatusWhereInput>
    preferredDiversity?: PreferredDiversityListRelationFilter
  }

  export type UserPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    astrologicalId?: SortOrder
    maritalStatusId?: SortOrder
    user?: UserOrderByWithRelationInput
    astrology?: AstrologyOrderByWithRelationInput
    maritalStatus?: MaritalStatusOrderByWithRelationInput
    preferredDiversity?: PreferredDiversityOrderByRelationAggregateInput
  }

  export type UserPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    gender?: StringFilter<"UserPreference"> | string
    minAge?: IntFilter<"UserPreference"> | number
    maxAge?: IntFilter<"UserPreference"> | number
    astrologicalId?: IntFilter<"UserPreference"> | number
    maritalStatusId?: IntFilter<"UserPreference"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    astrology?: XOR<AstrologyRelationFilter, AstrologyWhereInput>
    maritalStatus?: XOR<MaritalStatusRelationFilter, MaritalStatusWhereInput>
    preferredDiversity?: PreferredDiversityListRelationFilter
  }, "id" | "userId">

  export type UserPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    astrologicalId?: SortOrder
    maritalStatusId?: SortOrder
    _count?: UserPreferenceCountOrderByAggregateInput
    _avg?: UserPreferenceAvgOrderByAggregateInput
    _max?: UserPreferenceMaxOrderByAggregateInput
    _min?: UserPreferenceMinOrderByAggregateInput
    _sum?: UserPreferenceSumOrderByAggregateInput
  }

  export type UserPreferenceScalarWhereWithAggregatesInput = {
    AND?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    OR?: UserPreferenceScalarWhereWithAggregatesInput[]
    NOT?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPreference"> | number
    userId?: IntWithAggregatesFilter<"UserPreference"> | number
    gender?: StringWithAggregatesFilter<"UserPreference"> | string
    minAge?: IntWithAggregatesFilter<"UserPreference"> | number
    maxAge?: IntWithAggregatesFilter<"UserPreference"> | number
    astrologicalId?: IntWithAggregatesFilter<"UserPreference"> | number
    maritalStatusId?: IntWithAggregatesFilter<"UserPreference"> | number
  }

  export type PreferredDiversityWhereInput = {
    AND?: PreferredDiversityWhereInput | PreferredDiversityWhereInput[]
    OR?: PreferredDiversityWhereInput[]
    NOT?: PreferredDiversityWhereInput | PreferredDiversityWhereInput[]
    id?: IntFilter<"PreferredDiversity"> | number
    userPreferencesId?: IntFilter<"PreferredDiversity"> | number
    countryId?: IntFilter<"PreferredDiversity"> | number
    cityId?: IntFilter<"PreferredDiversity"> | number
    motherTongueId?: IntFilter<"PreferredDiversity"> | number
    communityId?: IntFilter<"PreferredDiversity"> | number
    religionId?: IntFilter<"PreferredDiversity"> | number
    userPreference?: XOR<UserPreferenceRelationFilter, UserPreferenceWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    motherTongue?: XOR<MotherTongueRelationFilter, MotherTongueWhereInput>
    community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    religion?: XOR<ReligionRelationFilter, ReligionWhereInput>
  }

  export type PreferredDiversityOrderByWithRelationInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    userPreference?: UserPreferenceOrderByWithRelationInput
    country?: CountryOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    motherTongue?: MotherTongueOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
    religion?: ReligionOrderByWithRelationInput
  }

  export type PreferredDiversityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PreferredDiversityWhereInput | PreferredDiversityWhereInput[]
    OR?: PreferredDiversityWhereInput[]
    NOT?: PreferredDiversityWhereInput | PreferredDiversityWhereInput[]
    userPreferencesId?: IntFilter<"PreferredDiversity"> | number
    countryId?: IntFilter<"PreferredDiversity"> | number
    cityId?: IntFilter<"PreferredDiversity"> | number
    motherTongueId?: IntFilter<"PreferredDiversity"> | number
    communityId?: IntFilter<"PreferredDiversity"> | number
    religionId?: IntFilter<"PreferredDiversity"> | number
    userPreference?: XOR<UserPreferenceRelationFilter, UserPreferenceWhereInput>
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    motherTongue?: XOR<MotherTongueRelationFilter, MotherTongueWhereInput>
    community?: XOR<CommunityRelationFilter, CommunityWhereInput>
    religion?: XOR<ReligionRelationFilter, ReligionWhereInput>
  }, "id">

  export type PreferredDiversityOrderByWithAggregationInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
    _count?: PreferredDiversityCountOrderByAggregateInput
    _avg?: PreferredDiversityAvgOrderByAggregateInput
    _max?: PreferredDiversityMaxOrderByAggregateInput
    _min?: PreferredDiversityMinOrderByAggregateInput
    _sum?: PreferredDiversitySumOrderByAggregateInput
  }

  export type PreferredDiversityScalarWhereWithAggregatesInput = {
    AND?: PreferredDiversityScalarWhereWithAggregatesInput | PreferredDiversityScalarWhereWithAggregatesInput[]
    OR?: PreferredDiversityScalarWhereWithAggregatesInput[]
    NOT?: PreferredDiversityScalarWhereWithAggregatesInput | PreferredDiversityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PreferredDiversity"> | number
    userPreferencesId?: IntWithAggregatesFilter<"PreferredDiversity"> | number
    countryId?: IntWithAggregatesFilter<"PreferredDiversity"> | number
    cityId?: IntWithAggregatesFilter<"PreferredDiversity"> | number
    motherTongueId?: IntWithAggregatesFilter<"PreferredDiversity"> | number
    communityId?: IntWithAggregatesFilter<"PreferredDiversity"> | number
    religionId?: IntWithAggregatesFilter<"PreferredDiversity"> | number
  }

  export type MaritalStatusWhereInput = {
    AND?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    OR?: MaritalStatusWhereInput[]
    NOT?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    id?: IntFilter<"MaritalStatus"> | number
    title?: StringFilter<"MaritalStatus"> | string
    users?: UserListRelationFilter
    UserPreference?: UserPreferenceListRelationFilter
  }

  export type MaritalStatusOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    users?: UserOrderByRelationAggregateInput
    UserPreference?: UserPreferenceOrderByRelationAggregateInput
  }

  export type MaritalStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    OR?: MaritalStatusWhereInput[]
    NOT?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    users?: UserListRelationFilter
    UserPreference?: UserPreferenceListRelationFilter
  }, "id" | "title">

  export type MaritalStatusOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: MaritalStatusCountOrderByAggregateInput
    _avg?: MaritalStatusAvgOrderByAggregateInput
    _max?: MaritalStatusMaxOrderByAggregateInput
    _min?: MaritalStatusMinOrderByAggregateInput
    _sum?: MaritalStatusSumOrderByAggregateInput
  }

  export type MaritalStatusScalarWhereWithAggregatesInput = {
    AND?: MaritalStatusScalarWhereWithAggregatesInput | MaritalStatusScalarWhereWithAggregatesInput[]
    OR?: MaritalStatusScalarWhereWithAggregatesInput[]
    NOT?: MaritalStatusScalarWhereWithAggregatesInput | MaritalStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaritalStatus"> | number
    title?: StringWithAggregatesFilter<"MaritalStatus"> | string
  }

  export type ReligionWhereInput = {
    AND?: ReligionWhereInput | ReligionWhereInput[]
    OR?: ReligionWhereInput[]
    NOT?: ReligionWhereInput | ReligionWhereInput[]
    id?: IntFilter<"Religion"> | number
    title?: StringFilter<"Religion"> | string
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }

  export type ReligionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    Diversity?: DiversityOrderByRelationAggregateInput
    PreferredDiversity?: PreferredDiversityOrderByRelationAggregateInput
  }

  export type ReligionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: ReligionWhereInput | ReligionWhereInput[]
    OR?: ReligionWhereInput[]
    NOT?: ReligionWhereInput | ReligionWhereInput[]
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }, "id" | "title">

  export type ReligionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: ReligionCountOrderByAggregateInput
    _avg?: ReligionAvgOrderByAggregateInput
    _max?: ReligionMaxOrderByAggregateInput
    _min?: ReligionMinOrderByAggregateInput
    _sum?: ReligionSumOrderByAggregateInput
  }

  export type ReligionScalarWhereWithAggregatesInput = {
    AND?: ReligionScalarWhereWithAggregatesInput | ReligionScalarWhereWithAggregatesInput[]
    OR?: ReligionScalarWhereWithAggregatesInput[]
    NOT?: ReligionScalarWhereWithAggregatesInput | ReligionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Religion"> | number
    title?: StringWithAggregatesFilter<"Religion"> | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    title?: StringFilter<"Country"> | string
    cities?: CityListRelationFilter
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    cities?: CityOrderByRelationAggregateInput
    Diversity?: DiversityOrderByRelationAggregateInput
    PreferredDiversity?: PreferredDiversityOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    cities?: CityListRelationFilter
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }, "id" | "title">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    title?: StringWithAggregatesFilter<"Country"> | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: IntFilter<"City"> | number
    title?: StringFilter<"City"> | string
    countryId?: IntFilter<"City"> | number
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
    country?: CountryOrderByWithRelationInput
    Diversity?: DiversityOrderByRelationAggregateInput
    PreferredDiversity?: PreferredDiversityOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    countryId?: IntFilter<"City"> | number
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }, "id" | "title">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"City"> | number
    title?: StringWithAggregatesFilter<"City"> | string
    countryId?: IntWithAggregatesFilter<"City"> | number
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: IntFilter<"Community"> | number
    title?: StringFilter<"Community"> | string
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    Diversity?: DiversityOrderByRelationAggregateInput
    PreferredDiversity?: PreferredDiversityOrderByRelationAggregateInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }, "id" | "title">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Community"> | number
    title?: StringWithAggregatesFilter<"Community"> | string
  }

  export type MotherTongueWhereInput = {
    AND?: MotherTongueWhereInput | MotherTongueWhereInput[]
    OR?: MotherTongueWhereInput[]
    NOT?: MotherTongueWhereInput | MotherTongueWhereInput[]
    id?: IntFilter<"MotherTongue"> | number
    title?: StringFilter<"MotherTongue"> | string
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }

  export type MotherTongueOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    Diversity?: DiversityOrderByRelationAggregateInput
    PreferredDiversity?: PreferredDiversityOrderByRelationAggregateInput
  }

  export type MotherTongueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: MotherTongueWhereInput | MotherTongueWhereInput[]
    OR?: MotherTongueWhereInput[]
    NOT?: MotherTongueWhereInput | MotherTongueWhereInput[]
    Diversity?: DiversityListRelationFilter
    PreferredDiversity?: PreferredDiversityListRelationFilter
  }, "id" | "title">

  export type MotherTongueOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: MotherTongueCountOrderByAggregateInput
    _avg?: MotherTongueAvgOrderByAggregateInput
    _max?: MotherTongueMaxOrderByAggregateInput
    _min?: MotherTongueMinOrderByAggregateInput
    _sum?: MotherTongueSumOrderByAggregateInput
  }

  export type MotherTongueScalarWhereWithAggregatesInput = {
    AND?: MotherTongueScalarWhereWithAggregatesInput | MotherTongueScalarWhereWithAggregatesInput[]
    OR?: MotherTongueScalarWhereWithAggregatesInput[]
    NOT?: MotherTongueScalarWhereWithAggregatesInput | MotherTongueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MotherTongue"> | number
    title?: StringWithAggregatesFilter<"MotherTongue"> | string
  }

  export type AstrologyWhereInput = {
    AND?: AstrologyWhereInput | AstrologyWhereInput[]
    OR?: AstrologyWhereInput[]
    NOT?: AstrologyWhereInput | AstrologyWhereInput[]
    id?: IntFilter<"Astrology"> | number
    title?: StringFilter<"Astrology"> | string
    AdditionalDetail?: AdditionalDetailListRelationFilter
    UserPreference?: UserPreferenceListRelationFilter
  }

  export type AstrologyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    AdditionalDetail?: AdditionalDetailOrderByRelationAggregateInput
    UserPreference?: UserPreferenceOrderByRelationAggregateInput
  }

  export type AstrologyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: AstrologyWhereInput | AstrologyWhereInput[]
    OR?: AstrologyWhereInput[]
    NOT?: AstrologyWhereInput | AstrologyWhereInput[]
    AdditionalDetail?: AdditionalDetailListRelationFilter
    UserPreference?: UserPreferenceListRelationFilter
  }, "id" | "title">

  export type AstrologyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: AstrologyCountOrderByAggregateInput
    _avg?: AstrologyAvgOrderByAggregateInput
    _max?: AstrologyMaxOrderByAggregateInput
    _min?: AstrologyMinOrderByAggregateInput
    _sum?: AstrologySumOrderByAggregateInput
  }

  export type AstrologyScalarWhereWithAggregatesInput = {
    AND?: AstrologyScalarWhereWithAggregatesInput | AstrologyScalarWhereWithAggregatesInput[]
    OR?: AstrologyScalarWhereWithAggregatesInput[]
    NOT?: AstrologyScalarWhereWithAggregatesInput | AstrologyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Astrology"> | number
    title?: StringWithAggregatesFilter<"Astrology"> | string
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    diversity?: DiversityCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    userPreferences?: UserPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    userPreferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    userPreferences?: UserPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    userPreferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
  }

  export type DiversityCreateInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityUpdateInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityUpdateManyMutationInput = {

  }

  export type DiversityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type AdditionalDetailCreateInput = {
    facebookProfileLink: string
    contactNumber: string
    user: UserCreateNestedOneWithoutAdditionalDetailInput
    astrology?: AstrologyCreateNestedOneWithoutAdditionalDetailInput
  }

  export type AdditionalDetailUncheckedCreateInput = {
    id?: number
    userId: number
    astrologicalId?: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailUpdateInput = {
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdditionalDetailNestedInput
    astrology?: AstrologyUpdateOneRequiredWithoutAdditionalDetailNestedInput
  }

  export type AdditionalDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalDetailCreateManyInput = {
    id?: number
    userId: number
    astrologicalId?: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailUpdateManyMutationInput = {
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type UserPreferenceCreateInput = {
    gender: string
    minAge: number
    maxAge: number
    user: UserCreateNestedOneWithoutUserPreferencesInput
    astrology?: AstrologyCreateNestedOneWithoutUserPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutUserPreferenceInput
    preferredDiversity?: PreferredDiversityCreateNestedManyWithoutUserPreferenceInput
  }

  export type UserPreferenceUncheckedCreateInput = {
    id?: number
    userId: number
    gender: string
    minAge: number
    maxAge: number
    astrologicalId?: number
    maritalStatusId: number
    preferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutUserPreferenceInput
  }

  export type UserPreferenceUpdateInput = {
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserPreferencesNestedInput
    astrology?: AstrologyUpdateOneRequiredWithoutUserPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUserPreferenceNestedInput
    preferredDiversity?: PreferredDiversityUpdateManyWithoutUserPreferenceNestedInput
  }

  export type UserPreferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    preferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutUserPreferenceNestedInput
  }

  export type UserPreferenceCreateManyInput = {
    id?: number
    userId: number
    gender: string
    minAge: number
    maxAge: number
    astrologicalId?: number
    maritalStatusId: number
  }

  export type UserPreferenceUpdateManyMutationInput = {
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
  }

  export type UserPreferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityCreateInput = {
    userPreference: UserPreferenceCreateNestedOneWithoutPreferredDiversityInput
    country: CountryCreateNestedOneWithoutPreferredDiversityInput
    city: CityCreateNestedOneWithoutPreferredDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferredDiversityInput
    community: CommunityCreateNestedOneWithoutPreferredDiversityInput
    religion: ReligionCreateNestedOneWithoutPreferredDiversityInput
  }

  export type PreferredDiversityUncheckedCreateInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type PreferredDiversityUpdateInput = {
    userPreference?: UserPreferenceUpdateOneRequiredWithoutPreferredDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferredDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferredDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferredDiversityNestedInput
  }

  export type PreferredDiversityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityCreateManyInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type PreferredDiversityUpdateManyMutationInput = {

  }

  export type PreferredDiversityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type MaritalStatusCreateInput = {
    title: string
    users?: UserCreateNestedManyWithoutMaritalStatusInput
    UserPreference?: UserPreferenceCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUncheckedCreateInput = {
    id?: number
    title: string
    users?: UserUncheckedCreateNestedManyWithoutMaritalStatusInput
    UserPreference?: UserPreferenceUncheckedCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutMaritalStatusNestedInput
    UserPreference?: UserPreferenceUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMaritalStatusNestedInput
    UserPreference?: UserPreferenceUncheckedUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusCreateManyInput = {
    id?: number
    title: string
  }

  export type MaritalStatusUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type MaritalStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionCreateInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutReligionInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutReligionInput
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutReligionNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutReligionNestedInput
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type ReligionCreateManyInput = {
    id?: number
    title: string
  }

  export type ReligionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateInput = {
    title: string
    cities?: CityCreateNestedManyWithoutCountryInput
    Diversity?: DiversityCreateNestedManyWithoutCountryInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    title: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCountryInput
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    Diversity?: DiversityUpdateManyWithoutCountryNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    Diversity?: DiversityUncheckedUpdateManyWithoutCountryNestedInput
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    title: string
  }

  export type CountryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    title: string
    country: CountryCreateNestedOneWithoutCitiesInput
    Diversity?: DiversityCreateNestedManyWithoutCityInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    title: string
    countryId: number
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCityInput
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    Diversity?: DiversityUpdateManyWithoutCityNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    Diversity?: DiversityUncheckedUpdateManyWithoutCityNestedInput
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: number
    title: string
    countryId: number
  }

  export type CityUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type CommunityCreateInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutCommunityInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCommunityInput
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutCommunityNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutCommunityNestedInput
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: number
    title: string
  }

  export type CommunityUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type MotherTongueCreateInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutMotherTongueInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueUncheckedCreateInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutMotherTongueInput
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutMotherTongueNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutMotherTongueNestedInput
  }

  export type MotherTongueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutMotherTongueNestedInput
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutMotherTongueNestedInput
  }

  export type MotherTongueCreateManyInput = {
    id?: number
    title: string
  }

  export type MotherTongueUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type MotherTongueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AstrologyCreateInput = {
    title: string
    AdditionalDetail?: AdditionalDetailCreateNestedManyWithoutAstrologyInput
    UserPreference?: UserPreferenceCreateNestedManyWithoutAstrologyInput
  }

  export type AstrologyUncheckedCreateInput = {
    id?: number
    title: string
    AdditionalDetail?: AdditionalDetailUncheckedCreateNestedManyWithoutAstrologyInput
    UserPreference?: UserPreferenceUncheckedCreateNestedManyWithoutAstrologyInput
  }

  export type AstrologyUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    AdditionalDetail?: AdditionalDetailUpdateManyWithoutAstrologyNestedInput
    UserPreference?: UserPreferenceUpdateManyWithoutAstrologyNestedInput
  }

  export type AstrologyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    AdditionalDetail?: AdditionalDetailUncheckedUpdateManyWithoutAstrologyNestedInput
    UserPreference?: UserPreferenceUncheckedUpdateManyWithoutAstrologyNestedInput
  }

  export type AstrologyCreateManyInput = {
    id?: number
    title: string
  }

  export type AstrologyUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AstrologyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type MaritalStatusRelationFilter = {
    is?: MaritalStatusWhereInput
    isNot?: MaritalStatusWhereInput
  }

  export type DiversityNullableRelationFilter = {
    is?: DiversityWhereInput | null
    isNot?: DiversityWhereInput | null
  }

  export type AdditionalDetailNullableRelationFilter = {
    is?: AdditionalDetailWhereInput | null
    isNot?: AdditionalDetailWhereInput | null
  }

  export type UserPreferenceNullableRelationFilter = {
    is?: UserPreferenceWhereInput | null
    isNot?: UserPreferenceWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    image?: SortOrder
    maritalStatusId?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ReligionRelationFilter = {
    is?: ReligionWhereInput
    isNot?: ReligionWhereInput
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type CommunityRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type MotherTongueRelationFilter = {
    is?: MotherTongueWhereInput
    isNot?: MotherTongueWhereInput
  }

  export type DiversityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type DiversityAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type DiversityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type DiversityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type DiversitySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    religionId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    communityId?: SortOrder
    motherTongueId?: SortOrder
  }

  export type AstrologyRelationFilter = {
    is?: AstrologyWhereInput
    isNot?: AstrologyWhereInput
  }

  export type AdditionalDetailCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
  }

  export type AdditionalDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
  }

  export type AdditionalDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
  }

  export type AdditionalDetailMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
    facebookProfileLink?: SortOrder
    contactNumber?: SortOrder
  }

  export type AdditionalDetailSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    astrologicalId?: SortOrder
  }

  export type PreferredDiversityListRelationFilter = {
    every?: PreferredDiversityWhereInput
    some?: PreferredDiversityWhereInput
    none?: PreferredDiversityWhereInput
  }

  export type PreferredDiversityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    astrologicalId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type UserPreferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    astrologicalId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type UserPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    astrologicalId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type UserPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    astrologicalId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type UserPreferenceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    astrologicalId?: SortOrder
    maritalStatusId?: SortOrder
  }

  export type UserPreferenceRelationFilter = {
    is?: UserPreferenceWhereInput
    isNot?: UserPreferenceWhereInput
  }

  export type PreferredDiversityCountOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
  }

  export type PreferredDiversityAvgOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
  }

  export type PreferredDiversityMaxOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
  }

  export type PreferredDiversityMinOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
  }

  export type PreferredDiversitySumOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    countryId?: SortOrder
    cityId?: SortOrder
    motherTongueId?: SortOrder
    communityId?: SortOrder
    religionId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserPreferenceListRelationFilter = {
    every?: UserPreferenceWhereInput
    some?: UserPreferenceWhereInput
    none?: UserPreferenceWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaritalStatusCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaritalStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaritalStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaritalStatusMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaritalStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiversityListRelationFilter = {
    every?: DiversityWhereInput
    some?: DiversityWhereInput
    none?: DiversityWhereInput
  }

  export type DiversityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReligionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ReligionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReligionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ReligionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ReligionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    countryId?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MotherTongueCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MotherTongueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MotherTongueMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MotherTongueMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MotherTongueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdditionalDetailListRelationFilter = {
    every?: AdditionalDetailWhereInput
    some?: AdditionalDetailWhereInput
    none?: AdditionalDetailWhereInput
  }

  export type AdditionalDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AstrologyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type AstrologyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AstrologyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type AstrologyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type AstrologySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaritalStatusCreateNestedOneWithoutUsersInput = {
    create?: XOR<MaritalStatusCreateWithoutUsersInput, MaritalStatusUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutUsersInput
    connect?: MaritalStatusWhereUniqueInput
  }

  export type DiversityCreateNestedOneWithoutUserInput = {
    create?: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiversityCreateOrConnectWithoutUserInput
    connect?: DiversityWhereUniqueInput
  }

  export type AdditionalDetailCreateNestedOneWithoutUserInput = {
    create?: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutUserInput
    connect?: AdditionalDetailWhereUniqueInput
  }

  export type UserPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type DiversityUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiversityCreateOrConnectWithoutUserInput
    connect?: DiversityWhereUniqueInput
  }

  export type AdditionalDetailUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutUserInput
    connect?: AdditionalDetailWhereUniqueInput
  }

  export type UserPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type MaritalStatusUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<MaritalStatusCreateWithoutUsersInput, MaritalStatusUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutUsersInput
    upsert?: MaritalStatusUpsertWithoutUsersInput
    connect?: MaritalStatusWhereUniqueInput
    update?: XOR<XOR<MaritalStatusUpdateToOneWithWhereWithoutUsersInput, MaritalStatusUpdateWithoutUsersInput>, MaritalStatusUncheckedUpdateWithoutUsersInput>
  }

  export type DiversityUpdateOneWithoutUserNestedInput = {
    create?: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiversityCreateOrConnectWithoutUserInput
    upsert?: DiversityUpsertWithoutUserInput
    disconnect?: DiversityWhereInput | boolean
    delete?: DiversityWhereInput | boolean
    connect?: DiversityWhereUniqueInput
    update?: XOR<XOR<DiversityUpdateToOneWithWhereWithoutUserInput, DiversityUpdateWithoutUserInput>, DiversityUncheckedUpdateWithoutUserInput>
  }

  export type AdditionalDetailUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutUserInput
    upsert?: AdditionalDetailUpsertWithoutUserInput
    disconnect?: AdditionalDetailWhereInput | boolean
    delete?: AdditionalDetailWhereInput | boolean
    connect?: AdditionalDetailWhereUniqueInput
    update?: XOR<XOR<AdditionalDetailUpdateToOneWithWhereWithoutUserInput, AdditionalDetailUpdateWithoutUserInput>, AdditionalDetailUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    upsert?: UserPreferenceUpsertWithoutUserInput
    disconnect?: UserPreferenceWhereInput | boolean
    delete?: UserPreferenceWhereInput | boolean
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutUserInput, UserPreferenceUpdateWithoutUserInput>, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DiversityUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiversityCreateOrConnectWithoutUserInput
    upsert?: DiversityUpsertWithoutUserInput
    disconnect?: DiversityWhereInput | boolean
    delete?: DiversityWhereInput | boolean
    connect?: DiversityWhereUniqueInput
    update?: XOR<XOR<DiversityUpdateToOneWithWhereWithoutUserInput, DiversityUpdateWithoutUserInput>, DiversityUncheckedUpdateWithoutUserInput>
  }

  export type AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutUserInput
    upsert?: AdditionalDetailUpsertWithoutUserInput
    disconnect?: AdditionalDetailWhereInput | boolean
    delete?: AdditionalDetailWhereInput | boolean
    connect?: AdditionalDetailWhereUniqueInput
    update?: XOR<XOR<AdditionalDetailUpdateToOneWithWhereWithoutUserInput, AdditionalDetailUpdateWithoutUserInput>, AdditionalDetailUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    upsert?: UserPreferenceUpsertWithoutUserInput
    disconnect?: UserPreferenceWhereInput | boolean
    delete?: UserPreferenceWhereInput | boolean
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutUserInput, UserPreferenceUpdateWithoutUserInput>, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutDiversityInput = {
    create?: XOR<UserCreateWithoutDiversityInput, UserUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiversityInput
    connect?: UserWhereUniqueInput
  }

  export type ReligionCreateNestedOneWithoutDiversityInput = {
    create?: XOR<ReligionCreateWithoutDiversityInput, ReligionUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutDiversityInput
    connect?: ReligionWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutDiversityInput = {
    create?: XOR<CountryCreateWithoutDiversityInput, CountryUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDiversityInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutDiversityInput = {
    create?: XOR<CityCreateWithoutDiversityInput, CityUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CityCreateOrConnectWithoutDiversityInput
    connect?: CityWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutDiversityInput = {
    create?: XOR<CommunityCreateWithoutDiversityInput, CommunityUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutDiversityInput
    connect?: CommunityWhereUniqueInput
  }

  export type MotherTongueCreateNestedOneWithoutDiversityInput = {
    create?: XOR<MotherTongueCreateWithoutDiversityInput, MotherTongueUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: MotherTongueCreateOrConnectWithoutDiversityInput
    connect?: MotherTongueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<UserCreateWithoutDiversityInput, UserUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiversityInput
    upsert?: UserUpsertWithoutDiversityInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDiversityInput, UserUpdateWithoutDiversityInput>, UserUncheckedUpdateWithoutDiversityInput>
  }

  export type ReligionUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<ReligionCreateWithoutDiversityInput, ReligionUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutDiversityInput
    upsert?: ReligionUpsertWithoutDiversityInput
    connect?: ReligionWhereUniqueInput
    update?: XOR<XOR<ReligionUpdateToOneWithWhereWithoutDiversityInput, ReligionUpdateWithoutDiversityInput>, ReligionUncheckedUpdateWithoutDiversityInput>
  }

  export type CountryUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<CountryCreateWithoutDiversityInput, CountryUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDiversityInput
    upsert?: CountryUpsertWithoutDiversityInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutDiversityInput, CountryUpdateWithoutDiversityInput>, CountryUncheckedUpdateWithoutDiversityInput>
  }

  export type CityUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<CityCreateWithoutDiversityInput, CityUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CityCreateOrConnectWithoutDiversityInput
    upsert?: CityUpsertWithoutDiversityInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutDiversityInput, CityUpdateWithoutDiversityInput>, CityUncheckedUpdateWithoutDiversityInput>
  }

  export type CommunityUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<CommunityCreateWithoutDiversityInput, CommunityUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutDiversityInput
    upsert?: CommunityUpsertWithoutDiversityInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutDiversityInput, CommunityUpdateWithoutDiversityInput>, CommunityUncheckedUpdateWithoutDiversityInput>
  }

  export type MotherTongueUpdateOneRequiredWithoutDiversityNestedInput = {
    create?: XOR<MotherTongueCreateWithoutDiversityInput, MotherTongueUncheckedCreateWithoutDiversityInput>
    connectOrCreate?: MotherTongueCreateOrConnectWithoutDiversityInput
    upsert?: MotherTongueUpsertWithoutDiversityInput
    connect?: MotherTongueWhereUniqueInput
    update?: XOR<XOR<MotherTongueUpdateToOneWithWhereWithoutDiversityInput, MotherTongueUpdateWithoutDiversityInput>, MotherTongueUncheckedUpdateWithoutDiversityInput>
  }

  export type UserCreateNestedOneWithoutAdditionalDetailInput = {
    create?: XOR<UserCreateWithoutAdditionalDetailInput, UserUncheckedCreateWithoutAdditionalDetailInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdditionalDetailInput
    connect?: UserWhereUniqueInput
  }

  export type AstrologyCreateNestedOneWithoutAdditionalDetailInput = {
    create?: XOR<AstrologyCreateWithoutAdditionalDetailInput, AstrologyUncheckedCreateWithoutAdditionalDetailInput>
    connectOrCreate?: AstrologyCreateOrConnectWithoutAdditionalDetailInput
    connect?: AstrologyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdditionalDetailNestedInput = {
    create?: XOR<UserCreateWithoutAdditionalDetailInput, UserUncheckedCreateWithoutAdditionalDetailInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdditionalDetailInput
    upsert?: UserUpsertWithoutAdditionalDetailInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdditionalDetailInput, UserUpdateWithoutAdditionalDetailInput>, UserUncheckedUpdateWithoutAdditionalDetailInput>
  }

  export type AstrologyUpdateOneRequiredWithoutAdditionalDetailNestedInput = {
    create?: XOR<AstrologyCreateWithoutAdditionalDetailInput, AstrologyUncheckedCreateWithoutAdditionalDetailInput>
    connectOrCreate?: AstrologyCreateOrConnectWithoutAdditionalDetailInput
    upsert?: AstrologyUpsertWithoutAdditionalDetailInput
    connect?: AstrologyWhereUniqueInput
    update?: XOR<XOR<AstrologyUpdateToOneWithWhereWithoutAdditionalDetailInput, AstrologyUpdateWithoutAdditionalDetailInput>, AstrologyUncheckedUpdateWithoutAdditionalDetailInput>
  }

  export type UserCreateNestedOneWithoutUserPreferencesInput = {
    create?: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type AstrologyCreateNestedOneWithoutUserPreferenceInput = {
    create?: XOR<AstrologyCreateWithoutUserPreferenceInput, AstrologyUncheckedCreateWithoutUserPreferenceInput>
    connectOrCreate?: AstrologyCreateOrConnectWithoutUserPreferenceInput
    connect?: AstrologyWhereUniqueInput
  }

  export type MaritalStatusCreateNestedOneWithoutUserPreferenceInput = {
    create?: XOR<MaritalStatusCreateWithoutUserPreferenceInput, MaritalStatusUncheckedCreateWithoutUserPreferenceInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutUserPreferenceInput
    connect?: MaritalStatusWhereUniqueInput
  }

  export type PreferredDiversityCreateNestedManyWithoutUserPreferenceInput = {
    create?: XOR<PreferredDiversityCreateWithoutUserPreferenceInput, PreferredDiversityUncheckedCreateWithoutUserPreferenceInput> | PreferredDiversityCreateWithoutUserPreferenceInput[] | PreferredDiversityUncheckedCreateWithoutUserPreferenceInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutUserPreferenceInput | PreferredDiversityCreateOrConnectWithoutUserPreferenceInput[]
    createMany?: PreferredDiversityCreateManyUserPreferenceInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type PreferredDiversityUncheckedCreateNestedManyWithoutUserPreferenceInput = {
    create?: XOR<PreferredDiversityCreateWithoutUserPreferenceInput, PreferredDiversityUncheckedCreateWithoutUserPreferenceInput> | PreferredDiversityCreateWithoutUserPreferenceInput[] | PreferredDiversityUncheckedCreateWithoutUserPreferenceInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutUserPreferenceInput | PreferredDiversityCreateOrConnectWithoutUserPreferenceInput[]
    createMany?: PreferredDiversityCreateManyUserPreferenceInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUserPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPreferencesInput
    upsert?: UserUpsertWithoutUserPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPreferencesInput, UserUpdateWithoutUserPreferencesInput>, UserUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type AstrologyUpdateOneRequiredWithoutUserPreferenceNestedInput = {
    create?: XOR<AstrologyCreateWithoutUserPreferenceInput, AstrologyUncheckedCreateWithoutUserPreferenceInput>
    connectOrCreate?: AstrologyCreateOrConnectWithoutUserPreferenceInput
    upsert?: AstrologyUpsertWithoutUserPreferenceInput
    connect?: AstrologyWhereUniqueInput
    update?: XOR<XOR<AstrologyUpdateToOneWithWhereWithoutUserPreferenceInput, AstrologyUpdateWithoutUserPreferenceInput>, AstrologyUncheckedUpdateWithoutUserPreferenceInput>
  }

  export type MaritalStatusUpdateOneRequiredWithoutUserPreferenceNestedInput = {
    create?: XOR<MaritalStatusCreateWithoutUserPreferenceInput, MaritalStatusUncheckedCreateWithoutUserPreferenceInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutUserPreferenceInput
    upsert?: MaritalStatusUpsertWithoutUserPreferenceInput
    connect?: MaritalStatusWhereUniqueInput
    update?: XOR<XOR<MaritalStatusUpdateToOneWithWhereWithoutUserPreferenceInput, MaritalStatusUpdateWithoutUserPreferenceInput>, MaritalStatusUncheckedUpdateWithoutUserPreferenceInput>
  }

  export type PreferredDiversityUpdateManyWithoutUserPreferenceNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutUserPreferenceInput, PreferredDiversityUncheckedCreateWithoutUserPreferenceInput> | PreferredDiversityCreateWithoutUserPreferenceInput[] | PreferredDiversityUncheckedCreateWithoutUserPreferenceInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutUserPreferenceInput | PreferredDiversityCreateOrConnectWithoutUserPreferenceInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutUserPreferenceInput | PreferredDiversityUpsertWithWhereUniqueWithoutUserPreferenceInput[]
    createMany?: PreferredDiversityCreateManyUserPreferenceInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutUserPreferenceInput | PreferredDiversityUpdateWithWhereUniqueWithoutUserPreferenceInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutUserPreferenceInput | PreferredDiversityUpdateManyWithWhereWithoutUserPreferenceInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutUserPreferenceNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutUserPreferenceInput, PreferredDiversityUncheckedCreateWithoutUserPreferenceInput> | PreferredDiversityCreateWithoutUserPreferenceInput[] | PreferredDiversityUncheckedCreateWithoutUserPreferenceInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutUserPreferenceInput | PreferredDiversityCreateOrConnectWithoutUserPreferenceInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutUserPreferenceInput | PreferredDiversityUpsertWithWhereUniqueWithoutUserPreferenceInput[]
    createMany?: PreferredDiversityCreateManyUserPreferenceInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutUserPreferenceInput | PreferredDiversityUpdateWithWhereUniqueWithoutUserPreferenceInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutUserPreferenceInput | PreferredDiversityUpdateManyWithWhereWithoutUserPreferenceInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type UserPreferenceCreateNestedOneWithoutPreferredDiversityInput = {
    create?: XOR<UserPreferenceCreateWithoutPreferredDiversityInput, UserPreferenceUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutPreferredDiversityInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutPreferredDiversityInput = {
    create?: XOR<CountryCreateWithoutPreferredDiversityInput, CountryUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: CountryCreateOrConnectWithoutPreferredDiversityInput
    connect?: CountryWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutPreferredDiversityInput = {
    create?: XOR<CityCreateWithoutPreferredDiversityInput, CityUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: CityCreateOrConnectWithoutPreferredDiversityInput
    connect?: CityWhereUniqueInput
  }

  export type MotherTongueCreateNestedOneWithoutPreferredDiversityInput = {
    create?: XOR<MotherTongueCreateWithoutPreferredDiversityInput, MotherTongueUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: MotherTongueCreateOrConnectWithoutPreferredDiversityInput
    connect?: MotherTongueWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutPreferredDiversityInput = {
    create?: XOR<CommunityCreateWithoutPreferredDiversityInput, CommunityUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPreferredDiversityInput
    connect?: CommunityWhereUniqueInput
  }

  export type ReligionCreateNestedOneWithoutPreferredDiversityInput = {
    create?: XOR<ReligionCreateWithoutPreferredDiversityInput, ReligionUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutPreferredDiversityInput
    connect?: ReligionWhereUniqueInput
  }

  export type UserPreferenceUpdateOneRequiredWithoutPreferredDiversityNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutPreferredDiversityInput, UserPreferenceUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutPreferredDiversityInput
    upsert?: UserPreferenceUpsertWithoutPreferredDiversityInput
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutPreferredDiversityInput, UserPreferenceUpdateWithoutPreferredDiversityInput>, UserPreferenceUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type CountryUpdateOneRequiredWithoutPreferredDiversityNestedInput = {
    create?: XOR<CountryCreateWithoutPreferredDiversityInput, CountryUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: CountryCreateOrConnectWithoutPreferredDiversityInput
    upsert?: CountryUpsertWithoutPreferredDiversityInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutPreferredDiversityInput, CountryUpdateWithoutPreferredDiversityInput>, CountryUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type CityUpdateOneRequiredWithoutPreferredDiversityNestedInput = {
    create?: XOR<CityCreateWithoutPreferredDiversityInput, CityUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: CityCreateOrConnectWithoutPreferredDiversityInput
    upsert?: CityUpsertWithoutPreferredDiversityInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutPreferredDiversityInput, CityUpdateWithoutPreferredDiversityInput>, CityUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type MotherTongueUpdateOneRequiredWithoutPreferredDiversityNestedInput = {
    create?: XOR<MotherTongueCreateWithoutPreferredDiversityInput, MotherTongueUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: MotherTongueCreateOrConnectWithoutPreferredDiversityInput
    upsert?: MotherTongueUpsertWithoutPreferredDiversityInput
    connect?: MotherTongueWhereUniqueInput
    update?: XOR<XOR<MotherTongueUpdateToOneWithWhereWithoutPreferredDiversityInput, MotherTongueUpdateWithoutPreferredDiversityInput>, MotherTongueUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type CommunityUpdateOneRequiredWithoutPreferredDiversityNestedInput = {
    create?: XOR<CommunityCreateWithoutPreferredDiversityInput, CommunityUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPreferredDiversityInput
    upsert?: CommunityUpsertWithoutPreferredDiversityInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutPreferredDiversityInput, CommunityUpdateWithoutPreferredDiversityInput>, CommunityUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type ReligionUpdateOneRequiredWithoutPreferredDiversityNestedInput = {
    create?: XOR<ReligionCreateWithoutPreferredDiversityInput, ReligionUncheckedCreateWithoutPreferredDiversityInput>
    connectOrCreate?: ReligionCreateOrConnectWithoutPreferredDiversityInput
    upsert?: ReligionUpsertWithoutPreferredDiversityInput
    connect?: ReligionWhereUniqueInput
    update?: XOR<XOR<ReligionUpdateToOneWithWhereWithoutPreferredDiversityInput, ReligionUpdateWithoutPreferredDiversityInput>, ReligionUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type UserCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput> | UserCreateWithoutMaritalStatusInput[] | UserUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMaritalStatusInput | UserCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: UserCreateManyMaritalStatusInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserPreferenceCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<UserPreferenceCreateWithoutMaritalStatusInput, UserPreferenceUncheckedCreateWithoutMaritalStatusInput> | UserPreferenceCreateWithoutMaritalStatusInput[] | UserPreferenceUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutMaritalStatusInput | UserPreferenceCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: UserPreferenceCreateManyMaritalStatusInputEnvelope
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput> | UserCreateWithoutMaritalStatusInput[] | UserUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMaritalStatusInput | UserCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: UserCreateManyMaritalStatusInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserPreferenceUncheckedCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<UserPreferenceCreateWithoutMaritalStatusInput, UserPreferenceUncheckedCreateWithoutMaritalStatusInput> | UserPreferenceCreateWithoutMaritalStatusInput[] | UserPreferenceUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutMaritalStatusInput | UserPreferenceCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: UserPreferenceCreateManyMaritalStatusInputEnvelope
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput> | UserCreateWithoutMaritalStatusInput[] | UserUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMaritalStatusInput | UserCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMaritalStatusInput | UserUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: UserCreateManyMaritalStatusInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMaritalStatusInput | UserUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMaritalStatusInput | UserUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserPreferenceUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutMaritalStatusInput, UserPreferenceUncheckedCreateWithoutMaritalStatusInput> | UserPreferenceCreateWithoutMaritalStatusInput[] | UserPreferenceUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutMaritalStatusInput | UserPreferenceCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: UserPreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput | UserPreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: UserPreferenceCreateManyMaritalStatusInputEnvelope
    set?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    disconnect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    delete?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    update?: UserPreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput | UserPreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: UserPreferenceUpdateManyWithWhereWithoutMaritalStatusInput | UserPreferenceUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput> | UserCreateWithoutMaritalStatusInput[] | UserUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMaritalStatusInput | UserCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMaritalStatusInput | UserUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: UserCreateManyMaritalStatusInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMaritalStatusInput | UserUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMaritalStatusInput | UserUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserPreferenceUncheckedUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutMaritalStatusInput, UserPreferenceUncheckedCreateWithoutMaritalStatusInput> | UserPreferenceCreateWithoutMaritalStatusInput[] | UserPreferenceUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutMaritalStatusInput | UserPreferenceCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: UserPreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput | UserPreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: UserPreferenceCreateManyMaritalStatusInputEnvelope
    set?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    disconnect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    delete?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    update?: UserPreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput | UserPreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: UserPreferenceUpdateManyWithWhereWithoutMaritalStatusInput | UserPreferenceUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
  }

  export type DiversityCreateNestedManyWithoutReligionInput = {
    create?: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput> | DiversityCreateWithoutReligionInput[] | DiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutReligionInput | DiversityCreateOrConnectWithoutReligionInput[]
    createMany?: DiversityCreateManyReligionInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityCreateNestedManyWithoutReligionInput = {
    create?: XOR<PreferredDiversityCreateWithoutReligionInput, PreferredDiversityUncheckedCreateWithoutReligionInput> | PreferredDiversityCreateWithoutReligionInput[] | PreferredDiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutReligionInput | PreferredDiversityCreateOrConnectWithoutReligionInput[]
    createMany?: PreferredDiversityCreateManyReligionInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutReligionInput = {
    create?: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput> | DiversityCreateWithoutReligionInput[] | DiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutReligionInput | DiversityCreateOrConnectWithoutReligionInput[]
    createMany?: DiversityCreateManyReligionInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityUncheckedCreateNestedManyWithoutReligionInput = {
    create?: XOR<PreferredDiversityCreateWithoutReligionInput, PreferredDiversityUncheckedCreateWithoutReligionInput> | PreferredDiversityCreateWithoutReligionInput[] | PreferredDiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutReligionInput | PreferredDiversityCreateOrConnectWithoutReligionInput[]
    createMany?: PreferredDiversityCreateManyReligionInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type DiversityUpdateManyWithoutReligionNestedInput = {
    create?: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput> | DiversityCreateWithoutReligionInput[] | DiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutReligionInput | DiversityCreateOrConnectWithoutReligionInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutReligionInput | DiversityUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: DiversityCreateManyReligionInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutReligionInput | DiversityUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutReligionInput | DiversityUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUpdateManyWithoutReligionNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutReligionInput, PreferredDiversityUncheckedCreateWithoutReligionInput> | PreferredDiversityCreateWithoutReligionInput[] | PreferredDiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutReligionInput | PreferredDiversityCreateOrConnectWithoutReligionInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutReligionInput | PreferredDiversityUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: PreferredDiversityCreateManyReligionInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutReligionInput | PreferredDiversityUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutReligionInput | PreferredDiversityUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutReligionNestedInput = {
    create?: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput> | DiversityCreateWithoutReligionInput[] | DiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutReligionInput | DiversityCreateOrConnectWithoutReligionInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutReligionInput | DiversityUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: DiversityCreateManyReligionInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutReligionInput | DiversityUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutReligionInput | DiversityUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutReligionNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutReligionInput, PreferredDiversityUncheckedCreateWithoutReligionInput> | PreferredDiversityCreateWithoutReligionInput[] | PreferredDiversityUncheckedCreateWithoutReligionInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutReligionInput | PreferredDiversityCreateOrConnectWithoutReligionInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutReligionInput | PreferredDiversityUpsertWithWhereUniqueWithoutReligionInput[]
    createMany?: PreferredDiversityCreateManyReligionInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutReligionInput | PreferredDiversityUpdateWithWhereUniqueWithoutReligionInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutReligionInput | PreferredDiversityUpdateManyWithWhereWithoutReligionInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type CityCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type DiversityCreateNestedManyWithoutCountryInput = {
    create?: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput> | DiversityCreateWithoutCountryInput[] | DiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCountryInput | DiversityCreateOrConnectWithoutCountryInput[]
    createMany?: DiversityCreateManyCountryInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityCreateNestedManyWithoutCountryInput = {
    create?: XOR<PreferredDiversityCreateWithoutCountryInput, PreferredDiversityUncheckedCreateWithoutCountryInput> | PreferredDiversityCreateWithoutCountryInput[] | PreferredDiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCountryInput | PreferredDiversityCreateOrConnectWithoutCountryInput[]
    createMany?: PreferredDiversityCreateManyCountryInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput> | DiversityCreateWithoutCountryInput[] | DiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCountryInput | DiversityCreateOrConnectWithoutCountryInput[]
    createMany?: DiversityCreateManyCountryInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<PreferredDiversityCreateWithoutCountryInput, PreferredDiversityUncheckedCreateWithoutCountryInput> | PreferredDiversityCreateWithoutCountryInput[] | PreferredDiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCountryInput | PreferredDiversityCreateOrConnectWithoutCountryInput[]
    createMany?: PreferredDiversityCreateManyCountryInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type CityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type DiversityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput> | DiversityCreateWithoutCountryInput[] | DiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCountryInput | DiversityCreateOrConnectWithoutCountryInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCountryInput | DiversityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: DiversityCreateManyCountryInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCountryInput | DiversityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCountryInput | DiversityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutCountryInput, PreferredDiversityUncheckedCreateWithoutCountryInput> | PreferredDiversityCreateWithoutCountryInput[] | PreferredDiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCountryInput | PreferredDiversityCreateOrConnectWithoutCountryInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutCountryInput | PreferredDiversityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PreferredDiversityCreateManyCountryInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutCountryInput | PreferredDiversityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutCountryInput | PreferredDiversityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput> | CityCreateWithoutCountryInput[] | CityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CityCreateOrConnectWithoutCountryInput | CityCreateOrConnectWithoutCountryInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutCountryInput | CityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CityCreateManyCountryInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutCountryInput | CityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CityUpdateManyWithWhereWithoutCountryInput | CityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput> | DiversityCreateWithoutCountryInput[] | DiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCountryInput | DiversityCreateOrConnectWithoutCountryInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCountryInput | DiversityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: DiversityCreateManyCountryInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCountryInput | DiversityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCountryInput | DiversityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutCountryInput, PreferredDiversityUncheckedCreateWithoutCountryInput> | PreferredDiversityCreateWithoutCountryInput[] | PreferredDiversityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCountryInput | PreferredDiversityCreateOrConnectWithoutCountryInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutCountryInput | PreferredDiversityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PreferredDiversityCreateManyCountryInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutCountryInput | PreferredDiversityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutCountryInput | PreferredDiversityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type DiversityCreateNestedManyWithoutCityInput = {
    create?: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput> | DiversityCreateWithoutCityInput[] | DiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCityInput | DiversityCreateOrConnectWithoutCityInput[]
    createMany?: DiversityCreateManyCityInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityCreateNestedManyWithoutCityInput = {
    create?: XOR<PreferredDiversityCreateWithoutCityInput, PreferredDiversityUncheckedCreateWithoutCityInput> | PreferredDiversityCreateWithoutCityInput[] | PreferredDiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCityInput | PreferredDiversityCreateOrConnectWithoutCityInput[]
    createMany?: PreferredDiversityCreateManyCityInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput> | DiversityCreateWithoutCityInput[] | DiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCityInput | DiversityCreateOrConnectWithoutCityInput[]
    createMany?: DiversityCreateManyCityInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<PreferredDiversityCreateWithoutCityInput, PreferredDiversityUncheckedCreateWithoutCityInput> | PreferredDiversityCreateWithoutCityInput[] | PreferredDiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCityInput | PreferredDiversityCreateOrConnectWithoutCityInput[]
    createMany?: PreferredDiversityCreateManyCityInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCitiesInput, CountryUpdateWithoutCitiesInput>, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type DiversityUpdateManyWithoutCityNestedInput = {
    create?: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput> | DiversityCreateWithoutCityInput[] | DiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCityInput | DiversityCreateOrConnectWithoutCityInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCityInput | DiversityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DiversityCreateManyCityInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCityInput | DiversityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCityInput | DiversityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUpdateManyWithoutCityNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutCityInput, PreferredDiversityUncheckedCreateWithoutCityInput> | PreferredDiversityCreateWithoutCityInput[] | PreferredDiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCityInput | PreferredDiversityCreateOrConnectWithoutCityInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutCityInput | PreferredDiversityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: PreferredDiversityCreateManyCityInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutCityInput | PreferredDiversityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutCityInput | PreferredDiversityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput> | DiversityCreateWithoutCityInput[] | DiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCityInput | DiversityCreateOrConnectWithoutCityInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCityInput | DiversityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: DiversityCreateManyCityInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCityInput | DiversityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCityInput | DiversityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutCityInput, PreferredDiversityUncheckedCreateWithoutCityInput> | PreferredDiversityCreateWithoutCityInput[] | PreferredDiversityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCityInput | PreferredDiversityCreateOrConnectWithoutCityInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutCityInput | PreferredDiversityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: PreferredDiversityCreateManyCityInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutCityInput | PreferredDiversityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutCityInput | PreferredDiversityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type DiversityCreateNestedManyWithoutCommunityInput = {
    create?: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput> | DiversityCreateWithoutCommunityInput[] | DiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCommunityInput | DiversityCreateOrConnectWithoutCommunityInput[]
    createMany?: DiversityCreateManyCommunityInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PreferredDiversityCreateWithoutCommunityInput, PreferredDiversityUncheckedCreateWithoutCommunityInput> | PreferredDiversityCreateWithoutCommunityInput[] | PreferredDiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCommunityInput | PreferredDiversityCreateOrConnectWithoutCommunityInput[]
    createMany?: PreferredDiversityCreateManyCommunityInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput> | DiversityCreateWithoutCommunityInput[] | DiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCommunityInput | DiversityCreateOrConnectWithoutCommunityInput[]
    createMany?: DiversityCreateManyCommunityInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PreferredDiversityCreateWithoutCommunityInput, PreferredDiversityUncheckedCreateWithoutCommunityInput> | PreferredDiversityCreateWithoutCommunityInput[] | PreferredDiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCommunityInput | PreferredDiversityCreateOrConnectWithoutCommunityInput[]
    createMany?: PreferredDiversityCreateManyCommunityInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type DiversityUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput> | DiversityCreateWithoutCommunityInput[] | DiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCommunityInput | DiversityCreateOrConnectWithoutCommunityInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCommunityInput | DiversityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: DiversityCreateManyCommunityInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCommunityInput | DiversityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCommunityInput | DiversityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutCommunityInput, PreferredDiversityUncheckedCreateWithoutCommunityInput> | PreferredDiversityCreateWithoutCommunityInput[] | PreferredDiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCommunityInput | PreferredDiversityCreateOrConnectWithoutCommunityInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutCommunityInput | PreferredDiversityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PreferredDiversityCreateManyCommunityInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutCommunityInput | PreferredDiversityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutCommunityInput | PreferredDiversityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput> | DiversityCreateWithoutCommunityInput[] | DiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutCommunityInput | DiversityCreateOrConnectWithoutCommunityInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutCommunityInput | DiversityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: DiversityCreateManyCommunityInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutCommunityInput | DiversityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutCommunityInput | DiversityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutCommunityInput, PreferredDiversityUncheckedCreateWithoutCommunityInput> | PreferredDiversityCreateWithoutCommunityInput[] | PreferredDiversityUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutCommunityInput | PreferredDiversityCreateOrConnectWithoutCommunityInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutCommunityInput | PreferredDiversityUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PreferredDiversityCreateManyCommunityInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutCommunityInput | PreferredDiversityUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutCommunityInput | PreferredDiversityUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type DiversityCreateNestedManyWithoutMotherTongueInput = {
    create?: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput> | DiversityCreateWithoutMotherTongueInput[] | DiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutMotherTongueInput | DiversityCreateOrConnectWithoutMotherTongueInput[]
    createMany?: DiversityCreateManyMotherTongueInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityCreateNestedManyWithoutMotherTongueInput = {
    create?: XOR<PreferredDiversityCreateWithoutMotherTongueInput, PreferredDiversityUncheckedCreateWithoutMotherTongueInput> | PreferredDiversityCreateWithoutMotherTongueInput[] | PreferredDiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutMotherTongueInput | PreferredDiversityCreateOrConnectWithoutMotherTongueInput[]
    createMany?: PreferredDiversityCreateManyMotherTongueInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type DiversityUncheckedCreateNestedManyWithoutMotherTongueInput = {
    create?: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput> | DiversityCreateWithoutMotherTongueInput[] | DiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutMotherTongueInput | DiversityCreateOrConnectWithoutMotherTongueInput[]
    createMany?: DiversityCreateManyMotherTongueInputEnvelope
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
  }

  export type PreferredDiversityUncheckedCreateNestedManyWithoutMotherTongueInput = {
    create?: XOR<PreferredDiversityCreateWithoutMotherTongueInput, PreferredDiversityUncheckedCreateWithoutMotherTongueInput> | PreferredDiversityCreateWithoutMotherTongueInput[] | PreferredDiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutMotherTongueInput | PreferredDiversityCreateOrConnectWithoutMotherTongueInput[]
    createMany?: PreferredDiversityCreateManyMotherTongueInputEnvelope
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
  }

  export type DiversityUpdateManyWithoutMotherTongueNestedInput = {
    create?: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput> | DiversityCreateWithoutMotherTongueInput[] | DiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutMotherTongueInput | DiversityCreateOrConnectWithoutMotherTongueInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutMotherTongueInput | DiversityUpsertWithWhereUniqueWithoutMotherTongueInput[]
    createMany?: DiversityCreateManyMotherTongueInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutMotherTongueInput | DiversityUpdateWithWhereUniqueWithoutMotherTongueInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutMotherTongueInput | DiversityUpdateManyWithWhereWithoutMotherTongueInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUpdateManyWithoutMotherTongueNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutMotherTongueInput, PreferredDiversityUncheckedCreateWithoutMotherTongueInput> | PreferredDiversityCreateWithoutMotherTongueInput[] | PreferredDiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutMotherTongueInput | PreferredDiversityCreateOrConnectWithoutMotherTongueInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutMotherTongueInput | PreferredDiversityUpsertWithWhereUniqueWithoutMotherTongueInput[]
    createMany?: PreferredDiversityCreateManyMotherTongueInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutMotherTongueInput | PreferredDiversityUpdateWithWhereUniqueWithoutMotherTongueInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutMotherTongueInput | PreferredDiversityUpdateManyWithWhereWithoutMotherTongueInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type DiversityUncheckedUpdateManyWithoutMotherTongueNestedInput = {
    create?: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput> | DiversityCreateWithoutMotherTongueInput[] | DiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: DiversityCreateOrConnectWithoutMotherTongueInput | DiversityCreateOrConnectWithoutMotherTongueInput[]
    upsert?: DiversityUpsertWithWhereUniqueWithoutMotherTongueInput | DiversityUpsertWithWhereUniqueWithoutMotherTongueInput[]
    createMany?: DiversityCreateManyMotherTongueInputEnvelope
    set?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    disconnect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    delete?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    connect?: DiversityWhereUniqueInput | DiversityWhereUniqueInput[]
    update?: DiversityUpdateWithWhereUniqueWithoutMotherTongueInput | DiversityUpdateWithWhereUniqueWithoutMotherTongueInput[]
    updateMany?: DiversityUpdateManyWithWhereWithoutMotherTongueInput | DiversityUpdateManyWithWhereWithoutMotherTongueInput[]
    deleteMany?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutMotherTongueNestedInput = {
    create?: XOR<PreferredDiversityCreateWithoutMotherTongueInput, PreferredDiversityUncheckedCreateWithoutMotherTongueInput> | PreferredDiversityCreateWithoutMotherTongueInput[] | PreferredDiversityUncheckedCreateWithoutMotherTongueInput[]
    connectOrCreate?: PreferredDiversityCreateOrConnectWithoutMotherTongueInput | PreferredDiversityCreateOrConnectWithoutMotherTongueInput[]
    upsert?: PreferredDiversityUpsertWithWhereUniqueWithoutMotherTongueInput | PreferredDiversityUpsertWithWhereUniqueWithoutMotherTongueInput[]
    createMany?: PreferredDiversityCreateManyMotherTongueInputEnvelope
    set?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    disconnect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    delete?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    connect?: PreferredDiversityWhereUniqueInput | PreferredDiversityWhereUniqueInput[]
    update?: PreferredDiversityUpdateWithWhereUniqueWithoutMotherTongueInput | PreferredDiversityUpdateWithWhereUniqueWithoutMotherTongueInput[]
    updateMany?: PreferredDiversityUpdateManyWithWhereWithoutMotherTongueInput | PreferredDiversityUpdateManyWithWhereWithoutMotherTongueInput[]
    deleteMany?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
  }

  export type AdditionalDetailCreateNestedManyWithoutAstrologyInput = {
    create?: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput> | AdditionalDetailCreateWithoutAstrologyInput[] | AdditionalDetailUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutAstrologyInput | AdditionalDetailCreateOrConnectWithoutAstrologyInput[]
    createMany?: AdditionalDetailCreateManyAstrologyInputEnvelope
    connect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
  }

  export type UserPreferenceCreateNestedManyWithoutAstrologyInput = {
    create?: XOR<UserPreferenceCreateWithoutAstrologyInput, UserPreferenceUncheckedCreateWithoutAstrologyInput> | UserPreferenceCreateWithoutAstrologyInput[] | UserPreferenceUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutAstrologyInput | UserPreferenceCreateOrConnectWithoutAstrologyInput[]
    createMany?: UserPreferenceCreateManyAstrologyInputEnvelope
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
  }

  export type AdditionalDetailUncheckedCreateNestedManyWithoutAstrologyInput = {
    create?: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput> | AdditionalDetailCreateWithoutAstrologyInput[] | AdditionalDetailUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutAstrologyInput | AdditionalDetailCreateOrConnectWithoutAstrologyInput[]
    createMany?: AdditionalDetailCreateManyAstrologyInputEnvelope
    connect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
  }

  export type UserPreferenceUncheckedCreateNestedManyWithoutAstrologyInput = {
    create?: XOR<UserPreferenceCreateWithoutAstrologyInput, UserPreferenceUncheckedCreateWithoutAstrologyInput> | UserPreferenceCreateWithoutAstrologyInput[] | UserPreferenceUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutAstrologyInput | UserPreferenceCreateOrConnectWithoutAstrologyInput[]
    createMany?: UserPreferenceCreateManyAstrologyInputEnvelope
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
  }

  export type AdditionalDetailUpdateManyWithoutAstrologyNestedInput = {
    create?: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput> | AdditionalDetailCreateWithoutAstrologyInput[] | AdditionalDetailUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutAstrologyInput | AdditionalDetailCreateOrConnectWithoutAstrologyInput[]
    upsert?: AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput | AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput[]
    createMany?: AdditionalDetailCreateManyAstrologyInputEnvelope
    set?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    disconnect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    delete?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    connect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    update?: AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput | AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput[]
    updateMany?: AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput | AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput[]
    deleteMany?: AdditionalDetailScalarWhereInput | AdditionalDetailScalarWhereInput[]
  }

  export type UserPreferenceUpdateManyWithoutAstrologyNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutAstrologyInput, UserPreferenceUncheckedCreateWithoutAstrologyInput> | UserPreferenceCreateWithoutAstrologyInput[] | UserPreferenceUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutAstrologyInput | UserPreferenceCreateOrConnectWithoutAstrologyInput[]
    upsert?: UserPreferenceUpsertWithWhereUniqueWithoutAstrologyInput | UserPreferenceUpsertWithWhereUniqueWithoutAstrologyInput[]
    createMany?: UserPreferenceCreateManyAstrologyInputEnvelope
    set?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    disconnect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    delete?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    update?: UserPreferenceUpdateWithWhereUniqueWithoutAstrologyInput | UserPreferenceUpdateWithWhereUniqueWithoutAstrologyInput[]
    updateMany?: UserPreferenceUpdateManyWithWhereWithoutAstrologyInput | UserPreferenceUpdateManyWithWhereWithoutAstrologyInput[]
    deleteMany?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
  }

  export type AdditionalDetailUncheckedUpdateManyWithoutAstrologyNestedInput = {
    create?: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput> | AdditionalDetailCreateWithoutAstrologyInput[] | AdditionalDetailUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: AdditionalDetailCreateOrConnectWithoutAstrologyInput | AdditionalDetailCreateOrConnectWithoutAstrologyInput[]
    upsert?: AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput | AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput[]
    createMany?: AdditionalDetailCreateManyAstrologyInputEnvelope
    set?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    disconnect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    delete?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    connect?: AdditionalDetailWhereUniqueInput | AdditionalDetailWhereUniqueInput[]
    update?: AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput | AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput[]
    updateMany?: AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput | AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput[]
    deleteMany?: AdditionalDetailScalarWhereInput | AdditionalDetailScalarWhereInput[]
  }

  export type UserPreferenceUncheckedUpdateManyWithoutAstrologyNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutAstrologyInput, UserPreferenceUncheckedCreateWithoutAstrologyInput> | UserPreferenceCreateWithoutAstrologyInput[] | UserPreferenceUncheckedCreateWithoutAstrologyInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutAstrologyInput | UserPreferenceCreateOrConnectWithoutAstrologyInput[]
    upsert?: UserPreferenceUpsertWithWhereUniqueWithoutAstrologyInput | UserPreferenceUpsertWithWhereUniqueWithoutAstrologyInput[]
    createMany?: UserPreferenceCreateManyAstrologyInputEnvelope
    set?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    disconnect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    delete?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    update?: UserPreferenceUpdateWithWhereUniqueWithoutAstrologyInput | UserPreferenceUpdateWithWhereUniqueWithoutAstrologyInput[]
    updateMany?: UserPreferenceUpdateManyWithWhereWithoutAstrologyInput | UserPreferenceUpdateManyWithWhereWithoutAstrologyInput[]
    deleteMany?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type MaritalStatusCreateWithoutUsersInput = {
    title: string
    UserPreference?: UserPreferenceCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    UserPreference?: UserPreferenceUncheckedCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusCreateOrConnectWithoutUsersInput = {
    where: MaritalStatusWhereUniqueInput
    create: XOR<MaritalStatusCreateWithoutUsersInput, MaritalStatusUncheckedCreateWithoutUsersInput>
  }

  export type DiversityCreateWithoutUserInput = {
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutUserInput = {
    id?: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutUserInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
  }

  export type AdditionalDetailCreateWithoutUserInput = {
    facebookProfileLink: string
    contactNumber: string
    astrology?: AstrologyCreateNestedOneWithoutAdditionalDetailInput
  }

  export type AdditionalDetailUncheckedCreateWithoutUserInput = {
    id?: number
    astrologicalId?: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailCreateOrConnectWithoutUserInput = {
    where: AdditionalDetailWhereUniqueInput
    create: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
  }

  export type UserPreferenceCreateWithoutUserInput = {
    gender: string
    minAge: number
    maxAge: number
    astrology?: AstrologyCreateNestedOneWithoutUserPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutUserPreferenceInput
    preferredDiversity?: PreferredDiversityCreateNestedManyWithoutUserPreferenceInput
  }

  export type UserPreferenceUncheckedCreateWithoutUserInput = {
    id?: number
    gender: string
    minAge: number
    maxAge: number
    astrologicalId?: number
    maritalStatusId: number
    preferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutUserPreferenceInput
  }

  export type UserPreferenceCreateOrConnectWithoutUserInput = {
    where: UserPreferenceWhereUniqueInput
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
  }

  export type MaritalStatusUpsertWithoutUsersInput = {
    update: XOR<MaritalStatusUpdateWithoutUsersInput, MaritalStatusUncheckedUpdateWithoutUsersInput>
    create: XOR<MaritalStatusCreateWithoutUsersInput, MaritalStatusUncheckedCreateWithoutUsersInput>
    where?: MaritalStatusWhereInput
  }

  export type MaritalStatusUpdateToOneWithWhereWithoutUsersInput = {
    where?: MaritalStatusWhereInput
    data: XOR<MaritalStatusUpdateWithoutUsersInput, MaritalStatusUncheckedUpdateWithoutUsersInput>
  }

  export type MaritalStatusUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    UserPreference?: UserPreferenceUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    UserPreference?: UserPreferenceUncheckedUpdateManyWithoutMaritalStatusNestedInput
  }

  export type DiversityUpsertWithoutUserInput = {
    update: XOR<DiversityUpdateWithoutUserInput, DiversityUncheckedUpdateWithoutUserInput>
    create: XOR<DiversityCreateWithoutUserInput, DiversityUncheckedCreateWithoutUserInput>
    where?: DiversityWhereInput
  }

  export type DiversityUpdateToOneWithWhereWithoutUserInput = {
    where?: DiversityWhereInput
    data: XOR<DiversityUpdateWithoutUserInput, DiversityUncheckedUpdateWithoutUserInput>
  }

  export type DiversityUpdateWithoutUserInput = {
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type AdditionalDetailUpsertWithoutUserInput = {
    update: XOR<AdditionalDetailUpdateWithoutUserInput, AdditionalDetailUncheckedUpdateWithoutUserInput>
    create: XOR<AdditionalDetailCreateWithoutUserInput, AdditionalDetailUncheckedCreateWithoutUserInput>
    where?: AdditionalDetailWhereInput
  }

  export type AdditionalDetailUpdateToOneWithWhereWithoutUserInput = {
    where?: AdditionalDetailWhereInput
    data: XOR<AdditionalDetailUpdateWithoutUserInput, AdditionalDetailUncheckedUpdateWithoutUserInput>
  }

  export type AdditionalDetailUpdateWithoutUserInput = {
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    astrology?: AstrologyUpdateOneRequiredWithoutAdditionalDetailNestedInput
  }

  export type AdditionalDetailUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type UserPreferenceUpsertWithoutUserInput = {
    update: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    where?: UserPreferenceWhereInput
  }

  export type UserPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferenceWhereInput
    data: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUpdateWithoutUserInput = {
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    astrology?: AstrologyUpdateOneRequiredWithoutUserPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUserPreferenceNestedInput
    preferredDiversity?: PreferredDiversityUpdateManyWithoutUserPreferenceNestedInput
  }

  export type UserPreferenceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    preferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutUserPreferenceNestedInput
  }

  export type UserCreateWithoutDiversityInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    userPreferences?: UserPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDiversityInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    userPreferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDiversityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDiversityInput, UserUncheckedCreateWithoutDiversityInput>
  }

  export type ReligionCreateWithoutDiversityInput = {
    title: string
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionCreateOrConnectWithoutDiversityInput = {
    where: ReligionWhereUniqueInput
    create: XOR<ReligionCreateWithoutDiversityInput, ReligionUncheckedCreateWithoutDiversityInput>
  }

  export type CountryCreateWithoutDiversityInput = {
    title: string
    cities?: CityCreateNestedManyWithoutCountryInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutDiversityInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutDiversityInput, CountryUncheckedCreateWithoutDiversityInput>
  }

  export type CityCreateWithoutDiversityInput = {
    title: string
    country: CountryCreateNestedOneWithoutCitiesInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    countryId: number
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutDiversityInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutDiversityInput, CityUncheckedCreateWithoutDiversityInput>
  }

  export type CommunityCreateWithoutDiversityInput = {
    title: string
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutDiversityInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutDiversityInput, CommunityUncheckedCreateWithoutDiversityInput>
  }

  export type MotherTongueCreateWithoutDiversityInput = {
    title: string
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueUncheckedCreateWithoutDiversityInput = {
    id?: number
    title: string
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueCreateOrConnectWithoutDiversityInput = {
    where: MotherTongueWhereUniqueInput
    create: XOR<MotherTongueCreateWithoutDiversityInput, MotherTongueUncheckedCreateWithoutDiversityInput>
  }

  export type UserUpsertWithoutDiversityInput = {
    update: XOR<UserUpdateWithoutDiversityInput, UserUncheckedUpdateWithoutDiversityInput>
    create: XOR<UserCreateWithoutDiversityInput, UserUncheckedCreateWithoutDiversityInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDiversityInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDiversityInput, UserUncheckedUpdateWithoutDiversityInput>
  }

  export type UserUpdateWithoutDiversityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    userPreferences?: UserPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    userPreferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ReligionUpsertWithoutDiversityInput = {
    update: XOR<ReligionUpdateWithoutDiversityInput, ReligionUncheckedUpdateWithoutDiversityInput>
    create: XOR<ReligionCreateWithoutDiversityInput, ReligionUncheckedCreateWithoutDiversityInput>
    where?: ReligionWhereInput
  }

  export type ReligionUpdateToOneWithWhereWithoutDiversityInput = {
    where?: ReligionWhereInput
    data: XOR<ReligionUpdateWithoutDiversityInput, ReligionUncheckedUpdateWithoutDiversityInput>
  }

  export type ReligionUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type CountryUpsertWithoutDiversityInput = {
    update: XOR<CountryUpdateWithoutDiversityInput, CountryUncheckedUpdateWithoutDiversityInput>
    create: XOR<CountryCreateWithoutDiversityInput, CountryUncheckedCreateWithoutDiversityInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutDiversityInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutDiversityInput, CountryUncheckedUpdateWithoutDiversityInput>
  }

  export type CountryUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CityUpsertWithoutDiversityInput = {
    update: XOR<CityUpdateWithoutDiversityInput, CityUncheckedUpdateWithoutDiversityInput>
    create: XOR<CityCreateWithoutDiversityInput, CityUncheckedCreateWithoutDiversityInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutDiversityInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutDiversityInput, CityUncheckedUpdateWithoutDiversityInput>
  }

  export type CityUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CommunityUpsertWithoutDiversityInput = {
    update: XOR<CommunityUpdateWithoutDiversityInput, CommunityUncheckedUpdateWithoutDiversityInput>
    create: XOR<CommunityCreateWithoutDiversityInput, CommunityUncheckedCreateWithoutDiversityInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutDiversityInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutDiversityInput, CommunityUncheckedUpdateWithoutDiversityInput>
  }

  export type CommunityUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type MotherTongueUpsertWithoutDiversityInput = {
    update: XOR<MotherTongueUpdateWithoutDiversityInput, MotherTongueUncheckedUpdateWithoutDiversityInput>
    create: XOR<MotherTongueCreateWithoutDiversityInput, MotherTongueUncheckedCreateWithoutDiversityInput>
    where?: MotherTongueWhereInput
  }

  export type MotherTongueUpdateToOneWithWhereWithoutDiversityInput = {
    where?: MotherTongueWhereInput
    data: XOR<MotherTongueUpdateWithoutDiversityInput, MotherTongueUncheckedUpdateWithoutDiversityInput>
  }

  export type MotherTongueUpdateWithoutDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutMotherTongueNestedInput
  }

  export type MotherTongueUncheckedUpdateWithoutDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutMotherTongueNestedInput
  }

  export type UserCreateWithoutAdditionalDetailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    diversity?: DiversityCreateNestedOneWithoutUserInput
    userPreferences?: UserPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdditionalDetailInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    userPreferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdditionalDetailInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdditionalDetailInput, UserUncheckedCreateWithoutAdditionalDetailInput>
  }

  export type AstrologyCreateWithoutAdditionalDetailInput = {
    title: string
    UserPreference?: UserPreferenceCreateNestedManyWithoutAstrologyInput
  }

  export type AstrologyUncheckedCreateWithoutAdditionalDetailInput = {
    id?: number
    title: string
    UserPreference?: UserPreferenceUncheckedCreateNestedManyWithoutAstrologyInput
  }

  export type AstrologyCreateOrConnectWithoutAdditionalDetailInput = {
    where: AstrologyWhereUniqueInput
    create: XOR<AstrologyCreateWithoutAdditionalDetailInput, AstrologyUncheckedCreateWithoutAdditionalDetailInput>
  }

  export type UserUpsertWithoutAdditionalDetailInput = {
    update: XOR<UserUpdateWithoutAdditionalDetailInput, UserUncheckedUpdateWithoutAdditionalDetailInput>
    create: XOR<UserCreateWithoutAdditionalDetailInput, UserUncheckedCreateWithoutAdditionalDetailInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdditionalDetailInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdditionalDetailInput, UserUncheckedUpdateWithoutAdditionalDetailInput>
  }

  export type UserUpdateWithoutAdditionalDetailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    userPreferences?: UserPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdditionalDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    userPreferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AstrologyUpsertWithoutAdditionalDetailInput = {
    update: XOR<AstrologyUpdateWithoutAdditionalDetailInput, AstrologyUncheckedUpdateWithoutAdditionalDetailInput>
    create: XOR<AstrologyCreateWithoutAdditionalDetailInput, AstrologyUncheckedCreateWithoutAdditionalDetailInput>
    where?: AstrologyWhereInput
  }

  export type AstrologyUpdateToOneWithWhereWithoutAdditionalDetailInput = {
    where?: AstrologyWhereInput
    data: XOR<AstrologyUpdateWithoutAdditionalDetailInput, AstrologyUncheckedUpdateWithoutAdditionalDetailInput>
  }

  export type AstrologyUpdateWithoutAdditionalDetailInput = {
    title?: StringFieldUpdateOperationsInput | string
    UserPreference?: UserPreferenceUpdateManyWithoutAstrologyNestedInput
  }

  export type AstrologyUncheckedUpdateWithoutAdditionalDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    UserPreference?: UserPreferenceUncheckedUpdateManyWithoutAstrologyNestedInput
  }

  export type UserCreateWithoutUserPreferencesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    maritalStatus: MaritalStatusCreateNestedOneWithoutUsersInput
    diversity?: DiversityCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPreferencesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    maritalStatusId: number
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
  }

  export type AstrologyCreateWithoutUserPreferenceInput = {
    title: string
    AdditionalDetail?: AdditionalDetailCreateNestedManyWithoutAstrologyInput
  }

  export type AstrologyUncheckedCreateWithoutUserPreferenceInput = {
    id?: number
    title: string
    AdditionalDetail?: AdditionalDetailUncheckedCreateNestedManyWithoutAstrologyInput
  }

  export type AstrologyCreateOrConnectWithoutUserPreferenceInput = {
    where: AstrologyWhereUniqueInput
    create: XOR<AstrologyCreateWithoutUserPreferenceInput, AstrologyUncheckedCreateWithoutUserPreferenceInput>
  }

  export type MaritalStatusCreateWithoutUserPreferenceInput = {
    title: string
    users?: UserCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUncheckedCreateWithoutUserPreferenceInput = {
    id?: number
    title: string
    users?: UserUncheckedCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusCreateOrConnectWithoutUserPreferenceInput = {
    where: MaritalStatusWhereUniqueInput
    create: XOR<MaritalStatusCreateWithoutUserPreferenceInput, MaritalStatusUncheckedCreateWithoutUserPreferenceInput>
  }

  export type PreferredDiversityCreateWithoutUserPreferenceInput = {
    country: CountryCreateNestedOneWithoutPreferredDiversityInput
    city: CityCreateNestedOneWithoutPreferredDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferredDiversityInput
    community: CommunityCreateNestedOneWithoutPreferredDiversityInput
    religion: ReligionCreateNestedOneWithoutPreferredDiversityInput
  }

  export type PreferredDiversityUncheckedCreateWithoutUserPreferenceInput = {
    id?: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type PreferredDiversityCreateOrConnectWithoutUserPreferenceInput = {
    where: PreferredDiversityWhereUniqueInput
    create: XOR<PreferredDiversityCreateWithoutUserPreferenceInput, PreferredDiversityUncheckedCreateWithoutUserPreferenceInput>
  }

  export type PreferredDiversityCreateManyUserPreferenceInputEnvelope = {
    data: PreferredDiversityCreateManyUserPreferenceInput | PreferredDiversityCreateManyUserPreferenceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserPreferencesInput = {
    update: XOR<UserUpdateWithoutUserPreferencesInput, UserUncheckedUpdateWithoutUserPreferencesInput>
    create: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPreferencesInput, UserUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserUpdateWithoutUserPreferencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUsersNestedInput
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPreferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AstrologyUpsertWithoutUserPreferenceInput = {
    update: XOR<AstrologyUpdateWithoutUserPreferenceInput, AstrologyUncheckedUpdateWithoutUserPreferenceInput>
    create: XOR<AstrologyCreateWithoutUserPreferenceInput, AstrologyUncheckedCreateWithoutUserPreferenceInput>
    where?: AstrologyWhereInput
  }

  export type AstrologyUpdateToOneWithWhereWithoutUserPreferenceInput = {
    where?: AstrologyWhereInput
    data: XOR<AstrologyUpdateWithoutUserPreferenceInput, AstrologyUncheckedUpdateWithoutUserPreferenceInput>
  }

  export type AstrologyUpdateWithoutUserPreferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    AdditionalDetail?: AdditionalDetailUpdateManyWithoutAstrologyNestedInput
  }

  export type AstrologyUncheckedUpdateWithoutUserPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    AdditionalDetail?: AdditionalDetailUncheckedUpdateManyWithoutAstrologyNestedInput
  }

  export type MaritalStatusUpsertWithoutUserPreferenceInput = {
    update: XOR<MaritalStatusUpdateWithoutUserPreferenceInput, MaritalStatusUncheckedUpdateWithoutUserPreferenceInput>
    create: XOR<MaritalStatusCreateWithoutUserPreferenceInput, MaritalStatusUncheckedCreateWithoutUserPreferenceInput>
    where?: MaritalStatusWhereInput
  }

  export type MaritalStatusUpdateToOneWithWhereWithoutUserPreferenceInput = {
    where?: MaritalStatusWhereInput
    data: XOR<MaritalStatusUpdateWithoutUserPreferenceInput, MaritalStatusUncheckedUpdateWithoutUserPreferenceInput>
  }

  export type MaritalStatusUpdateWithoutUserPreferenceInput = {
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusUncheckedUpdateWithoutUserPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutMaritalStatusNestedInput
  }

  export type PreferredDiversityUpsertWithWhereUniqueWithoutUserPreferenceInput = {
    where: PreferredDiversityWhereUniqueInput
    update: XOR<PreferredDiversityUpdateWithoutUserPreferenceInput, PreferredDiversityUncheckedUpdateWithoutUserPreferenceInput>
    create: XOR<PreferredDiversityCreateWithoutUserPreferenceInput, PreferredDiversityUncheckedCreateWithoutUserPreferenceInput>
  }

  export type PreferredDiversityUpdateWithWhereUniqueWithoutUserPreferenceInput = {
    where: PreferredDiversityWhereUniqueInput
    data: XOR<PreferredDiversityUpdateWithoutUserPreferenceInput, PreferredDiversityUncheckedUpdateWithoutUserPreferenceInput>
  }

  export type PreferredDiversityUpdateManyWithWhereWithoutUserPreferenceInput = {
    where: PreferredDiversityScalarWhereInput
    data: XOR<PreferredDiversityUpdateManyMutationInput, PreferredDiversityUncheckedUpdateManyWithoutUserPreferenceInput>
  }

  export type PreferredDiversityScalarWhereInput = {
    AND?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
    OR?: PreferredDiversityScalarWhereInput[]
    NOT?: PreferredDiversityScalarWhereInput | PreferredDiversityScalarWhereInput[]
    id?: IntFilter<"PreferredDiversity"> | number
    userPreferencesId?: IntFilter<"PreferredDiversity"> | number
    countryId?: IntFilter<"PreferredDiversity"> | number
    cityId?: IntFilter<"PreferredDiversity"> | number
    motherTongueId?: IntFilter<"PreferredDiversity"> | number
    communityId?: IntFilter<"PreferredDiversity"> | number
    religionId?: IntFilter<"PreferredDiversity"> | number
  }

  export type UserPreferenceCreateWithoutPreferredDiversityInput = {
    gender: string
    minAge: number
    maxAge: number
    user: UserCreateNestedOneWithoutUserPreferencesInput
    astrology?: AstrologyCreateNestedOneWithoutUserPreferenceInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutUserPreferenceInput
  }

  export type UserPreferenceUncheckedCreateWithoutPreferredDiversityInput = {
    id?: number
    userId: number
    gender: string
    minAge: number
    maxAge: number
    astrologicalId?: number
    maritalStatusId: number
  }

  export type UserPreferenceCreateOrConnectWithoutPreferredDiversityInput = {
    where: UserPreferenceWhereUniqueInput
    create: XOR<UserPreferenceCreateWithoutPreferredDiversityInput, UserPreferenceUncheckedCreateWithoutPreferredDiversityInput>
  }

  export type CountryCreateWithoutPreferredDiversityInput = {
    title: string
    cities?: CityCreateNestedManyWithoutCountryInput
    Diversity?: DiversityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutPreferredDiversityInput = {
    id?: number
    title: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryInput
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutPreferredDiversityInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutPreferredDiversityInput, CountryUncheckedCreateWithoutPreferredDiversityInput>
  }

  export type CityCreateWithoutPreferredDiversityInput = {
    title: string
    country: CountryCreateNestedOneWithoutCitiesInput
    Diversity?: DiversityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutPreferredDiversityInput = {
    id?: number
    title: string
    countryId: number
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutPreferredDiversityInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutPreferredDiversityInput, CityUncheckedCreateWithoutPreferredDiversityInput>
  }

  export type MotherTongueCreateWithoutPreferredDiversityInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueUncheckedCreateWithoutPreferredDiversityInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutMotherTongueInput
  }

  export type MotherTongueCreateOrConnectWithoutPreferredDiversityInput = {
    where: MotherTongueWhereUniqueInput
    create: XOR<MotherTongueCreateWithoutPreferredDiversityInput, MotherTongueUncheckedCreateWithoutPreferredDiversityInput>
  }

  export type CommunityCreateWithoutPreferredDiversityInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutPreferredDiversityInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutPreferredDiversityInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutPreferredDiversityInput, CommunityUncheckedCreateWithoutPreferredDiversityInput>
  }

  export type ReligionCreateWithoutPreferredDiversityInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutReligionInput
  }

  export type ReligionUncheckedCreateWithoutPreferredDiversityInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutReligionInput
  }

  export type ReligionCreateOrConnectWithoutPreferredDiversityInput = {
    where: ReligionWhereUniqueInput
    create: XOR<ReligionCreateWithoutPreferredDiversityInput, ReligionUncheckedCreateWithoutPreferredDiversityInput>
  }

  export type UserPreferenceUpsertWithoutPreferredDiversityInput = {
    update: XOR<UserPreferenceUpdateWithoutPreferredDiversityInput, UserPreferenceUncheckedUpdateWithoutPreferredDiversityInput>
    create: XOR<UserPreferenceCreateWithoutPreferredDiversityInput, UserPreferenceUncheckedCreateWithoutPreferredDiversityInput>
    where?: UserPreferenceWhereInput
  }

  export type UserPreferenceUpdateToOneWithWhereWithoutPreferredDiversityInput = {
    where?: UserPreferenceWhereInput
    data: XOR<UserPreferenceUpdateWithoutPreferredDiversityInput, UserPreferenceUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type UserPreferenceUpdateWithoutPreferredDiversityInput = {
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserPreferencesNestedInput
    astrology?: AstrologyUpdateOneRequiredWithoutUserPreferenceNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUserPreferenceNestedInput
  }

  export type UserPreferenceUncheckedUpdateWithoutPreferredDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type CountryUpsertWithoutPreferredDiversityInput = {
    update: XOR<CountryUpdateWithoutPreferredDiversityInput, CountryUncheckedUpdateWithoutPreferredDiversityInput>
    create: XOR<CountryCreateWithoutPreferredDiversityInput, CountryUncheckedCreateWithoutPreferredDiversityInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutPreferredDiversityInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutPreferredDiversityInput, CountryUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type CountryUpdateWithoutPreferredDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryNestedInput
    Diversity?: DiversityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutPreferredDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryNestedInput
    Diversity?: DiversityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CityUpsertWithoutPreferredDiversityInput = {
    update: XOR<CityUpdateWithoutPreferredDiversityInput, CityUncheckedUpdateWithoutPreferredDiversityInput>
    create: XOR<CityCreateWithoutPreferredDiversityInput, CityUncheckedCreateWithoutPreferredDiversityInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutPreferredDiversityInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutPreferredDiversityInput, CityUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type CityUpdateWithoutPreferredDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutCitiesNestedInput
    Diversity?: DiversityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutPreferredDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    Diversity?: DiversityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type MotherTongueUpsertWithoutPreferredDiversityInput = {
    update: XOR<MotherTongueUpdateWithoutPreferredDiversityInput, MotherTongueUncheckedUpdateWithoutPreferredDiversityInput>
    create: XOR<MotherTongueCreateWithoutPreferredDiversityInput, MotherTongueUncheckedCreateWithoutPreferredDiversityInput>
    where?: MotherTongueWhereInput
  }

  export type MotherTongueUpdateToOneWithWhereWithoutPreferredDiversityInput = {
    where?: MotherTongueWhereInput
    data: XOR<MotherTongueUpdateWithoutPreferredDiversityInput, MotherTongueUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type MotherTongueUpdateWithoutPreferredDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutMotherTongueNestedInput
  }

  export type MotherTongueUncheckedUpdateWithoutPreferredDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutMotherTongueNestedInput
  }

  export type CommunityUpsertWithoutPreferredDiversityInput = {
    update: XOR<CommunityUpdateWithoutPreferredDiversityInput, CommunityUncheckedUpdateWithoutPreferredDiversityInput>
    create: XOR<CommunityCreateWithoutPreferredDiversityInput, CommunityUncheckedCreateWithoutPreferredDiversityInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutPreferredDiversityInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutPreferredDiversityInput, CommunityUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type CommunityUpdateWithoutPreferredDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutPreferredDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type ReligionUpsertWithoutPreferredDiversityInput = {
    update: XOR<ReligionUpdateWithoutPreferredDiversityInput, ReligionUncheckedUpdateWithoutPreferredDiversityInput>
    create: XOR<ReligionCreateWithoutPreferredDiversityInput, ReligionUncheckedCreateWithoutPreferredDiversityInput>
    where?: ReligionWhereInput
  }

  export type ReligionUpdateToOneWithWhereWithoutPreferredDiversityInput = {
    where?: ReligionWhereInput
    data: XOR<ReligionUpdateWithoutPreferredDiversityInput, ReligionUncheckedUpdateWithoutPreferredDiversityInput>
  }

  export type ReligionUpdateWithoutPreferredDiversityInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutReligionNestedInput
  }

  export type ReligionUncheckedUpdateWithoutPreferredDiversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutReligionNestedInput
  }

  export type UserCreateWithoutMaritalStatusInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    diversity?: DiversityCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailCreateNestedOneWithoutUserInput
    userPreferences?: UserPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMaritalStatusInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
    diversity?: DiversityUncheckedCreateNestedOneWithoutUserInput
    additionalDetail?: AdditionalDetailUncheckedCreateNestedOneWithoutUserInput
    userPreferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMaritalStatusInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput>
  }

  export type UserCreateManyMaritalStatusInputEnvelope = {
    data: UserCreateManyMaritalStatusInput | UserCreateManyMaritalStatusInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferenceCreateWithoutMaritalStatusInput = {
    gender: string
    minAge: number
    maxAge: number
    user: UserCreateNestedOneWithoutUserPreferencesInput
    astrology?: AstrologyCreateNestedOneWithoutUserPreferenceInput
    preferredDiversity?: PreferredDiversityCreateNestedManyWithoutUserPreferenceInput
  }

  export type UserPreferenceUncheckedCreateWithoutMaritalStatusInput = {
    id?: number
    userId: number
    gender: string
    minAge: number
    maxAge: number
    astrologicalId?: number
    preferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutUserPreferenceInput
  }

  export type UserPreferenceCreateOrConnectWithoutMaritalStatusInput = {
    where: UserPreferenceWhereUniqueInput
    create: XOR<UserPreferenceCreateWithoutMaritalStatusInput, UserPreferenceUncheckedCreateWithoutMaritalStatusInput>
  }

  export type UserPreferenceCreateManyMaritalStatusInputEnvelope = {
    data: UserPreferenceCreateManyMaritalStatusInput | UserPreferenceCreateManyMaritalStatusInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutMaritalStatusInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutMaritalStatusInput, UserUncheckedUpdateWithoutMaritalStatusInput>
    create: XOR<UserCreateWithoutMaritalStatusInput, UserUncheckedCreateWithoutMaritalStatusInput>
  }

  export type UserUpdateWithWhereUniqueWithoutMaritalStatusInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutMaritalStatusInput, UserUncheckedUpdateWithoutMaritalStatusInput>
  }

  export type UserUpdateManyWithWhereWithoutMaritalStatusInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutMaritalStatusInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeFilter<"User"> | Date | string
    gender?: StringFilter<"User"> | string
    bio?: StringFilter<"User"> | string
    image?: StringFilter<"User"> | string
    maritalStatusId?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
  }

  export type UserPreferenceUpsertWithWhereUniqueWithoutMaritalStatusInput = {
    where: UserPreferenceWhereUniqueInput
    update: XOR<UserPreferenceUpdateWithoutMaritalStatusInput, UserPreferenceUncheckedUpdateWithoutMaritalStatusInput>
    create: XOR<UserPreferenceCreateWithoutMaritalStatusInput, UserPreferenceUncheckedCreateWithoutMaritalStatusInput>
  }

  export type UserPreferenceUpdateWithWhereUniqueWithoutMaritalStatusInput = {
    where: UserPreferenceWhereUniqueInput
    data: XOR<UserPreferenceUpdateWithoutMaritalStatusInput, UserPreferenceUncheckedUpdateWithoutMaritalStatusInput>
  }

  export type UserPreferenceUpdateManyWithWhereWithoutMaritalStatusInput = {
    where: UserPreferenceScalarWhereInput
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyWithoutMaritalStatusInput>
  }

  export type UserPreferenceScalarWhereInput = {
    AND?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
    OR?: UserPreferenceScalarWhereInput[]
    NOT?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
    id?: IntFilter<"UserPreference"> | number
    userId?: IntFilter<"UserPreference"> | number
    gender?: StringFilter<"UserPreference"> | string
    minAge?: IntFilter<"UserPreference"> | number
    maxAge?: IntFilter<"UserPreference"> | number
    astrologicalId?: IntFilter<"UserPreference"> | number
    maritalStatusId?: IntFilter<"UserPreference"> | number
  }

  export type DiversityCreateWithoutReligionInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutReligionInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutReligionInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput>
  }

  export type DiversityCreateManyReligionInputEnvelope = {
    data: DiversityCreateManyReligionInput | DiversityCreateManyReligionInput[]
    skipDuplicates?: boolean
  }

  export type PreferredDiversityCreateWithoutReligionInput = {
    userPreference: UserPreferenceCreateNestedOneWithoutPreferredDiversityInput
    country: CountryCreateNestedOneWithoutPreferredDiversityInput
    city: CityCreateNestedOneWithoutPreferredDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferredDiversityInput
    community: CommunityCreateNestedOneWithoutPreferredDiversityInput
  }

  export type PreferredDiversityUncheckedCreateWithoutReligionInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
  }

  export type PreferredDiversityCreateOrConnectWithoutReligionInput = {
    where: PreferredDiversityWhereUniqueInput
    create: XOR<PreferredDiversityCreateWithoutReligionInput, PreferredDiversityUncheckedCreateWithoutReligionInput>
  }

  export type PreferredDiversityCreateManyReligionInputEnvelope = {
    data: PreferredDiversityCreateManyReligionInput | PreferredDiversityCreateManyReligionInput[]
    skipDuplicates?: boolean
  }

  export type DiversityUpsertWithWhereUniqueWithoutReligionInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutReligionInput, DiversityUncheckedUpdateWithoutReligionInput>
    create: XOR<DiversityCreateWithoutReligionInput, DiversityUncheckedCreateWithoutReligionInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutReligionInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutReligionInput, DiversityUncheckedUpdateWithoutReligionInput>
  }

  export type DiversityUpdateManyWithWhereWithoutReligionInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutReligionInput>
  }

  export type DiversityScalarWhereInput = {
    AND?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
    OR?: DiversityScalarWhereInput[]
    NOT?: DiversityScalarWhereInput | DiversityScalarWhereInput[]
    id?: IntFilter<"Diversity"> | number
    userId?: IntFilter<"Diversity"> | number
    religionId?: IntFilter<"Diversity"> | number
    countryId?: IntFilter<"Diversity"> | number
    cityId?: IntFilter<"Diversity"> | number
    communityId?: IntFilter<"Diversity"> | number
    motherTongueId?: IntFilter<"Diversity"> | number
  }

  export type PreferredDiversityUpsertWithWhereUniqueWithoutReligionInput = {
    where: PreferredDiversityWhereUniqueInput
    update: XOR<PreferredDiversityUpdateWithoutReligionInput, PreferredDiversityUncheckedUpdateWithoutReligionInput>
    create: XOR<PreferredDiversityCreateWithoutReligionInput, PreferredDiversityUncheckedCreateWithoutReligionInput>
  }

  export type PreferredDiversityUpdateWithWhereUniqueWithoutReligionInput = {
    where: PreferredDiversityWhereUniqueInput
    data: XOR<PreferredDiversityUpdateWithoutReligionInput, PreferredDiversityUncheckedUpdateWithoutReligionInput>
  }

  export type PreferredDiversityUpdateManyWithWhereWithoutReligionInput = {
    where: PreferredDiversityScalarWhereInput
    data: XOR<PreferredDiversityUpdateManyMutationInput, PreferredDiversityUncheckedUpdateManyWithoutReligionInput>
  }

  export type CityCreateWithoutCountryInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutCityInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCityInput
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityCreateManyCountryInputEnvelope = {
    data: CityCreateManyCountryInput | CityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type DiversityCreateWithoutCountryInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutCountryInput = {
    id?: number
    userId: number
    religionId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutCountryInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput>
  }

  export type DiversityCreateManyCountryInputEnvelope = {
    data: DiversityCreateManyCountryInput | DiversityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type PreferredDiversityCreateWithoutCountryInput = {
    userPreference: UserPreferenceCreateNestedOneWithoutPreferredDiversityInput
    city: CityCreateNestedOneWithoutPreferredDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferredDiversityInput
    community: CommunityCreateNestedOneWithoutPreferredDiversityInput
    religion: ReligionCreateNestedOneWithoutPreferredDiversityInput
  }

  export type PreferredDiversityUncheckedCreateWithoutCountryInput = {
    id?: number
    userPreferencesId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type PreferredDiversityCreateOrConnectWithoutCountryInput = {
    where: PreferredDiversityWhereUniqueInput
    create: XOR<PreferredDiversityCreateWithoutCountryInput, PreferredDiversityUncheckedCreateWithoutCountryInput>
  }

  export type PreferredDiversityCreateManyCountryInputEnvelope = {
    data: PreferredDiversityCreateManyCountryInput | PreferredDiversityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
    create: XOR<CityCreateWithoutCountryInput, CityUncheckedCreateWithoutCountryInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryInput, CityUncheckedUpdateWithoutCountryInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: IntFilter<"City"> | number
    title?: StringFilter<"City"> | string
    countryId?: IntFilter<"City"> | number
  }

  export type DiversityUpsertWithWhereUniqueWithoutCountryInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutCountryInput, DiversityUncheckedUpdateWithoutCountryInput>
    create: XOR<DiversityCreateWithoutCountryInput, DiversityUncheckedCreateWithoutCountryInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutCountryInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutCountryInput, DiversityUncheckedUpdateWithoutCountryInput>
  }

  export type DiversityUpdateManyWithWhereWithoutCountryInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutCountryInput>
  }

  export type PreferredDiversityUpsertWithWhereUniqueWithoutCountryInput = {
    where: PreferredDiversityWhereUniqueInput
    update: XOR<PreferredDiversityUpdateWithoutCountryInput, PreferredDiversityUncheckedUpdateWithoutCountryInput>
    create: XOR<PreferredDiversityCreateWithoutCountryInput, PreferredDiversityUncheckedCreateWithoutCountryInput>
  }

  export type PreferredDiversityUpdateWithWhereUniqueWithoutCountryInput = {
    where: PreferredDiversityWhereUniqueInput
    data: XOR<PreferredDiversityUpdateWithoutCountryInput, PreferredDiversityUncheckedUpdateWithoutCountryInput>
  }

  export type PreferredDiversityUpdateManyWithWhereWithoutCountryInput = {
    where: PreferredDiversityScalarWhereInput
    data: XOR<PreferredDiversityUpdateManyMutationInput, PreferredDiversityUncheckedUpdateManyWithoutCountryInput>
  }

  export type CountryCreateWithoutCitiesInput = {
    title: string
    Diversity?: DiversityCreateNestedManyWithoutCountryInput
    PreferredDiversity?: PreferredDiversityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    id?: number
    title: string
    Diversity?: DiversityUncheckedCreateNestedManyWithoutCountryInput
    PreferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type DiversityCreateWithoutCityInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutCityInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    communityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutCityInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput>
  }

  export type DiversityCreateManyCityInputEnvelope = {
    data: DiversityCreateManyCityInput | DiversityCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type PreferredDiversityCreateWithoutCityInput = {
    userPreference: UserPreferenceCreateNestedOneWithoutPreferredDiversityInput
    country: CountryCreateNestedOneWithoutPreferredDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferredDiversityInput
    community: CommunityCreateNestedOneWithoutPreferredDiversityInput
    religion: ReligionCreateNestedOneWithoutPreferredDiversityInput
  }

  export type PreferredDiversityUncheckedCreateWithoutCityInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type PreferredDiversityCreateOrConnectWithoutCityInput = {
    where: PreferredDiversityWhereUniqueInput
    create: XOR<PreferredDiversityCreateWithoutCityInput, PreferredDiversityUncheckedCreateWithoutCityInput>
  }

  export type PreferredDiversityCreateManyCityInputEnvelope = {
    data: PreferredDiversityCreateManyCityInput | PreferredDiversityCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCitiesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutCountryNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutCountryNestedInput
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type DiversityUpsertWithWhereUniqueWithoutCityInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutCityInput, DiversityUncheckedUpdateWithoutCityInput>
    create: XOR<DiversityCreateWithoutCityInput, DiversityUncheckedCreateWithoutCityInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutCityInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutCityInput, DiversityUncheckedUpdateWithoutCityInput>
  }

  export type DiversityUpdateManyWithWhereWithoutCityInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutCityInput>
  }

  export type PreferredDiversityUpsertWithWhereUniqueWithoutCityInput = {
    where: PreferredDiversityWhereUniqueInput
    update: XOR<PreferredDiversityUpdateWithoutCityInput, PreferredDiversityUncheckedUpdateWithoutCityInput>
    create: XOR<PreferredDiversityCreateWithoutCityInput, PreferredDiversityUncheckedCreateWithoutCityInput>
  }

  export type PreferredDiversityUpdateWithWhereUniqueWithoutCityInput = {
    where: PreferredDiversityWhereUniqueInput
    data: XOR<PreferredDiversityUpdateWithoutCityInput, PreferredDiversityUncheckedUpdateWithoutCityInput>
  }

  export type PreferredDiversityUpdateManyWithWhereWithoutCityInput = {
    where: PreferredDiversityScalarWhereInput
    data: XOR<PreferredDiversityUpdateManyMutationInput, PreferredDiversityUncheckedUpdateManyWithoutCityInput>
  }

  export type DiversityCreateWithoutCommunityInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutCommunityInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    motherTongueId: number
  }

  export type DiversityCreateOrConnectWithoutCommunityInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput>
  }

  export type DiversityCreateManyCommunityInputEnvelope = {
    data: DiversityCreateManyCommunityInput | DiversityCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type PreferredDiversityCreateWithoutCommunityInput = {
    userPreference: UserPreferenceCreateNestedOneWithoutPreferredDiversityInput
    country: CountryCreateNestedOneWithoutPreferredDiversityInput
    city: CityCreateNestedOneWithoutPreferredDiversityInput
    motherTongue: MotherTongueCreateNestedOneWithoutPreferredDiversityInput
    religion: ReligionCreateNestedOneWithoutPreferredDiversityInput
  }

  export type PreferredDiversityUncheckedCreateWithoutCommunityInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    cityId: number
    motherTongueId: number
    religionId: number
  }

  export type PreferredDiversityCreateOrConnectWithoutCommunityInput = {
    where: PreferredDiversityWhereUniqueInput
    create: XOR<PreferredDiversityCreateWithoutCommunityInput, PreferredDiversityUncheckedCreateWithoutCommunityInput>
  }

  export type PreferredDiversityCreateManyCommunityInputEnvelope = {
    data: PreferredDiversityCreateManyCommunityInput | PreferredDiversityCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type DiversityUpsertWithWhereUniqueWithoutCommunityInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutCommunityInput, DiversityUncheckedUpdateWithoutCommunityInput>
    create: XOR<DiversityCreateWithoutCommunityInput, DiversityUncheckedCreateWithoutCommunityInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutCommunityInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutCommunityInput, DiversityUncheckedUpdateWithoutCommunityInput>
  }

  export type DiversityUpdateManyWithWhereWithoutCommunityInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutCommunityInput>
  }

  export type PreferredDiversityUpsertWithWhereUniqueWithoutCommunityInput = {
    where: PreferredDiversityWhereUniqueInput
    update: XOR<PreferredDiversityUpdateWithoutCommunityInput, PreferredDiversityUncheckedUpdateWithoutCommunityInput>
    create: XOR<PreferredDiversityCreateWithoutCommunityInput, PreferredDiversityUncheckedCreateWithoutCommunityInput>
  }

  export type PreferredDiversityUpdateWithWhereUniqueWithoutCommunityInput = {
    where: PreferredDiversityWhereUniqueInput
    data: XOR<PreferredDiversityUpdateWithoutCommunityInput, PreferredDiversityUncheckedUpdateWithoutCommunityInput>
  }

  export type PreferredDiversityUpdateManyWithWhereWithoutCommunityInput = {
    where: PreferredDiversityScalarWhereInput
    data: XOR<PreferredDiversityUpdateManyMutationInput, PreferredDiversityUncheckedUpdateManyWithoutCommunityInput>
  }

  export type DiversityCreateWithoutMotherTongueInput = {
    user: UserCreateNestedOneWithoutDiversityInput
    religion: ReligionCreateNestedOneWithoutDiversityInput
    country: CountryCreateNestedOneWithoutDiversityInput
    city: CityCreateNestedOneWithoutDiversityInput
    community: CommunityCreateNestedOneWithoutDiversityInput
  }

  export type DiversityUncheckedCreateWithoutMotherTongueInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
  }

  export type DiversityCreateOrConnectWithoutMotherTongueInput = {
    where: DiversityWhereUniqueInput
    create: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput>
  }

  export type DiversityCreateManyMotherTongueInputEnvelope = {
    data: DiversityCreateManyMotherTongueInput | DiversityCreateManyMotherTongueInput[]
    skipDuplicates?: boolean
  }

  export type PreferredDiversityCreateWithoutMotherTongueInput = {
    userPreference: UserPreferenceCreateNestedOneWithoutPreferredDiversityInput
    country: CountryCreateNestedOneWithoutPreferredDiversityInput
    city: CityCreateNestedOneWithoutPreferredDiversityInput
    community: CommunityCreateNestedOneWithoutPreferredDiversityInput
    religion: ReligionCreateNestedOneWithoutPreferredDiversityInput
  }

  export type PreferredDiversityUncheckedCreateWithoutMotherTongueInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    cityId: number
    communityId: number
    religionId: number
  }

  export type PreferredDiversityCreateOrConnectWithoutMotherTongueInput = {
    where: PreferredDiversityWhereUniqueInput
    create: XOR<PreferredDiversityCreateWithoutMotherTongueInput, PreferredDiversityUncheckedCreateWithoutMotherTongueInput>
  }

  export type PreferredDiversityCreateManyMotherTongueInputEnvelope = {
    data: PreferredDiversityCreateManyMotherTongueInput | PreferredDiversityCreateManyMotherTongueInput[]
    skipDuplicates?: boolean
  }

  export type DiversityUpsertWithWhereUniqueWithoutMotherTongueInput = {
    where: DiversityWhereUniqueInput
    update: XOR<DiversityUpdateWithoutMotherTongueInput, DiversityUncheckedUpdateWithoutMotherTongueInput>
    create: XOR<DiversityCreateWithoutMotherTongueInput, DiversityUncheckedCreateWithoutMotherTongueInput>
  }

  export type DiversityUpdateWithWhereUniqueWithoutMotherTongueInput = {
    where: DiversityWhereUniqueInput
    data: XOR<DiversityUpdateWithoutMotherTongueInput, DiversityUncheckedUpdateWithoutMotherTongueInput>
  }

  export type DiversityUpdateManyWithWhereWithoutMotherTongueInput = {
    where: DiversityScalarWhereInput
    data: XOR<DiversityUpdateManyMutationInput, DiversityUncheckedUpdateManyWithoutMotherTongueInput>
  }

  export type PreferredDiversityUpsertWithWhereUniqueWithoutMotherTongueInput = {
    where: PreferredDiversityWhereUniqueInput
    update: XOR<PreferredDiversityUpdateWithoutMotherTongueInput, PreferredDiversityUncheckedUpdateWithoutMotherTongueInput>
    create: XOR<PreferredDiversityCreateWithoutMotherTongueInput, PreferredDiversityUncheckedCreateWithoutMotherTongueInput>
  }

  export type PreferredDiversityUpdateWithWhereUniqueWithoutMotherTongueInput = {
    where: PreferredDiversityWhereUniqueInput
    data: XOR<PreferredDiversityUpdateWithoutMotherTongueInput, PreferredDiversityUncheckedUpdateWithoutMotherTongueInput>
  }

  export type PreferredDiversityUpdateManyWithWhereWithoutMotherTongueInput = {
    where: PreferredDiversityScalarWhereInput
    data: XOR<PreferredDiversityUpdateManyMutationInput, PreferredDiversityUncheckedUpdateManyWithoutMotherTongueInput>
  }

  export type AdditionalDetailCreateWithoutAstrologyInput = {
    facebookProfileLink: string
    contactNumber: string
    user: UserCreateNestedOneWithoutAdditionalDetailInput
  }

  export type AdditionalDetailUncheckedCreateWithoutAstrologyInput = {
    id?: number
    userId: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type AdditionalDetailCreateOrConnectWithoutAstrologyInput = {
    where: AdditionalDetailWhereUniqueInput
    create: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput>
  }

  export type AdditionalDetailCreateManyAstrologyInputEnvelope = {
    data: AdditionalDetailCreateManyAstrologyInput | AdditionalDetailCreateManyAstrologyInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferenceCreateWithoutAstrologyInput = {
    gender: string
    minAge: number
    maxAge: number
    user: UserCreateNestedOneWithoutUserPreferencesInput
    maritalStatus: MaritalStatusCreateNestedOneWithoutUserPreferenceInput
    preferredDiversity?: PreferredDiversityCreateNestedManyWithoutUserPreferenceInput
  }

  export type UserPreferenceUncheckedCreateWithoutAstrologyInput = {
    id?: number
    userId: number
    gender: string
    minAge: number
    maxAge: number
    maritalStatusId: number
    preferredDiversity?: PreferredDiversityUncheckedCreateNestedManyWithoutUserPreferenceInput
  }

  export type UserPreferenceCreateOrConnectWithoutAstrologyInput = {
    where: UserPreferenceWhereUniqueInput
    create: XOR<UserPreferenceCreateWithoutAstrologyInput, UserPreferenceUncheckedCreateWithoutAstrologyInput>
  }

  export type UserPreferenceCreateManyAstrologyInputEnvelope = {
    data: UserPreferenceCreateManyAstrologyInput | UserPreferenceCreateManyAstrologyInput[]
    skipDuplicates?: boolean
  }

  export type AdditionalDetailUpsertWithWhereUniqueWithoutAstrologyInput = {
    where: AdditionalDetailWhereUniqueInput
    update: XOR<AdditionalDetailUpdateWithoutAstrologyInput, AdditionalDetailUncheckedUpdateWithoutAstrologyInput>
    create: XOR<AdditionalDetailCreateWithoutAstrologyInput, AdditionalDetailUncheckedCreateWithoutAstrologyInput>
  }

  export type AdditionalDetailUpdateWithWhereUniqueWithoutAstrologyInput = {
    where: AdditionalDetailWhereUniqueInput
    data: XOR<AdditionalDetailUpdateWithoutAstrologyInput, AdditionalDetailUncheckedUpdateWithoutAstrologyInput>
  }

  export type AdditionalDetailUpdateManyWithWhereWithoutAstrologyInput = {
    where: AdditionalDetailScalarWhereInput
    data: XOR<AdditionalDetailUpdateManyMutationInput, AdditionalDetailUncheckedUpdateManyWithoutAstrologyInput>
  }

  export type AdditionalDetailScalarWhereInput = {
    AND?: AdditionalDetailScalarWhereInput | AdditionalDetailScalarWhereInput[]
    OR?: AdditionalDetailScalarWhereInput[]
    NOT?: AdditionalDetailScalarWhereInput | AdditionalDetailScalarWhereInput[]
    id?: IntFilter<"AdditionalDetail"> | number
    userId?: IntFilter<"AdditionalDetail"> | number
    astrologicalId?: IntFilter<"AdditionalDetail"> | number
    facebookProfileLink?: StringFilter<"AdditionalDetail"> | string
    contactNumber?: StringFilter<"AdditionalDetail"> | string
  }

  export type UserPreferenceUpsertWithWhereUniqueWithoutAstrologyInput = {
    where: UserPreferenceWhereUniqueInput
    update: XOR<UserPreferenceUpdateWithoutAstrologyInput, UserPreferenceUncheckedUpdateWithoutAstrologyInput>
    create: XOR<UserPreferenceCreateWithoutAstrologyInput, UserPreferenceUncheckedCreateWithoutAstrologyInput>
  }

  export type UserPreferenceUpdateWithWhereUniqueWithoutAstrologyInput = {
    where: UserPreferenceWhereUniqueInput
    data: XOR<UserPreferenceUpdateWithoutAstrologyInput, UserPreferenceUncheckedUpdateWithoutAstrologyInput>
  }

  export type UserPreferenceUpdateManyWithWhereWithoutAstrologyInput = {
    where: UserPreferenceScalarWhereInput
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyWithoutAstrologyInput>
  }

  export type PreferredDiversityCreateManyUserPreferenceInput = {
    id?: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type PreferredDiversityUpdateWithoutUserPreferenceInput = {
    country?: CountryUpdateOneRequiredWithoutPreferredDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferredDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferredDiversityNestedInput
  }

  export type PreferredDiversityUncheckedUpdateWithoutUserPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutUserPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateManyMaritalStatusInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: string
    bio: string
    image: string
    password: string
  }

  export type UserPreferenceCreateManyMaritalStatusInput = {
    id?: number
    userId: number
    gender: string
    minAge: number
    maxAge: number
    astrologicalId?: number
  }

  export type UserUpdateWithoutMaritalStatusInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUpdateOneWithoutUserNestedInput
    userPreferences?: UserPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    diversity?: DiversityUncheckedUpdateOneWithoutUserNestedInput
    additionalDetail?: AdditionalDetailUncheckedUpdateOneWithoutUserNestedInput
    userPreferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserPreferenceUpdateWithoutMaritalStatusInput = {
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserPreferencesNestedInput
    astrology?: AstrologyUpdateOneRequiredWithoutUserPreferenceNestedInput
    preferredDiversity?: PreferredDiversityUpdateManyWithoutUserPreferenceNestedInput
  }

  export type UserPreferenceUncheckedUpdateWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
    preferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutUserPreferenceNestedInput
  }

  export type UserPreferenceUncheckedUpdateManyWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    astrologicalId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyReligionInput = {
    id?: number
    userId: number
    countryId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type PreferredDiversityCreateManyReligionInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    cityId: number
    motherTongueId: number
    communityId: number
  }

  export type DiversityUpdateWithoutReligionInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUpdateWithoutReligionInput = {
    userPreference?: UserPreferenceUpdateOneRequiredWithoutPreferredDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferredDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferredDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferredDiversityNestedInput
  }

  export type PreferredDiversityUncheckedUpdateWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutReligionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type CityCreateManyCountryInput = {
    id?: number
    title: string
  }

  export type DiversityCreateManyCountryInput = {
    id?: number
    userId: number
    religionId: number
    cityId: number
    communityId: number
    motherTongueId: number
  }

  export type PreferredDiversityCreateManyCountryInput = {
    id?: number
    userPreferencesId: number
    cityId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type CityUpdateWithoutCountryInput = {
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUpdateManyWithoutCityNestedInput
    PreferredDiversity?: PreferredDiversityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Diversity?: DiversityUncheckedUpdateManyWithoutCityNestedInput
    PreferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type DiversityUpdateWithoutCountryInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUpdateWithoutCountryInput = {
    userPreference?: UserPreferenceUpdateOneRequiredWithoutPreferredDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferredDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferredDiversityNestedInput
  }

  export type PreferredDiversityUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyCityInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    communityId: number
    motherTongueId: number
  }

  export type PreferredDiversityCreateManyCityInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    motherTongueId: number
    communityId: number
    religionId: number
  }

  export type DiversityUpdateWithoutCityInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUpdateWithoutCityInput = {
    userPreference?: UserPreferenceUpdateOneRequiredWithoutPreferredDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferredDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferredDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferredDiversityNestedInput
  }

  export type PreferredDiversityUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyCommunityInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    motherTongueId: number
  }

  export type PreferredDiversityCreateManyCommunityInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    cityId: number
    motherTongueId: number
    religionId: number
  }

  export type DiversityUpdateWithoutCommunityInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUpdateWithoutCommunityInput = {
    userPreference?: UserPreferenceUpdateOneRequiredWithoutPreferredDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferredDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    motherTongue?: MotherTongueUpdateOneRequiredWithoutPreferredDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferredDiversityNestedInput
  }

  export type PreferredDiversityUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    motherTongueId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityCreateManyMotherTongueInput = {
    id?: number
    userId: number
    religionId: number
    countryId: number
    cityId: number
    communityId: number
  }

  export type PreferredDiversityCreateManyMotherTongueInput = {
    id?: number
    userPreferencesId: number
    countryId: number
    cityId: number
    communityId: number
    religionId: number
  }

  export type DiversityUpdateWithoutMotherTongueInput = {
    user?: UserUpdateOneRequiredWithoutDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutDiversityNestedInput
  }

  export type DiversityUncheckedUpdateWithoutMotherTongueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type DiversityUncheckedUpdateManyWithoutMotherTongueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUpdateWithoutMotherTongueInput = {
    userPreference?: UserPreferenceUpdateOneRequiredWithoutPreferredDiversityNestedInput
    country?: CountryUpdateOneRequiredWithoutPreferredDiversityNestedInput
    city?: CityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    community?: CommunityUpdateOneRequiredWithoutPreferredDiversityNestedInput
    religion?: ReligionUpdateOneRequiredWithoutPreferredDiversityNestedInput
  }

  export type PreferredDiversityUncheckedUpdateWithoutMotherTongueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferredDiversityUncheckedUpdateManyWithoutMotherTongueInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPreferencesId?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    communityId?: IntFieldUpdateOperationsInput | number
    religionId?: IntFieldUpdateOperationsInput | number
  }

  export type AdditionalDetailCreateManyAstrologyInput = {
    id?: number
    userId: number
    facebookProfileLink: string
    contactNumber: string
  }

  export type UserPreferenceCreateManyAstrologyInput = {
    id?: number
    userId: number
    gender: string
    minAge: number
    maxAge: number
    maritalStatusId: number
  }

  export type AdditionalDetailUpdateWithoutAstrologyInput = {
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAdditionalDetailNestedInput
  }

  export type AdditionalDetailUncheckedUpdateWithoutAstrologyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalDetailUncheckedUpdateManyWithoutAstrologyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    facebookProfileLink?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
  }

  export type UserPreferenceUpdateWithoutAstrologyInput = {
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserPreferencesNestedInput
    maritalStatus?: MaritalStatusUpdateOneRequiredWithoutUserPreferenceNestedInput
    preferredDiversity?: PreferredDiversityUpdateManyWithoutUserPreferenceNestedInput
  }

  export type UserPreferenceUncheckedUpdateWithoutAstrologyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
    preferredDiversity?: PreferredDiversityUncheckedUpdateManyWithoutUserPreferenceNestedInput
  }

  export type UserPreferenceUncheckedUpdateManyWithoutAstrologyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    minAge?: IntFieldUpdateOperationsInput | number
    maxAge?: IntFieldUpdateOperationsInput | number
    maritalStatusId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserPreferenceCountOutputTypeDefaultArgs instead
     */
    export type UserPreferenceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserPreferenceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaritalStatusCountOutputTypeDefaultArgs instead
     */
    export type MaritalStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaritalStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReligionCountOutputTypeDefaultArgs instead
     */
    export type ReligionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReligionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryCountOutputTypeDefaultArgs instead
     */
    export type CountryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityCountOutputTypeDefaultArgs instead
     */
    export type CommunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MotherTongueCountOutputTypeDefaultArgs instead
     */
    export type MotherTongueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MotherTongueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AstrologyCountOutputTypeDefaultArgs instead
     */
    export type AstrologyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AstrologyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiversityDefaultArgs instead
     */
    export type DiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiversityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdditionalDetailDefaultArgs instead
     */
    export type AdditionalDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdditionalDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserPreferenceDefaultArgs instead
     */
    export type UserPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PreferredDiversityDefaultArgs instead
     */
    export type PreferredDiversityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PreferredDiversityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaritalStatusDefaultArgs instead
     */
    export type MaritalStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaritalStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReligionDefaultArgs instead
     */
    export type ReligionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReligionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryDefaultArgs instead
     */
    export type CountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityDefaultArgs instead
     */
    export type CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MotherTongueDefaultArgs instead
     */
    export type MotherTongueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MotherTongueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AstrologyDefaultArgs instead
     */
    export type AstrologyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AstrologyDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}